<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pigDong</title>
  
  
  <link href="https://mrchen229.github.io/atom.xml" rel="self"/>
  
  <link href="https://mrchen229.github.io/"/>
  <updated>2020-08-31T07:10:37.899Z</updated>
  <id>https://mrchen229.github.io/</id>
  
  <author>
    <name>pigDong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>后台前端_Vuetify_nginx反向代理_商品分类_cors跨域_品牌查询_axios_分页和过滤</title>
    <link href="https://mrchen229.github.io/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/"/>
    <id>https://mrchen229.github.io/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/</id>
    <published>2020-08-31T07:10:08.000Z</published>
    <updated>2020-08-31T07:10:37.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li><p>后台前端的目录结构</p></li><li><p>Vuetify的项目页面布局</p></li><li><p>nginx反向代理解决端口问题</p></li><li><p>商品分类查询功能</p><ul><li>JPA</li><li>通用Mapper</li></ul></li><li><p>cors解决跨域</p></li><li><p>品牌查询功能</p><ul><li>异步查询axios</li><li>分页和过滤</li></ul></li></ul><h1 id="1-搭建后台管理前端"><a href="#1-搭建后台管理前端" class="headerlink" title="1. 搭建后台管理前端"></a>1. 搭建后台管理前端</h1><h2 id="1-1-导入已有资源"><a href="#1-1-导入已有资源" class="headerlink" title="1.1 导入已有资源"></a>1.1 导入已有资源</h2><p>后台项目相对复杂，使用资料中的code：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530555871804.png" alt="1530555871804" style="zoom:67%;"><p>我们解压缩，放到工作目录中：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530367369490.png" alt="1530367369490" style="zoom:67%;"><p>然后在Intellij idea中导入新的工程：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530367589197.png" alt="1530367589197" style="zoom:80%;"><p>选中我们的工程：</p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530367781173.png" alt="1530367781173" style="zoom:67%;"><h2 id="1-2-安装依赖"><a href="#1-2-安装依赖" class="headerlink" title="1.2 安装依赖"></a>1.2 安装依赖</h2><p>这里并没有node_modules文件夹，package.json中定义了所需的一切依赖：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530368695265.png" alt="1530368695265" style="zoom:67%;"><p>我们只需要打开终端，进入项目目录，输入：<code>npm install</code>命令，即可安装这些依赖。</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530374769782.png" alt="1530374769782" style="zoom: 67%;"><p>大概需要几分钟。</p><p><strong>如果安装过程出现以下问题</strong>：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530374827792.png" alt="1530374827792" style="zoom:67%;"><p>建议删除node_modules目录，重新安装。或者copy其他人的node_modules使用</p><h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3 运行"></a>1.3 运行</h2><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1540706914029.png" alt="1540706914029" style="zoom:67%;"><p>在package.json文件中有scripts启动脚本配置，可以输入命令：<code>npm run dev</code>或者<code>npm start</code></p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530374954209.png" alt="1530374954209" style="zoom:67%;"><p>发现默认的端口是9001。访问：<a href="http://localhost:9001/">http://localhost:9001</a></p><p>会自动进行跳转：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530375152204.png" alt="1525958950616" style="zoom: 33%;"><h2 id="1-4-目录结构"><a href="#1-4-目录结构" class="headerlink" title="1.4 目录结构"></a>1.4 目录结构</h2> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525962755237.png" alt="1525962755237" style="zoom:80%;"><p>webpack：是一个现代 JavaScript 应用程序的**静态模块打包器(module bundler)**。并且提供了前端项目的热部署插件。</p><h2 id="1-5-调用关系"><a href="#1-5-调用关系" class="headerlink" title="1.5 调用关系"></a>1.5 调用关系</h2><p>我们最主要理清index.html、main.js、App.vue之间的关系：</p><p>注意：若文件夹中仅有一个index.js，可以直接引入文件夹就成</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525964023585.png" alt="1525964023585"></p><p>理一下：</p><ul><li><code>index.html</code>：html模板文件。定义了空的<code>div</code>，其id为<code>app</code>。</li><li><code>main.js</code>：<strong>实例化vue对象</strong>，并且通过id选择器绑定到index.html的div中，因此<strong>main.js的内容都将在index.html的div中显示</strong>。main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就<strong>拥有了vue的内容（包括组件、样式等）</strong>，所以，main.js也是<strong>webpack打包的入口</strong>。</li><li><code>index.js</code>：定义请求路径和组件的映射关系。相当于之前的<code>&lt;vue-router&gt;</code></li><li><code>App.vue</code>中也没有内容，而是定义了vue-router的锚点：<code>&lt;router-view&gt;</code>,我们之前讲过，vue-router路由后的组件将会在锚点展示。</li><li>最终结论：<strong>一切路由后的内容都将通过App.vue在index.html中显示。</strong></li><li><strong>访问流程</strong>：用户在浏览器输入路径，例如：<a href="http://localhost:9001/#/item/brand">http://localhost:9001/#/item/brand</a> –&gt; index.js(<code>/item/brand</code>路径对应<code>pages/item/Brand.vue</code>组件) –&gt; 该组件显示在App.vue的锚点位置 –&gt; main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中）</li></ul><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1543399927909.png" alt="1543399927909"></p><h1 id="2-Vuetify框架"><a href="#2-Vuetify框架" class="headerlink" title="2. Vuetify框架"></a>2. Vuetify框架</h1><h2 id="2-1-为什么要学习UI框架"><a href="#2-1-为什么要学习UI框架" class="headerlink" title="2.1 为什么要学习UI框架"></a>2.1 为什么要学习UI框架</h2><p>Vue虽然会帮我们进行视图的渲染，但样式还是由我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如：</p><ul><li>BootStrap</li><li>LayUI</li><li>EasyUI</li><li>ZUI</li></ul><p>然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。</p><p>而目前与Vue吻合的UI框架也非常的多，国内比较知名的如：</p><ul><li>element-ui：饿了么出品</li><li>i-view：某公司出品</li></ul><p>然而今天推荐的是一款国外的框架：Vuetify</p><p>官方网站：<a href="https://vuetifyjs.com/zh-Hans/">https://vuetifyjs.com/zh-Hans/</a></p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525960652724.png" alt="1525960652724" style="zoom:50%;"><h2 id="2-2-为什么是Vuetify"><a href="#2-2-为什么是Vuetify" class="headerlink" title="2.2 为什么是Vuetify"></a>2.2 为什么是Vuetify</h2><p>有中国的为什么还要用外国的？原因如下：</p><ul><li>Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写</li><li>Vuetify从底层构建起来的语义化组件。简单易学，容易记住。</li><li>Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一</li></ul><p>官网说明：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530555978248.png" alt="1530555978248"></p><p>缺陷：</p><ul><li>目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。</li></ul><h2 id="2-3-用法"><a href="#2-3-用法" class="headerlink" title="2.3 用法"></a>2.3 用法</h2><p>基于官方网站的文档进行学习：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525960312939.png" alt="1525960312939" style="zoom:80%;"><p>我们重点关注<code>UI components</code>即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么：</p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525961862771.png" alt="1525961862771" style="zoom:80%;"> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525961875288.png" alt="1525961875288" style="zoom:80%;"><p>以后用到什么组件，就来查询即可。</p><h2 id="2-4-项目页面布局"><a href="#2-4-项目页面布局" class="headerlink" title="2.4 项目页面布局"></a>2.4 项目页面布局</h2><p>接下来我们一起看下页面布局。</p><p>Layout组件是我们的整个页面的布局组件：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530380040278.png" alt="1530380040278" style="zoom:67%;"><p>一个典型的三块布局。包含左，上，中三部分：</p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525965779366.png" alt="1525965779366" style="zoom:80%;"><p>里面使用了Vuetify中的2个组件和一个布局元素：</p><ul><li><p><code>v-navigation-drawer</code> ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 </p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1532577155616.png" alt="1532577155616" style="zoom: 67%;"></li><li><p><code>v-toolbar </code>：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530380292558.png" alt="1530380292558"></p></li><li><p><code>v-content</code>：并不是一个组件，而是标记页面布局的元素。可以根据您指定的<strong>app</strong>组件的结构动态调整大小，使得您可以创建高度可定制的组件。</p></li></ul><p>那么问题来了：<code>v-content</code>中的内容来自哪里？</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525966180568.png" alt="1525966180568" style="zoom:80%;"><ul><li>Layout映射的路径是<code>/</code></li><li>除了Login以外的所有组件，都是定义在Layout的children属性，并且路径都是<code>/</code>的下面</li><li>因此当路由到子组件时，会在Layout中定义的锚点中显示。</li><li>并且Layout中的其它部分不会变化，这就实现了布局的共享。</li></ul><h1 id="3-使用域名访问本地项目"><a href="#3-使用域名访问本地项目" class="headerlink" title="3. 使用域名访问本地项目"></a>3. 使用域名访问本地项目</h1><h2 id="3-1-统一环境"><a href="#3-1-统一环境" class="headerlink" title="3.1 统一环境"></a>3.1 统一环境</h2><p>我们现在访问页面使用的是：<a href="http://localhost:9001/">http://localhost:9001</a></p><p>有没有什么问题？</p><p>实际开发中，会有不同的环境：</p><ul><li>开发环境：自己的电脑</li><li>测试环境：提供给测试人员使用的环境</li><li>预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试</li><li>生产环境：项目最终发布上线的环境</li></ul><p>如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。</p><p>我们将使用以下域名：</p><ul><li>主域名是：<a href="http://www.leyou.com,leyou.com/">www.leyou.com，leyou.com</a> </li><li>管理系统域名：manage.leyou.com</li><li>网关域名：api.leyou.com</li><li>…</li></ul><p>但是最终，我们希望这些域名指向的还是我们本机的某个端口。</p><p>那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？</p><h2 id="3-2-域名解析"><a href="#3-2-域名解析" class="headerlink" title="3.2 域名解析"></a>3.2 域名解析</h2><p>一个域名一定会被解析为一个或多个ip。这一般会包含两步：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/image-20200721122317758.png" alt="image-20200721122317758" style="zoom:67%;"><ul><li><p><strong>本地域名解析</strong></p><p>浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。</p><ul><li>Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts</li><li>Linux下的hosts文件所在路径： /etc/hosts </li></ul><p>样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># My hosts</span><br><span class="line">127.0.0.1 localhost</span><br></pre></td></tr></table></figure></li><li><p><strong>域名服务器解析</strong></p><p>本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。</p></li></ul><h2 id="3-3-解决域名解析问题"><a href="#3-3-解决域名解析问题" class="headerlink" title="3.3 解决域名解析问题"></a>3.3 解决域名解析问题</h2><p>我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 api.leyou.com</span><br><span class="line">127.0.0.1 manage.leyou.com</span><br></pre></td></tr></table></figure><p>这样就实现了域名的关系映射了。</p><p>每次在C盘寻找hosts文件并修改是非常麻烦的，推荐一个快捷修改host的工具（《资料》）：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530556073565.png" alt="1530556073565" style="zoom:67%;"><p>解压，运行exe文件，效果：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530382550630.png" alt="1530382550630" style="zoom:67%;"><p>我们添加了两个映射关系（中间用空格隔开）：</p><ul><li>127.0.0.1 api.leyou.com ：我们的网关Zuul</li><li>127.0.0.1 manage.leyou.com：我们的后台系统地址</li></ul><p>现在，ping一下域名试试是否畅通：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530382601757.png" alt="1530382601757" style="zoom:67%;"><p>OK！</p><p>通过域名访问：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530383586463.png" alt="1530383586463" style="zoom:67%;"><p>原因：我们配置了项目访问的路径，虽然manage.leyou.com映射的ip也是127.0.0.1，但是webpack会验证host是否符合配置。</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530383612716.png" alt="1530383612716"></p><p>在webpack.dev.conf.js中取消host验证：<code>disableHostCheck: true</code></p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530383927461.png" alt="1530383927461"></p><p>重新执行<code>npm run dev</code>，刷新浏览器：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1532578408206.png" alt="1532578408206" style="zoom:67%;"><p>OK！</p><h2 id="3-4-nginx解决端口问题"><a href="#3-4-nginx解决端口问题" class="headerlink" title="3.4 nginx解决端口问题"></a>3.4 nginx解决端口问题</h2><p>​        域名问题解决了，但是现在要访问后台页面，还得自己加上端口：<code>http://manage.taotao.com:9001</code>。</p><p>​        这就不够优雅了。希望的是直接域名访问：<code>http://manage.taotao.com</code>。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？</p><p>​        这里就要用到反向代理工具：Nginx</p><h3 id="3-4-1-什么是Nginx"><a href="#3-4-1-什么是Nginx" class="headerlink" title="3.4.1 什么是Nginx"></a>3.4.1 什么是Nginx</h3> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526187409033.png" alt="1526187409033" style="zoom:80%;"><p>nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能：</p><ul><li>反向代理</li><li>负载均衡</li><li>动态路由</li><li>请求过滤</li></ul><h3 id="3-4-2-nginx作为web服务器"><a href="#3-4-2-nginx作为web服务器" class="headerlink" title="3.4.2 nginx作为web服务器"></a>3.4.2 nginx作为web服务器</h3><p>Web服务器分2类：</p><ul><li>web应用服务器，如：<ul><li>tomcat </li><li>resin</li><li>jetty</li></ul></li><li>web服务器，如：<ul><li>Apache 服务器 </li><li>Nginx</li><li>IIS  </li></ul></li></ul><p>区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。<br>并发：web服务器的并发能力远高于web应用服务器。</p><h3 id="3-4-3-nginx作为反向代理"><a href="#3-4-3-nginx作为反向代理" class="headerlink" title="3.4.3 nginx作为反向代理"></a>3.4.3 nginx作为反向代理</h3><p>什么是反向代理？</p><ul><li>代理：通过客户机的配置，<strong>实现让一台服务器代理客户机</strong>，客户的所有请求都交给代理服务器处理。</li><li><strong>反向代理</strong>：用一台服务器，<strong>代理真实服务器</strong>，用户访问时，不再是访问真实服务器，而是代理服务器。</li></ul><p>nginx可以当做反向代理服务器来使用：</p><ul><li>我们需要<strong>提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</strong></li><li>当请求到达nginx，n<strong>ginx会根据已经定义的规则进行请求的转发，从而实现路由功能</strong></li></ul><p>利用反向代理，就可以解决我们前面所说的端口问题，如图</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526016663674.png" alt="1526016663674" style="zoom:80%;"><h3 id="3-4-4-安装和使用"><a href="#3-4-4-安装和使用" class="headerlink" title="3.4.4 安装和使用"></a>3.4.4 安装和使用</h3><blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></blockquote><p>安装非常简单，把资料提供的nginx直接解压即可 </p><p>在本地安装一台nginx：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530556268445.png" alt="1530556268445" style="zoom:67%;"><p>解压后，目录结构：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530384792790.png" alt="1530384792790" style="zoom:67%;"><ol><li>conf：配置目录</li><li>contrib：第三方依赖</li><li>html：默认的静态资源目录，类似于tomcat的webapps</li><li>logs：日志目录</li><li>nginx.exe：启动程序。可双击运行，但不建议这么做。</li></ol><blockquote><h3 id="反向代理配置"><a href="#反向代理配置" class="headerlink" title="反向代理配置"></a>反向代理配置</h3></blockquote><p>示例：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526188831504.png" alt="1526188831504"></p><p>nginx中的每个server就是一个反向代理配置，可以有多个server</p><p>完整配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  manage.leyou.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Server <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:9001;</span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  api.leyou.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Server <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:10010;</span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3></blockquote><p>nginx可以通过命令行来启动，操作命令：</p><ul><li>启动：<code>start nginx.exe</code></li><li>停止：<code>nginx.exe -s stop</code></li><li>重新加载：<code>nginx.exe -s reload</code></li></ul><p>启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程：</p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1532579488518.png" alt="1532579488518" style="zoom:80%;"><h2 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h2><p>问题：nginx监控得到的地址并没有manage.leyou.com，这时候有其他属性有携带该信息，eg：original</p><p>启动nginx，然后用域名访问后台管理系统：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530385593052.png" alt="1530385593052" style="zoom:67%;"><p>现在实现了域名访问网站了，中间的流程是怎样的呢？</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526189945180.png" alt="1526189945180"></p><ol><li><p>浏览器准备发起请求，访问<a href="http://mamage.leyou.com,但需要进行**域名解析/">http://mamage.leyou.com，但需要进行**域名解析</a>**</p></li><li><p>优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1</p></li><li><p>请求被发往解析得到的ip，并且默认使用80端口：<a href="http://127.0.0.1/">http://127.0.0.1:80</a></p><p>本机的nginx一直监听80端口，因此捕获这个请求</p></li><li><p>nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发</p></li><li><p>后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx</p></li><li><p>nginx将得到的结果返回到浏览器</p></li></ol><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/image-20200721154433444.png" alt="image-20200721154433444" style="zoom:67%;"><h1 id="4-实现商品分类查询"><a href="#4-实现商品分类查询" class="headerlink" title="4. 实现商品分类查询"></a>4. 实现商品分类查询</h1><h2 id="实现时的问题？"><a href="#实现时的问题？" class="headerlink" title="实现时的问题？"></a>实现时的问题？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 位置categoryController:</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoriesByPid的返回值是什么意思</span><br><span class="line">        ResponseEntity.badRequest().build()这个类中有哪些方法能用，怎么用</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 位置leyou_item_service的启动类</span><br><span class="line">    <span class="meta">@MapperScan(&quot;com.leyou.item.mapper&quot;)</span>为什么注解扫描需要写com.leyou</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 位置leyou_item_service的Category pojo类（JPA）</span><br><span class="line">    <span class="meta">@Table(name=&quot;tb_category&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Id</span></span><br><span class="line">        <span class="meta">@GeneratedValue(strategy= GenerationType.IDENTITY)</span></span><br><span class="line">     这些注解的含义是什么，为何从未见过，需要怎么去学习</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 类似service中使用categoryMapper.select(record);这些方法应该什么时候使用（通用mapper），怎么用。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 理清这里的zuul和nginx和微服务的关系，以及怎样进行配置（已解决）</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 网关中LeyouCorsConfiguration的有关corsFilter的写法（很明确了）</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> pagehelper的pojo定义以及使用（https:<span class="comment">//mybatis.io/）</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> nginx监控得到的地址并没有manage.leyou.com，这时候有其他属性有携带该信息，eg：original。（已解决）</span><br></pre></td></tr></table></figure><p>​        商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，我们需要依次去完成：商品分类、品牌、商品的开发。</p><h2 id="4-1-导入数据"><a href="#4-1-导入数据" class="headerlink" title="4.1 导入数据"></a>4.1 导入数据</h2><p>首先导入资料提供的sql：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530556389224.png" alt="1530556389224" style="zoom:67%;"><p>先看商品分类表：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1525999774439.png" alt="1525999774439"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tb_category&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;类目id&#39;,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL COMMENT &#39;类目名称&#39;,</span><br><span class="line">  &#96;parent_id&#96; bigint(20) NOT NULL COMMENT &#39;父类目id,顶级类目填0&#39;,</span><br><span class="line">  &#96;is_parent&#96; tinyint(1) NOT NULL COMMENT &#39;是否为父节点，0为否，1为是&#39;,</span><br><span class="line">  &#96;sort&#96; int(4) NOT NULL COMMENT &#39;排序指数，越小越靠前&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;key_parent_id&#96; (&#96;parent_id&#96;) USING BTREE</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1424 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&#39;;</span><br></pre></td></tr></table></figure><p>因为商品分类会有层级关系，因此这里我们加入了<code>parent_id</code>字段，对本表中的其它分类进行自关联。</p><h2 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h2><p>在浏览器页面点击“分类管理”菜单：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1545220121941.png" alt="1545220121941"></p><p>根据这个路由路径到路由文件（src/route/index.js），<strong>也就是路由路径是地址上的路径，而路由文件是实际项目的文件位置</strong>，可以定位到分类管理页面：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1545220316442.png" alt="1545220316442"></p><p>由路由文件知，页面是src/pages/item/Category.vue</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1545220394460.png" alt="1545220394460" style="zoom:67%;"><p>商品分类使用了树状结构，而这种结构的组件vuetify并没有为我们提供，这里自定义了一个树状组件。不要求实现或者查询组件的实现，只要求可以参照文档使用该组件即可：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1545219777406.png" alt="1545219777406"></p><h3 id="4-2-1-url异步请求"><a href="#4-2-1-url异步请求" class="headerlink" title="4.2.1 url异步请求"></a>4.2.1 url异步请求</h3><p>点击商品管理下的分类管理子菜单，在浏览器控制台可以看到：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530427294644.png" alt="1530427294644"></p><p>页面中没有，只是发起了一条请求：<a href="http://api.leyou.com/api/item/category/list?pid=0">http://api.leyou.com/api/item/category/list?pid=0</a> </p><p>大家可能会觉得很奇怪，我们明明是使用的相对路径：/item/category/list，讲道理发起的请求地址应该是：</p><p><a href="http://manage.leyou.com/item/category/list">http://manage.leyou.com/item/category/list</a></p><p>但实际却是：</p><p><a href="http://api.leyou.com/api/item/category/list?pid=0">http://api.leyou.com/api/item/category/list?pid=0</a> </p><p>这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530427514123.png" alt="1530427514123"></p><p>路径是<a href="http://api.leyou.com,并且默认加上了/api%E7%9A%84%E5%89%8D%E7%BC%80%EF%BC%8C%E8%BF%99%E6%81%B0%E5%A5%BD%E4%B8%8E%E6%88%91%E4%BB%AC%E7%9A%84%E7%BD%91%E5%85%B3%E8%AE%BE%E7%BD%AE%E5%8C%B9%E9%85%8D%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AA%E9%9C%80%E8%A6%81%E6%8A%8A%E5%9C%B0%E5%9D%80%E6%94%B9%E6%88%90%E7%BD%91%E5%85%B3%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8D%B3%E5%8F%AF,%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BA%86nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E5%86%99%E5%9F%9F%E5%90%8D%E3%80%82">http://api.leyou.com，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名。</a></p><p>接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。</p><h3 id="4-2-2-实体类-item-interface"><a href="#4-2-2-实体类-item-interface" class="headerlink" title="4.2.2 实体类(item-interface)"></a>4.2.2 实体类(item-interface)</h3><p>在<code>leyou-item-interface</code>中添加category实体类：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530444682670.png" alt="1530444682670"></p><p>内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(name=&quot;tb_category&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Long parentId;</span><br><span class="line">    <span class="keyword">private</span> Boolean isParent; <span class="comment">// 注意isParent生成的getter和setter方法需要手动加上Is</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line">    <span class="comment">// getter和setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里要用到<strong>jpa的注解</strong>，因此我们在<code>leyou-item-iterface</code>中添加jpa依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>persistence-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-3-controller"><a href="#4-2-3-controller" class="headerlink" title="4.2.3 controller"></a>4.2.3 controller</h3><p>编写一个controller一般需要知道四个内容：</p><ul><li><strong>请求方式</strong>：决定我们用GetMapping还是PostMapping</li><li><strong>请求路径</strong>：决定映射路径</li><li><strong>请求参数</strong>：决定方法的参数</li><li><strong>返回值结果</strong>：决定方法的返回值，这里返回值是根据全局组件的Tree.vue中的mockDB中的treedata来得知的。</li></ul><p>在刚才页面发起的请求中，我们就能得到绝大多数信息：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530445885707.png" alt="1530445885707"></p><ul><li><p>请求方式：Get，插叙肯定是get请求</p></li><li><p>请求路径：/api/item/category/list。<strong>其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list</strong></p></li><li><p>请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目</p></li><li><p>返回结果：？？</p><p>根据前面tree组件的用法我们知道，返回的应该是json数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">74</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;isParent&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;sort&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">     &#123; </span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">75</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;家用电器&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;isParent&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;sort&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对应的java类型可以是List集合，里面的元素就是类目对象了。也就是<code>List&lt;Category&gt;</code></p></li></ul><p>添加Controller：</p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530450599897.png" alt="1530450599897" style="zoom:67%;"><p>controller代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;category&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据父id查询子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoriesByPid(<span class="meta">@RequestParam(&quot;pid&quot;)</span> Long pid) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="keyword">null</span> || pid.longValue() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 响应400，相当于ResponseEntity.status(HttpStatus.BAD_REQUEST).build();</span></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().build();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Category&gt; categories = <span class="keyword">this</span>.categoryService.queryCategoriesByPid(pid);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(categories)) &#123;</span><br><span class="line">            <span class="comment">// 响应404</span></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(categories);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-service"><a href="#4-2-4-service" class="headerlink" title="4.2.4 service"></a>4.2.4 service</h3><p>一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530450744567.png" alt="1530450744567"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryMapper categoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据parentId查询子类目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">queryCategoriesByPid</span><span class="params">(Long pid)</span> </span>&#123;</span><br><span class="line">        Category record = <span class="keyword">new</span> Category();</span><br><span class="line">        record.setParentId(pid);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.categoryMapper.select(record);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-5-mapper"><a href="#4-2-5-mapper" class="headerlink" title="4.2.5 mapper"></a>4.2.5 mapper</h3><p>我们使用<strong>通用mapper</strong>来简化开发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Category</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？</p><p>我们在启动类上添加一个<strong>扫描包功能</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.leyou.item.mapper&quot;)</span> <span class="comment">// mapper接口的包扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeyouItemServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(LeyouItemServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-6-启动并测试"><a href="#4-2-6-启动并测试" class="headerlink" title="4.2.6.启动并测试"></a>4.2.6.启动并测试</h3><p>我们不经过网关，直接访问：<a href="http://localhost:8081/category/list">http://localhost:8081/category/list</a></p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530455133230.png" alt="1530455133230" style="zoom:67%;"><p>然后试试网关是否畅通：<a href="http://api.leyou.com/api/item/category/list">http://api.leyou.com/api/item/category/list</a></p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530455291468.png" alt="1530455291468" style="zoom:67%;"><p>一切OK！</p><p>然后刷新后台管理页面查看：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530455437899.png" alt="1530455437899" style="zoom:67%;"><p>发现报错了！</p><p>浏览器直接访问没事，但是这里却报错，什么原因？</p><p>这其实是浏览器的同源策略造成的跨域问题。</p><h1 id="5-跨域问题"><a href="#5-跨域问题" class="headerlink" title="5. 跨域问题"></a>5. 跨域问题</h1><p>跨域：<strong>浏览器对于javascript的同源策略的限制</strong> 。</p><p>以下情况都属于跨域：</p><table><thead><tr><th>跨域原因说明</th><th>示例</th></tr></thead><tbody><tr><td>域名不同</td><td><code>www.jd.com</code> 与 <code>www.taobao.com</code></td></tr><tr><td>域名相同，端口不同</td><td><code>www.jd.com:8080</code> 与 <code>www.jd.com:8081</code></td></tr><tr><td>二级域名不同</td><td><code>item.jd.com</code> 与 <code>miaosha.jd.com</code></td></tr></tbody></table><p>如果<strong>域名和端口都相同，但是请求路径不同</strong>，不属于跨域，如：</p><p><code>www.jd.com/item</code> </p><p><code>www.jd.com/goods</code></p><p>http和https也属于跨域</p><p>而我们刚才是从<code>manage.leyou.com</code>去访问<code>api.leyou.com</code>，这属于二级域名不同，跨域了。</p><h2 id="5-1-跨域问题的原因"><a href="#5-1-跨域问题的原因" class="headerlink" title="5.1 跨域问题的原因"></a>5.1 跨域问题的原因</h2><p>跨域不一定都会有跨域问题。</p><p>因为跨域问题是浏览器对于ajax请求的一种安全限制：<strong>一个页面发起的ajax请求，只能是与当前页域名相同的路径</strong>，这能有效的阻止跨站攻击。</p><p>因此：<strong>跨域问题 是针对ajax的一种限制</strong>。</p><p>但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？</p><h2 id="5-2-解决跨域问题的方案"><a href="#5-2-解决跨域问题的方案" class="headerlink" title="5.2 解决跨域问题的方案"></a>5.2 解决跨域问题的方案</h2><p>目前比较常用的跨域解决方案有3种：</p><ul><li><p><strong>Jsonp</strong></p><p>最早的解决方案，利用script标签可以跨域的原理实现。</p><p>限制：</p><ul><li>需要服务的支持</li><li>只能发起GET请求</li></ul></li><li><p><strong>nginx反向代理</strong></p><p>思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式</p><p>缺点：需要在nginx进行额外配置，语义不清晰 </p></li><li><p><strong>CORS</strong></p><p>规范化的跨域请求解决方案，安全可靠。</p><p>优势：</p><ul><li>在服务端进行控制是否允许跨域，可自定义规则</li><li>支持各种请求方式</li></ul><p>缺点：</p><ul><li>会产生额外的请求</li></ul></li></ul><p>我们这里会采用cors的跨域方案。</p><h2 id="5-3-cors解决跨域"><a href="#5-3-cors解决跨域" class="headerlink" title="5.3 cors解决跨域"></a>5.3 cors解决跨域</h2><h3 id="5-3-1-什么是cors"><a href="#5-3-1-什么是cors" class="headerlink" title="5.3.1 什么是cors"></a>5.3.1 什么是cors</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p><p>CORS需要<strong>浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><ul><li><p>浏览器端：</p><p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p></li><li><p>服务端：</p><p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p></li></ul><h3 id="5-3-2-两种请求对应的响应头格式"><a href="#5-3-2-两种请求对应的响应头格式" class="headerlink" title="5.3.2 两种请求对应的响应头格式"></a>5.3.2 两种请求对应的响应头格式</h3><p>浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。：</p><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><p>当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：<code>Origin</code>.</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530460311064.png" alt="1530460311064"></p><p>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p><p>如果服务器允许跨域，需要在返回的<strong>响应头</strong>中携带下面信息：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><ul><li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）</li><li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</li></ul><h5 id="有关cookie"><a href="#有关cookie" class="headerlink" title="有关cookie"></a>有关cookie</h5><blockquote><p>有关cookie：</p></blockquote><p>要<strong>想操作cookie</strong>，需要满足3个条件：</p><ul><li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li><li>浏览器发起ajax需要指定withCredentials 为true</li><li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li></ul><h4 id="特殊请求"><a href="#特殊请求" class="headerlink" title="特殊请求"></a>特殊请求</h4><p>不符合简单请求的条件，会被浏览器判定为特殊请求, 例如请求方式为PUT。</p><blockquote><p>预检请求</p></blockquote><p>​        特殊请求会在正式通信之前，<strong>增加一次HTTP查询请求</strong>，称为”预检”请求（preflight）。</p><p>​        浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>一个“预检”请求的样板：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span>: api.leyou.com</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>与简单请求相比，除了Origin以外，多了两个头：</p><ul><li>Access-Control-Request-Method：接下来会用到的<strong>请求方式</strong>，比如PUT</li><li>Access-Control-Request-Headers：会额外用到的<strong>头信息</strong></li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><blockquote><p>预检请求的响应</p></blockquote><p>服务的收到预检请求，如果许可跨域，会发出响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure><p>除了<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Credentials</code>以外，这里又额外多出3个头：</p><ul><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的ajax请求就无需再次进行预检了</strong></li></ul><p>如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。</p><h3 id="5-3-3-实现"><a href="#5-3-3-实现" class="headerlink" title="5.3.3 实现"></a>5.3.3 实现</h3><p>虽然原理比较复杂，但是前面说过：</p><ul><li>浏览器端都有浏览器自动完成，我们无需操心</li><li><strong>服务端可以通过拦截器统一实现</strong>，不必每次都去进行跨域判定的编写。</li></ul><p>事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：<strong>CorsFilter</strong> ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p><p>在<code>leyou-gateway</code>中编写一个配置类，并且注册CorsFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeyouCorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.添加CORS配置信息</span></span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://manage.leyou.com&quot;</span>);</span><br><span class="line">        <span class="comment">//2) 是否发送Cookie信息</span></span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//3) 允许的请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PATCH&quot;</span>);</span><br><span class="line">        <span class="comment">// 4）允许的头信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加映射路径，我们拦截一切请求</span></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回新的CorsFilter.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530462650711.png" alt="1530462650711"></p><p>重启测试，访问正常：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530463010927.png" alt="1530463010927"></p><p>分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。</p><h1 id="6-品牌的查询"><a href="#6-品牌的查询" class="headerlink" title="6. 品牌的查询"></a>6. 品牌的查询</h1><p>需要注意的是，<strong>页面中的排序和分页操作是前端ui通过watch  pagination调用相应的函数来自动更新的</strong>，我们本身并没有对其进行处理。</p><p><strong>搜索也是前端ui通过watch seach来调用函数完成</strong>，我们本身在后端并没有进行处理。</p><p>商品分类完成以后，自然轮到了品牌功能了。</p><p>先看看我们要实现的效果：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526021968036.png" alt="1526021968036" style="zoom:67%;"><p>点击“品牌管理”菜单：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1545221218980.png" alt="1545221218980" style="zoom:80%;"><p>路由路径：/item/brand</p><p>根据路由文件知，对应的页面是：src/pages/item/Brand.vue</p><p>页面会发送如下请求：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1543066995215.png" alt="1543066995215"></p><h2 id="6-1-后台提供查询接口"><a href="#6-1-后台提供查询接口" class="headerlink" title="6.1 后台提供查询接口"></a>6.1 后台提供查询接口</h2><p>前台页面已经准备好，接下来就是后台提供数据接口了。</p><h3 id="6-1-1-数据库表"><a href="#6-1-1-数据库表" class="headerlink" title="6.1.1 数据库表"></a>6.1.1 数据库表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tb_brand&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;品牌id&#39;,</span><br><span class="line">  &#96;name&#96; varchar(50) NOT NULL COMMENT &#39;品牌名称&#39;,</span><br><span class="line">  &#96;image&#96; varchar(200) DEFAULT &#39;&#39; COMMENT &#39;品牌图片地址&#39;,</span><br><span class="line">  &#96;letter&#96; char(1) DEFAULT &#39;&#39; COMMENT &#39;品牌的首字母&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;325400 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;品牌表，一个品牌下有多个商品（spu），一对多关系&#39;;</span><br></pre></td></tr></table></figure><p>简单的四个字段，不多解释。</p><p>这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tb_category_brand&#96; (</span><br><span class="line">  &#96;category_id&#96; bigint(20) NOT NULL COMMENT &#39;商品类目id&#39;,</span><br><span class="line">  &#96;brand_id&#96; bigint(20) NOT NULL COMMENT &#39;品牌id&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;category_id&#96;,&#96;brand_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品分类和品牌的中间表，两者是多对多关系&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，你可能会发现，这张表中并<strong>没有设置外键约束</strong>，似乎与数据库的设计范式不符。为什么这么做？</p><ul><li>外键会严重影响数据库读写的效率</li><li>数据删除时会比较麻烦</li></ul><p>在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。</p><h3 id="6-1-2-实体类"><a href="#6-1-2-实体类" class="headerlink" title="6.1.2 实体类"></a>6.1.2 实体类</h3> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530541070271.png" alt="1530541070271" style="zoom:80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;tb_brand&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">// 品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">// 品牌图片</span></span><br><span class="line">    <span class="keyword">private</span> Character letter;</span><br><span class="line">    <span class="comment">// getter setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-3-mapper"><a href="#6-1-3-mapper" class="headerlink" title="6.1.3 mapper"></a>6.1.3 mapper</h3> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530541222679.png" alt="1530541222679" style="zoom:67%;"><p>通用mapper来简化开发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BrandMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Brand</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-4-controller"><a href="#6-1-4-controller" class="headerlink" title="6.1.4 controller"></a>6.1.4 controller</h3><p>编写controller先思考四个问题，参照前端页面的控制台</p><ul><li><strong>请求方式</strong>：查询，肯定是Get</li><li><strong>请求路径</strong>：分页查询，/brand/page</li><li><strong>请求参数</strong>：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，<strong>查询源文件发现在$http.get中的params中传入了5个参数</strong>：<ul><li>page：当前页，int</li><li>rows：每页大小，int</li><li>sortBy：排序字段，String</li><li>desc：是否为降序，boolean</li><li>key：搜索关键词，String</li></ul></li><li><strong>响应结果</strong>：分页结果一般至少需要两个数据，这里查询源文件<strong>发现在$http.get中的resp.data中用到了items和total，items的使用中又用到了id name image letter</strong><ul><li>total：总条数</li><li>items：当前页数据</li><li>totalPage：有些还需要总页数</li></ul></li></ul><p>这里我们封装一个类，来表示分页结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;<span class="comment">// 总条数</span></span><br><span class="line">    <span class="keyword">private</span> Integer totalPage;<span class="comment">// 总页数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items;<span class="comment">// 当前页数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(Long total, List&lt;T&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(Long total, Long totalPage, List&lt;T&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.totalPage = totalPage;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(Long total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItems</span><span class="params">(List&lt;T&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getTotalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalPage</span><span class="params">(Long totalPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalPage = totalPage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到<code>leyou-common</code>中，提高复用性：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530543778541.png" alt="1530543778541"></p><p><strong>不要忘记在leyou-item-service工程的pom.xml中引入leyou-common的依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.common<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们编写Controller</p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530549253999.png" alt="1530549253999" style="zoom:80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;brand&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BrandService brandService;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据查询条件分页并排序查询品牌信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rows</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sortBy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandsByPage(</span><br><span class="line">            <span class="meta">@RequestParam(value = &quot;key&quot;, required = false)</span>String key,</span><br><span class="line">            <span class="meta">@RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;)</span>Integer page,</span><br><span class="line">            <span class="meta">@RequestParam(value = &quot;rows&quot;, defaultValue = &quot;5&quot;)</span>Integer rows,</span><br><span class="line">            <span class="meta">@RequestParam(value = &quot;sortBy&quot;, required = false)</span>String sortBy,</span><br><span class="line">            <span class="meta">@RequestParam(value = &quot;desc&quot;, required = false)</span>Boolean desc</span><br><span class="line">    )&#123;</span><br><span class="line">        PageResult&lt;Brand&gt; result = <span class="keyword">this</span>.brandService.queryBrandsByPage(key, page, rows, sortBy, desc);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(result.getItems()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-5-Service"><a href="#6-1-5-Service" class="headerlink" title="6.1.5 Service"></a>6.1.5 Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BrandMapper brandMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据查询条件分页并排序查询品牌信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rows</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sortBy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult&lt;Brand&gt; <span class="title">queryBrandsByPage</span><span class="params">(String key, Integer page, Integer rows, String sortBy, Boolean desc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化example对象</span></span><br><span class="line">        Example example = <span class="keyword">new</span> Example(Brand.class);</span><br><span class="line">        Example.Criteria criteria = example.createCriteria();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据name模糊查询，或者根据首字母查询</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(key)) &#123;</span><br><span class="line">            criteria.andLike(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;%&quot;</span> + key + <span class="string">&quot;%&quot;</span>).orEqualTo(<span class="string">&quot;letter&quot;</span>, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加分页条件</span></span><br><span class="line">        PageHelper.startPage(page, rows);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加排序条件</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(sortBy)) &#123;</span><br><span class="line">            example.setOrderByClause(sortBy + <span class="string">&quot; &quot;</span> + (desc ? <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;asc&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Brand&gt; brands = <span class="keyword">this</span>.brandMapper.selectByExample(example);</span><br><span class="line">        <span class="comment">// 包装成pageInfo</span></span><br><span class="line">        PageInfo&lt;Brand&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(brands);</span><br><span class="line">        <span class="comment">// 包装成分页结果集返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo.getList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-6-测试"><a href="#6-1-6-测试" class="headerlink" title="6.1.6 测试"></a>6.1.6 测试</h3><p>通过浏览器访问试试：<a href="http://api.leyou.com/api/item/brand/page">http://api.leyou.com/api/item/brand/page</a></p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530549095150.png" alt="1530549095150" style="zoom:67%;"><p>接下来，去页面请求数据并渲染</p><h2 id="6-2-异步查询工具axios"><a href="#6-2-异步查询工具axios" class="headerlink" title="6.2 异步查询工具axios"></a>6.2 异步查询工具axios</h2><p>​        异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。</p><h3 id="6-2-1-axios入门（Get与POST）"><a href="#6-2-1-axios入门（Get与POST）" class="headerlink" title="6.2.1 axios入门（Get与POST）"></a>6.2.1 axios入门（Get与POST）</h3><p>Vue官方推荐的ajax请求框架叫做：axios，看下demo：</p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526033988251.png" alt="1526033988251" style="zoom:80%;"><p>axios的<strong>Get请求</strong>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;/item/category/list?pid=0&quot;</span>) <span class="comment">// 请求路径和请求参数拼接</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 成功回调函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 失败回调函数</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// 参数较多时，可以通过params来传递参数</span></span><br><span class="line">axios.get(<span class="string">&quot;/item/category/list&quot;</span>, &#123;</span><br><span class="line">        params:&#123;</span><br><span class="line">            pid:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;&#125;)<span class="comment">// 成功时的回调</span></span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;&#125;)<span class="comment">// 失败时的回调</span></span><br></pre></td></tr></table></figure><p>axios的<strong>POST请求</strong>语法：</p><p>比如新增一个用户</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;/user&quot;</span>,&#123;</span><br><span class="line">        name:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">        age:<span class="number">21</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数</p><p><strong>PUT和DELETE请求</strong>与POST请求类似</p><h3 id="6-2-2-axios的全局配置"><a href="#6-2-2-axios的全局配置" class="headerlink" title="6.2.2 axios的全局配置"></a>6.2.2 axios的全局配置</h3><p>而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526034150067.png" alt="1526034150067"></p><p>http.js中对axios进行了一些默认配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;./config&#x27;</span></span><br><span class="line"><span class="comment">// config中定义的基础路径是：http://api.leyou.com/api</span></span><br><span class="line">axios.defaults.baseURL = config.api; <span class="comment">// 设置axios的基础请求路径</span></span><br><span class="line">axios.defaults.timeout = <span class="number">2000</span>; <span class="comment">// 设置axios的请求时间</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios;<span class="comment">// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象</span></span><br></pre></td></tr></table></figure><ul><li><p>http.js中导入了config的配置，还记得吗？</p><p>   <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526041205846.png" alt="1526041205846"></p></li><li><p>http.js对axios进行了全局配置：<code>baseURL=config.api</code>，即<code>http://api.leyou.com/api</code>。因此<strong>以后所有用axios发起的请求，都会以这个地址作为前缀</strong>。</p></li><li><p>通过<code>Vue.property.$http = axios</code>，将<code>axios</code>赋值给了 Vue原型中的<code>$http</code> <strong>。这样以后所有的</strong>Vue实例<strong>都可以访问</strong>到$http，也就是访问到了axios了。</p></li></ul><h3 id="6-2-3-项目中使用"><a href="#6-2-3-项目中使用" class="headerlink" title="6.2.3 项目中使用"></a>6.2.3 项目中使用</h3><p>在组件<code>Brand.vue</code>的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1543067111272.png" alt="1543067111272" style="zoom:80%;"><p>网络监视：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526048143014.png" alt="1526048143014"></p><p>resp到底都有那些数据，查看控制台结果：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526048275064.png" alt="1526048275064"></p><p>可以看到，在请求成功的返回结果response中，有一个<strong>data属性</strong>，里面就是真正的响应数据。</p><p>响应结果中与我们设计的一致，包含3个内容：</p><ul><li>total：总条数，目前是165</li><li>items：当前页数据</li><li>totalPage：总页数，我们没有返回</li></ul><h2 id="6-3-完成分页和过滤"><a href="#6-3-完成分页和过滤" class="headerlink" title="6.3 完成分页和过滤"></a>6.3 完成分页和过滤</h2><h3 id="6-3-1-分页"><a href="#6-3-1-分页" class="headerlink" title="6.3.1 分页"></a>6.3.1 分页</h3><p>点击分页，会发起请求，通过浏览器工具查看，会发现pagination对象的属性一直在变化：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/9.gif"></p><p>我们可以<strong>利用Vue的监视功能：watch</strong>，当pagination发生改变时，会调用我们的回调函数，在回调函数中进行数据的查询！</p><p>具体实现：</p><p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526049643506.png" alt="1526049643506"></p><p>成功实现分页功能：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/22.gif" alt="1526049720200" style="zoom:67%;"><h3 id="6-3-2-过滤"><a href="#6-3-2-过滤" class="headerlink" title="6.3.2 过滤"></a>6.3.2 过滤</h3><p>过滤字段对应的是<strong>search属性</strong>，我们只要监视这个属性即可:</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526049939985.png" alt="1526049939985"></p><p>查看网络请求：</p><p> <img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1526050032436.png" alt="1526050032436"></p><p>页面结果：</p><img src="/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/1530555740595.png" alt="1530555740595" style="zoom: 50%;"><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>通过域名访问页面(nginx)</span><br><span class="line">    hosts: 解析域名--&gt; ip switchHost工具修改</span><br><span class="line">    nginx: web和反向代理服务器  Web服务器  web应用服务器   nginx+tomcat</span><br><span class="line">    请求分发，反向代理，负载均衡</span><br><span class="line">    start nginx   nginx -s reload/stop</span><br><span class="line">    nginx.conf</span><br><span class="line">    server&#123;</span><br><span class="line">        server_name;</span><br><span class="line">        proxy_pass;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 分类查询</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 跨域</span><br><span class="line">   跨域场景： 协议不同 域名不同 端口不同 二级域名不同</span><br><span class="line">   跨域前提: ajax请求才会出现跨域</span><br><span class="line">   解决方案: jsonp  nginx</span><br><span class="line">        </span><br><span class="line">    cors:无需处理请求，只需要处理响应即可，请求是浏览器自动携带的。</span><br><span class="line">        Access-Control-Allow-Origin: http:<span class="comment">//manage.leyou.com</span></span><br><span class="line">        Access-Control-Allow-Credentials: <span class="keyword">true</span></span><br><span class="line">        Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">        Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">       实现： springMVC提供了CorsFilter</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> 品牌查询</span><br><span class="line">    service</span><br><span class="line">        <span class="comment">// 添加查询条件key</span></span><br><span class="line">        <span class="comment">// 添加分页</span></span><br><span class="line">        <span class="comment">// 添加排序</span></span><br><span class="line">        <span class="comment">// 分页结果集</span></span><br><span class="line">        <span class="comment">// 封装成自己的分页结果集</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;后台前端的目录结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vuetify的项目页面布局&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="乐优商城" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"/>
    
    <category term="后台前端_Vuetify_nginx反向代理_商品分类(JPA_通用Mapper)_cors跨域_品牌查询(axios_分页和过滤)" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF-Vuetify-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB-JPA-%E9%80%9A%E7%94%A8Mapper-cors%E8%B7%A8%E5%9F%9F-%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2-axios-%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/"/>
    
    
    <category term="Vuetify" scheme="https://mrchen229.github.io/tags/Vuetify/"/>
    
    <category term="nginx反向代理解决端口问题" scheme="https://mrchen229.github.io/tags/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    
    <category term="cors解决跨域" scheme="https://mrchen229.github.io/tags/cors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"/>
    
    <category term="异步查询axios" scheme="https://mrchen229.github.io/tags/%E5%BC%82%E6%AD%A5%E6%9F%A5%E8%AF%A2axios/"/>
    
    <category term="分页和过滤" scheme="https://mrchen229.github.io/tags/%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>乐优商城结构_基本框架搭建_ES6语法</title>
    <link href="https://mrchen229.github.io/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/"/>
    <id>https://mrchen229.github.io/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-30T02:15:08.000Z</published>
    <updated>2020-08-30T02:18:10.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>电商行业介绍</li><li>乐优商城整体项目结构</li><li>项目基本框架的搭建（EurekaServer、zuul、leyou-item、leyou-common）</li><li>ES6语法</li></ul><h1 id="1-电商行业"><a href="#1-电商行业" class="headerlink" title="1. 电商行业"></a>1. 电商行业</h1><h2 id="1-1-项目分类"><a href="#1-1-项目分类" class="headerlink" title="1.1 项目分类"></a>1.1 项目分类</h2><p>主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同</p><h3 id="1-1-1-传统项目"><a href="#1-1-1-传统项目" class="headerlink" title="1.1.1 传统项目"></a>1.1.1 传统项目</h3><p>各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。）</p><ul><li>需求方：公司、企业内部</li><li>盈利模式：项目本身卖钱</li><li>技术侧重点：业务功能</li></ul><h3 id="1-1-2-互联网项目"><a href="#1-1-2-互联网项目" class="headerlink" title="1.1.2 互联网项目"></a>1.1.2 互联网项目</h3><p>门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com  …… </p><ul><li>需求方：广大用户群体</li><li>盈利模式：虚拟币、增值服务、广告收益……</li><li>技术侧重点：网站性能、业务功能</li></ul><p>互联网项目中的重要角色：电商:</p><h2 id="1-2-电商行业的发展"><a href="#1-2-电商行业的发展" class="headerlink" title="1.2 电商行业的发展"></a>1.2 电商行业的发展</h2><h3 id="1-2-1-涉及点"><a href="#1-2-1-涉及点" class="headerlink" title="1.2.1 涉及点"></a>1.2.1 涉及点</h3><p>​        alisql  oceanbase dubbo rabbitMQ</p><h3 id="1-2-2-技术特点"><a href="#1-2-2-技术特点" class="headerlink" title="1.2.2 技术特点"></a>1.2.2 技术特点</h3><p>​    电商行业的特点：</p><ul><li>技术范围广</li><li>技术新</li><li>高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列）</li><li>高可用（集群、负载均衡、限流、降级、熔断）</li><li>数据量大</li><li>业务复杂</li><li>数据安全</li></ul><h2 id="1-3-常见电商模式"><a href="#1-3-常见电商模式" class="headerlink" title="1.3 常见电商模式"></a>1.3 常见电商模式</h2><p>电商行业的一些常见模式：</p><ul><li>B2C：商家对个人，如：亚马逊、当当等</li><li>C2C平台：个人对个人，如：闲鱼、拍拍网、ebay</li><li>B2B平台：商家对商家，如：阿里巴巴、八方资源网等</li><li>O2O：线上和线下结合，如：饿了么、电影票、团购等</li><li>P2P：在线金融，贷款，如：网贷之家、人人聚财等。</li><li>B2C平台：天猫、京东、一号店等</li></ul><h2 id="1-4-一些专业术语"><a href="#1-4-一些专业术语" class="headerlink" title="1.4 一些专业术语"></a>1.4 一些专业术语</h2><ul><li><p>SaaS：软件即服务</p></li><li><p>SOA：面向服务</p></li><li><p>RPC：远程过程调用</p></li><li><p>RMI：远程方法调用</p></li><li><p>PV：(page view)，即页面浏览量；</p><p>用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计</p></li><li><p>UV：(unique visitor)，独立访客</p><p>指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。</p></li><li><p>PV与带宽：</p><ul><li>计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。</li><li>计算公式是：网站带宽= ( PV * 平均页面大小（单位MB）* 8 )/统计时间（换算到秒）</li><li>为什么要乘以8？<ul><li>网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit</li></ul></li><li>这个计算的是平均带宽，高峰期还需要扩大一定倍数</li></ul></li><li><p>PV、QPS、并发</p><ul><li><p>QPS：每秒处理的请求数量。</p><ul><li>比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。</li></ul></li><li><p>由PV和QPS如何需要部署的服务器数量？</p><ul><li>根据二八原则，80%的请求集中在20%的时间来计算峰值压力：</li><li>（每日PV * 80%） / （3600s * 24 * 20%） * 每个页面的请求数  = 每个页面每秒的请求数量</li><li>然后除以服务器的QPS值，即可计算得出需要部署的服务器数量</li></ul></li></ul></li></ul><h2 id="1-5-项目开发流程"><a href="#1-5-项目开发流程" class="headerlink" title="1.5.项目开发流程"></a>1.5.项目开发流程</h2><p>项目经理：管人 </p><p>技术经理：</p><p>产品经理：设计需求原型 </p><p>测试：</p><p>前端：大前端：UI 前端页面。</p><p>后端：</p><p>移动端：</p><p>项目开发流程图：</p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1525697632643.png" style="zoom: 80%;"><h1 id="2-乐优商城介绍"><a href="#2-乐优商城介绍" class="headerlink" title="2. 乐优商城介绍"></a>2. 乐优商城介绍</h1><h2 id="2-1-项目介绍"><a href="#2-1-项目介绍" class="headerlink" title="2.1 项目介绍"></a>2.1 项目介绍</h2><ul><li>乐优商城是一个全品类的电商购物网站（B2C）。</li><li>用户可以在线购买商品、加入购物车、下单</li><li>可以评论已购买商品</li><li>管理员可以在后台管理商品的上下架、促销活动</li><li>管理员可以监控商品销售状况</li><li>客服可以在后台处理退款操作</li><li>希望未来3到5年可以支持千万用户的使用</li></ul><h2 id="2-2-系统架构"><a href="#2-2-系统架构" class="headerlink" title="2.2 系统架构"></a>2.2 系统架构</h2><h3 id="2-2-1-架构图"><a href="#2-2-1-架构图" class="headerlink" title="2.2.1 架构图"></a>2.2.1 架构图</h3><p>乐优商城架构缩略图：</p><p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1525703759035.png" alt="1525703759035"></p><h3 id="2-2-2-系统架构解读"><a href="#2-2-2-系统架构解读" class="headerlink" title="2.2.2 系统架构解读"></a>2.2.2 系统架构解读</h3><p>整个乐优商城可以分为两部分：后台管理系统、前台门户系统。</p><ul><li><p>后台管理：</p><ul><li>后台系统主要包含以下功能：<ul><li>商品管理，包括商品分类、品牌、商品规格等信息的管理</li><li>销售管理，包括订单统计、订单退款处理、促销活动生成等</li><li>用户管理，包括用户控制、冻结、解锁等</li><li>权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制</li><li>统计，各种数据的统计分析展示</li></ul></li><li>后台系统会采用前后端分离开发，而且整个后台管理系统会<strong>使用Vue.js框架搭建出单页应用</strong>（SPA）。</li></ul></li><li><p>前台门户</p><ul><li>前台门户面向的是客户，包含与客户交互的一切功能。例如：<ul><li>搜索商品</li><li>加入购物车</li><li>下单</li><li>评价商品等等</li></ul></li><li>前台系统我们会<strong>使用Thymeleaf模板引擎</strong>技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。</li></ul><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1525704277126.png" alt="1525704277126" style="zoom:50%;"></li></ul><p>无论是前台还是后台系统，都共享相同的微服务集群，包括：</p><ul><li>商品微服务：商品及商品分类、品牌、库存等的服务</li><li>搜索微服务：实现搜索功能</li><li>订单微服务：实现订单相关</li><li>购物车微服务：实现购物车相关功能</li><li>用户中心：用户的登录注册等功能</li><li>Eureka注册中心</li><li>Zuul网关服务</li><li>…</li></ul><h1 id="3-项目搭建"><a href="#3-项目搭建" class="headerlink" title="3.项目搭建"></a>3.项目搭建</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整个springcloud项目结构：</span><br><span class="line">    浏览器访问接口，需要先经过zuul网关，后面是一堆的微服务</span><br><span class="line">    zuul网关也在eureka-server中,当有微服务时，配置zuul的路由</span><br><span class="line">    这时候zuul会根据指定需要代理的微服务，当通过zuul端口进行访问时，（映射路径），就会代理到eureka相应的服务名称所对应的服务中，并实现了负载均衡（负载均衡就能够帮我们根据service名称，获取到服务实例的ip和端口）。</span><br></pre></td></tr></table></figure><h1 id="需要学习的部分"><a href="#需要学习的部分" class="headerlink" title="需要学习的部分"></a>需要学习的部分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> zuul网关怎么分发请求的  OK</span><br><span class="line"><span class="number">2.</span> datasource的配置是怎么和mybatis springmvc结合的</span><br><span class="line"><span class="number">3.</span> yml文件中会有bean注入什么的吗</span><br><span class="line">    不会，是覆盖的springboot的默认配置，内部会对这个application*.yml的文件进行读取。</span><br></pre></td></tr></table></figure><h2 id="3-1-技术选型"><a href="#3-1-技术选型" class="headerlink" title="3.1.技术选型"></a>3.1.技术选型</h2><p>前端技术：</p><ul><li>基础的HTML、CSS、JavaScript（基于ES6标准）</li><li>JQuery</li><li>Vue.js 2.0以及基于Vue的框架：Vuetify（UI框架）</li><li>前端构建工具：WebPack</li><li>前端安装包工具：NPM</li><li>Vue脚手架：Vue-cli</li><li>Vue路由：vue-router</li><li>ajax框架：axios</li><li>基于Vue的富文本框架：quill-editor </li></ul><p>后端技术：</p><ul><li>基础的SpringMVC、Spring 5.x和MyBatis3</li><li>Spring Boot 2.0.7版本</li><li>Spring Cloud 最新版 Finchley.SR2</li><li>Redis-4.0</li><li>RabbitMQ-3.4</li><li>Elasticsearch-6.3</li><li>nginx-1.14.2</li><li>FastDFS - 5.0.8</li><li>MyCat</li><li>Thymeleaf</li><li>mysql 5.6</li></ul><h2 id="3-2-开发环境"><a href="#3-2-开发环境" class="headerlink" title="3.2 开发环境"></a>3.2 开发环境</h2><p>环境：</p><ul><li>IDE：Idea 2019.3 ，参考资料的《idea使用指南.md》</li><li>JDK：使用JDK1.8</li><li>项目构建：maven3.3.9以上版本即可（3.5.2）</li><li>版本控制工具：git</li></ul><h2 id="3-3-域名"><a href="#3-3-域名" class="headerlink" title="3.3 域名"></a>3.3 域名</h2><p>开发过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。</p><p>一级域名：<a href="http://www.leyou.com,leyou.com/">www.leyou.com，leyou.com</a> leyou.cn </p><p>二级域名：manage.leyou.com/item , api.leyou.com</p><p>可以通过switchhost工具《资料》来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。</p><p>也可以自己在hosts文件中修改。</p><h2 id="3-4-创建父工程"><a href="#3-4-创建父工程" class="headerlink" title="3.4 创建父工程"></a>3.4 创建父工程</h2><p>创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是module</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529224631578.png" alt="1529224631578" style="zoom:67%;"><p>填写项目信息：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529224746616.png" alt="1529224746616" style="zoom:67%;"><p>填写保存的位置信息：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529224804596.png" alt="1529224804596" style="zoom:67%;"><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>leyou<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.starter.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">mybatis.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper.starter.version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">mapper.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.starter.version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">druid.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pageHelper.starter.version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">pageHelper.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">leyou.latest.version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">leyou.latest.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fastDFS.client.version</span>&gt;</span>1.26.1-RELEASE<span class="tag">&lt;/<span class="name">fastDFS.client.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- springCloud --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mybatis启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 通用Mapper启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 分页助手启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pageHelper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--FastDFS客户端--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tobato<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fastDFS.client.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，我们在父工程中引入了SpringCloud等，很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。</p><p>可以删除src目录，工程结构如下：</p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529225577524.png" alt="1529225577524" style="zoom: 80%;"><h2 id="3-5-创建EurekaServer"><a href="#3-5-创建EurekaServer" class="headerlink" title="3.5 创建EurekaServer"></a>3.5 创建EurekaServer</h2><h3 id="3-5-1-创建工程"><a href="#3-5-1-创建工程" class="headerlink" title="3.5.1 创建工程"></a>3.5.1 创建工程</h3><p>注册中心起名为：leyou-registry</p><p>选择新建module：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529225751893.png" alt="1529225751893" style="zoom:67%;"><p>不要选择骨架：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529225984078.png" alt="1529225984078" style="zoom:67%;"><p>然后填写项目坐标，我们的项目名称为leyou-registry:</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529226086759.png" alt="1529226086759" style="zoom:67%;"><p>选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529226475238.png" alt="1529226475238" style="zoom:80%;"><h3 id="3-5-2-pom-xml添加依赖"><a href="#3-5-2-pom-xml添加依赖" class="headerlink" title="3.5.2 pom.xml添加依赖"></a>3.5.2 pom.xml添加依赖</h3><p>添加EurekaServer的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.common<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou-registry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-3-启动类"><a href="#3-5-3-启动类" class="headerlink" title="3.5.3 启动类"></a>3.5.3 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeyouRegistryApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(LeyouRegistryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-4-yml配置文件"><a href="#3-5-4-yml配置文件" class="headerlink" title="3.5.4 yml配置文件"></a>3.5.4 yml配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">leyou-registry</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 把自己注册到eureka服务列表</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 拉取eureka服务信息</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">5000</span> <span class="comment"># 每隔5秒钟，进行一次服务列表的清理</span></span><br></pre></td></tr></table></figure><h3 id="3-5-5-项目的结构"><a href="#3-5-5-项目的结构" class="headerlink" title="3.5.5 项目的结构"></a>3.5.5 项目的结构</h3><p>目前，整个项目的结构如图：</p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529288386033.png" alt="1529288386033" style="zoom:80%;"><h2 id="3-6-创建Zuul网关"><a href="#3-6-创建Zuul网关" class="headerlink" title="3.6 创建Zuul网关"></a>3.6 创建Zuul网关</h2><h3 id="3-6-1-创建工程"><a href="#3-6-1-创建工程" class="headerlink" title="3.6.1 创建工程"></a>3.6.1 创建工程</h3><p>与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：leyou-gateway</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529288749658.png" alt="1529288749658" style="zoom:67%;"><p>填写保存的目录：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529288865152.png" alt="1529288865152" style="zoom:67%;"><h3 id="3-6-2-pom-xml添加依赖"><a href="#3-6-2-pom-xml添加依赖" class="headerlink" title="3.6.2 pom.xml添加依赖"></a>3.6.2 pom.xml添加依赖</h3><p>这里我们需要添加Zuul和EurekaClient的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.common<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springboot提供微服务检测接口，默认对外提供几个接口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-6-3-启动类"><a href="#3-6-3-启动类" class="headerlink" title="3.6.3 启动类"></a>3.6.3 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeyouGatewayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(LeyouGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-4-yml配置文件"><a href="#3-6-4-yml配置文件" class="headerlink" title="3.6.4 yml配置文件"></a>3.6.4 yml配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">leyou-gateway</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span> <span class="comment"># 路由路径前缀</span></span><br></pre></td></tr></table></figure><h3 id="3-6-5-项目结构"><a href="#3-6-5-项目结构" class="headerlink" title="3.6.5 项目结构"></a>3.6.5 项目结构</h3><p>目前，leyou下有两个子模块：</p><ul><li>leyou-registry：服务的注册中心（EurekaServer）</li><li>leyou-gateway：服务网关（Zuul）</li></ul><p>目前，服务的结构如图所示：</p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529294593632.png" alt="1529294593632" style="zoom:67%;"><p>到这里已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）以后添加。</p><h2 id="3-7-创建商品微服务"><a href="#3-7-创建商品微服务" class="headerlink" title="3.7 创建商品微服务"></a>3.7 创建商品微服务</h2><p>既然是一个全品类的电商购物平台，那么核心自然就是商品。</p><p> 因此搭建的第一个服务就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括：</p><ul><li>商品分类管理</li><li>品牌管理</li><li>商品规格参数管理</li><li>商品管理</li><li>库存管理</li></ul><h3 id="3-7-1-微服务的结构"><a href="#3-7-1-微服务的结构" class="headerlink" title="3.7.1 微服务的结构"></a>3.7.1 微服务的结构</h3><p>因为与商品的品类相关，工程命名为<code>leyou-item</code>.</p><p>需要注意的是，leyou-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，获取的接口数据，也需要对应的实体类来封装，因此肯定也会使用到接口中关联的实体类。</p><p>因此这里需要使用<strong>聚合工程</strong>，将<strong>要提供的接口及相关实体类放到独立子工程中</strong>，以后别人引用的时候，只需要知道坐标即可。</p><p>会在leyou-item中创建两个子工程：</p><ul><li>leyou-item-interface：主要是<strong>对外暴露的接口及相关实体类</strong></li><li>leyou-item-service：所有<strong>业务逻辑及内部使用接口</strong>，这是微服务模块</li></ul><p>调用关系如图所示：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1525744281610.png" alt="1525744281610" style="zoom: 80%;"><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/image-20200718220241604.png" style="zoom: 67%;"><h3 id="3-7-2-leyou-item"><a href="#3-7-2-leyou-item" class="headerlink" title="3.7.2 leyou-item"></a>3.7.2 leyou-item</h3><p>依然是使用maven构建：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529299088082.png" alt="1529299088082" style="zoom: 67%;"><p>保存的位置：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529299138961.png" alt="1529299138961" style="zoom:67%;"><h4 id="pom-xml-1"><a href="#pom-xml-1" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>因为是<strong>聚合工程，所以把项目打包方式设置为pom</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.item<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou-item<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打包方式为pom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-7-3-leyou-item-interface"><a href="#3-7-3-leyou-item-interface" class="headerlink" title="3.7.3.leyou-item-interface"></a>3.7.3.leyou-item-interface</h3><p>在leyou-item工程上点击右键，选择new –&gt; module:</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529299709029.png" alt="1529299709029" style="zoom:67%;"><p>依然是使用maven构建，注意父工程是leyou-item：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529299826248.png" alt="1529299826248" style="zoom:67%;"><p><strong>注意</strong>：目录结构，保存到<code>leyou-item</code>下的<code>leyou-item-interface</code>目录中：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529299921171.png" alt="1529299921171" style="zoom:67%;"><p>点击Finish完成。</p><p>此时的项目结构：</p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529300026401.png" alt="1529300026401" style="zoom:67%;"><h3 id="3-7-4-leyou-item-service"><a href="#3-7-4-leyou-item-service" class="headerlink" title="3.7.4 leyou-item-service"></a>3.7.4 leyou-item-service</h3><p>与<code>leyou-item-interface</code>类似，我们选择在<code>leyou-item</code>上右键，新建module，然后填写项目信息：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529300203991.png" alt="1529300203991" style="zoom:67%;"><p>填写存储位置</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529300292096.png" alt="1529300292096" style="zoom:67%;"><p>点击Finish完成。</p><h3 id="3-7-5-整个微服务结构"><a href="#3-7-5-整个微服务结构" class="headerlink" title="3.7.5 整个微服务结构"></a>3.7.5 整个微服务结构</h3><p>如图所示：</p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529300341449.png" alt="1529300341449" style="zoom:67%;"><p>我们打开leyou-item的pom查看，会发现leyou-item-interface和leyou-item-service都已经成为module了：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529300419107.png" alt="1529300419107" style="zoom:67%;"><p>可以删除leyou-item工程的src目录</p><h3 id="3-7-6-item-serivice的pom-xml添加依赖"><a href="#3-7-6-item-serivice的pom-xml添加依赖" class="headerlink" title="3.7.6 item-serivice的pom.xml添加依赖"></a>3.7.6 item-serivice的pom.xml添加依赖</h3><p>接下来我们给<code>leyou-item-service</code>中添加依赖：</p><p>需要:</p><ul><li>Eureka客户端</li><li>web启动器</li><li>mybatis启动器</li><li>通用mapper启动器</li><li>分页助手启动器</li><li>连接池，我们用默认的Hykira</li><li>mysql驱动</li><li>千万不能忘了，我们自己也需要<code>leyou-item-interface</code>中的实体类</li></ul><p>这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou-item<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.item<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.item<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou-item-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- eureka客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis的启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通用mapper启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 分页助手启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jdbc启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.item<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou-item-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springboot检测服务启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>leyou-item-interface</code>需要什么依赖，再引入。</p><h3 id="3-7-7-编写启动类和yml配置"><a href="#3-7-7-编写启动类和yml配置" class="headerlink" title="3.7.7 编写启动类和yml配置"></a>3.7.7 编写启动类和yml配置</h3><p>在整个<code>leyou-item工程</code>中，只有<code>leyou-item-service</code>是需要启动的。因此在其中编写启动类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeyouItemServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(LeyouItemServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是yml全局属性文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/leyou</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">28830000</span> <span class="comment"># 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数（show variables like &#x27;%timeout%&#x27;;）</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">9</span> <span class="comment"># 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count)</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 5秒钟发送一次心跳</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span> <span class="comment"># 10秒不发送就过期</span></span><br></pre></td></tr></table></figure><h2 id="3-8-添加item-service的路由规则"><a href="#3-8-添加item-service的路由规则" class="headerlink" title="3.8 添加item-service的路由规则"></a>3.8 添加item-service的路由规则</h2><p>既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。</p><p>修改leyou-gateway工程的application.yml配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span> <span class="comment"># 路由路径前缀</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">item-service:</span> <span class="string">/item/**</span> <span class="comment"># 商品微服务的映射路径</span></span><br></pre></td></tr></table></figure><h2 id="3-9-启动测试"><a href="#3-9-启动测试" class="headerlink" title="3.9 启动测试"></a>3.9 启动测试</h2><p>我们分别启动：leyou-registry，leyou-gateway，leyou-item-service</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529335980812.png" alt="1529335980812"></p><p>查看Eureka面板：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529336014109.png" alt="1529336014109" style="zoom: 50%;"><h2 id="3-10-测试路由规则"><a href="#3-10-测试路由规则" class="headerlink" title="3.10 测试路由规则"></a>3.10 测试路由规则</h2><p>为了测试路由规则是否畅通，是不是需要在item-service中编写一个controller接口呢？</p><p>其实不需要，SpringBoot提供了一个依赖：actuator</p><p>只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口：</p><ul><li>/info</li><li>/health</li><li>/refresh</li><li>…</li></ul><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启后访问Eureka控制台：</p><p>鼠标悬停在item-service上，会显示一个地址：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529337273897.png" alt="1529337273897" style="zoom:67%;"><p>这就是actuator提供的接口，我们点击访问：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529337321847.png" alt="1529337321847" style="zoom:67%;"><p>因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。</p><p>接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是：</p><p><a href="http://127.0.0.1:10010/api/item/actuator/info">http://127.0.0.1:10010/api/item/actuator/info</a></p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529337396077.png" alt="1529337396077" style="zoom:67%;"><h2 id="3-11-leyou-common通用工具"><a href="#3-11-leyou-common通用工具" class="headerlink" title="3.11 leyou-common通用工具"></a>3.11 leyou-common通用工具</h2><p>有些工具或通用的约定内容希望被各个服务共享，因此需要创建一个工具模块：<code>leyou-common</code></p><p>右键leyou工程，使用maven来构建module：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529337583947.png" alt="1529337583947" style="zoom:67%;"><p>位置信息：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529337672465.png" alt="1529337672465" style="zoom:67%;"><p>结构：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529337748507.png" alt="1529337748507"></p><p>目前还不需要编码。</p><h2 id="当前项目整体结构"><a href="#当前项目整体结构" class="headerlink" title="当前项目整体结构"></a>当前项目整体结构</h2><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1539770110464.png" alt="1539770110464" style="zoom: 80%;"><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/image-20200719101744191.png" alt="image-20200719101744191" style="zoom:67%;"><h1 id="4-ES6语法指南"><a href="#4-ES6语法指南" class="headerlink" title="4. ES6语法指南"></a>4. ES6语法指南</h1><p>后端项目搭建完毕，接下来就是前端页面了, 需要学习ES6的语法标准。</p><p>ES6就是ECMAScript第6版标准。</p><h2 id="4-1-什么是ECMAScript？"><a href="#4-1-什么是ECMAScript？" class="headerlink" title="4.1 什么是ECMAScript？"></a>4.1 什么是ECMAScript？</h2><p>来看下前端的发展历程：</p><blockquote><p>web1.0时代：</p></blockquote><ul><li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</li></ul><blockquote><p>web2.0时代：</p></blockquote><ul><li>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。</li><li>1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。</li><li>1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了<code>ECMAscript</code>标准规范。JavaScript和JScript都是<code>ECMAScript</code>的标准实现者，随后各大浏览器厂商纷纷实现了<code>ECMAScript</code>标准。</li></ul><p>所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。</p><h2 id="4-2-ECMAScript的快速发展"><a href="#4-2-ECMAScript的快速发展" class="headerlink" title="4.2 ECMAScript的快速发展"></a>4.2 ECMAScript的快速发展</h2><p>而后，ECMAScript就进入了快速发展期。</p><ul><li><p>1998年6月，ECMAScript 2.0 发布。</p></li><li><p>1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。</p></li><li><p>2007年10月。。。。ECMAScript 4.0 草案发布。</p><p>这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。</p><ul><li>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4.0 工作组。</li><li>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</li></ul><p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中</p></li><li><p>2009年12月，ECMAScript 5 发布。</p></li><li><p>2011年6月，ECMAScript 5.1 发布。</p></li><li><p>2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p></li></ul><h2 id="4-3-ES5和6的一些新特性"><a href="#4-3-ES5和6的一些新特性" class="headerlink" title="4.3 ES5和6的一些新特性"></a>4.3 ES5和6的一些新特性</h2><p>详细参考：<a href="http://es6.ruanyifeng.com/?search=reduce&x=0&y=0#README">阮一峰的ES6教程</a></p><p>创建一个空的html页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-1-let-和-const"><a href="#4-3-1-let-和-const" class="headerlink" title="4.3.1 let 和 const"></a>4.3.1 let 和 const</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><blockquote><p>var</p></blockquote><p>之前，js定义变量只有一个关键字：<code>var</code></p><p><code>var</code>有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。</p><p>例如这样的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;循环外：&quot;</span> + i)</span><br></pre></td></tr></table></figure><p>你猜下打印的结果是什么？</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529376275020.png" alt="1529376275020" style="zoom: 67%;"><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><blockquote><p>let</p></blockquote><p><code>let</code>所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><p>我们把刚才的<code>var</code>改成<code>let</code>试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;循环外：&quot;</span> + i)</span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529395660265.png" alt="1529395660265" style="zoom:67%;"><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><blockquote><p>const</p></blockquote><p><code>const</code>声明的变量是常量，不能被修改</p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1529420270814.png" alt="1529420270814" style="zoom:67%;"><h3 id="4-3-2-字符串API"><a href="#4-3-2-字符串API" class="headerlink" title="4.3.2 字符串API"></a>4.3.2 字符串API</h3><blockquote><p>新的API</p></blockquote><p>ES6为字符串扩展了几个新的API，字符串只要是” “串起来的就成。eg const s =”str”：</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><p>实验一下：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526107640349.png" alt="1526107640349"></p><blockquote><p>字符串模板</p></blockquote><p>ES6中提供了`来作为字符串模板标记：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526108070980.png" alt="1526108070980"></p><p>在两个`之间的部分都会被作为字符串的值，不管任意换行，甚至加入js脚本，<strong>这个换行也会当作字符串的一部分</strong></p><h3 id="4-3-3-解构表达式"><a href="#4-3-3-解构表达式" class="headerlink" title="4.3.3 解构表达式"></a>4.3.3 解构表达式</h3><h4 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h4><blockquote><p>数组解构</p></blockquote><p>比如有一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>我想获取其中的值，只能通过角标。ES6可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [x,y,z] = arr;<span class="comment">// x，y，z将与arr中的每个位置对应来取值</span></span><br><span class="line"><span class="comment">// 然后打印</span></span><br><span class="line"><span class="built_in">console</span>.log(x,y,z);</span><br></pre></td></tr></table></figure><p>结果：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526109778368.png" alt="1526109778368"></p><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><blockquote><p>对象解构</p></blockquote><p>例如有个person对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name:<span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    language: [<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构表达式获取值</span></span><br><span class="line"><span class="keyword">const</span> &#123;name,age,language&#125; = person;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(language);</span><br></pre></td></tr></table></figure><p>结果：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526109984544.png" alt="1526109984544"></p><p>如过想要用其它变量接收，需要额外指定别名：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526110159450.png" alt="1526110159450"></p><p><code>&#123;name:n&#125;</code>：name是person中的属性名，冒号后面的n是解构后要赋值给的变量，也就是说n是该属性的别名。</p><h3 id="4-3-4-函数优化"><a href="#4-3-4-函数优化" class="headerlink" title="4.3.4 函数优化"></a>4.3.4 函数优化</h3><h4 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h4><blockquote><p>1）函数参数默认值</p></blockquote><p>在ES6以前无法给一个函数参数设置默认值，只能采用变通写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a , b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断b是否为空，为空就给默认值1</span></span><br><span class="line">    b = b || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只传一个参数</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>现在可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a , b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传一个参数</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><blockquote><p>2）<strong>箭头函数</strong></p></blockquote><p>ES6中定义函数的简写方式：</p><ul><li>一个参数时：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> print2 = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><ul><li>多个参数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数的情况：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a , b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> sum2 = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br></pre></td></tr></table></figure><p>代码不止一行，可以用<code>&#123;&#125;</code>括起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum3 = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的函数属性简写"><a href="#对象的函数属性简写" class="headerlink" title="对象的函数属性简写"></a>对象的函数属性简写</h4><blockquote><p><strong>对象的函数属性简写</strong></p></blockquote><p>比如一个Person对象，里面有eat方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="comment">// 以前：</span></span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 箭头函数版：</span></span><br><span class="line">    eat2: <span class="function"><span class="params">food</span> =&gt;</span> <span class="built_in">console</span>.log(person.name + <span class="string">&quot;在吃&quot;</span> + food),  <span class="comment">// 特别注意-----------这里拿不到this</span></span><br><span class="line">    <span class="comment">// 简写版：</span></span><br><span class="line">    eat3(food)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="箭头函数结合解构表达式"><a href="#箭头函数结合解构表达式" class="headerlink" title="箭头函数结合解构表达式"></a>箭头函数结合解构表达式</h4><blockquote><p><strong>箭头函数结合解构表达式</strong></p></blockquote><p>比如有一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name:<span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    language: [<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello,&quot;</span> + person.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用箭头函数和解构表达式，这个就相当于说是参数为{name}，而不是person</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hi = <span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span>  <span class="built_in">console</span>.log(<span class="string">&quot;hello,&quot;</span> + name); <span class="comment">//注意这里是&#123;&#125;</span></span><br><span class="line">hi(person)</span><br></pre></td></tr></table></figure><h3 id="4-3-5-map和reduce"><a href="#4-3-5-map和reduce" class="headerlink" title="4.3.5 map和reduce"></a>4.3.5 map和reduce</h3><p>数组中新增了map和reduce方法。</p><blockquote><p>map</p></blockquote><p><code>map()</code>：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><p>举例：有一个字符串数组，我们希望转为int数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;20&#x27;</span>,<span class="string">&#x27;-5&#x27;</span>,<span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line">arr = arr.map(<span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">parseInt</span>(s));</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure><p>  <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526110796839.png" alt="1526110796839"></p><blockquote><p>reduce</p></blockquote><p><code>reduce()</code>：接收一个函数（必须）和一个初始值（可选）。</p><p>第一个参数（函数）接收两个参数：</p><ul><li>第一个参数是上一次reduce处理的结果</li><li>第二个参数是数组中要处理的下一个元素</li></ul><p><code>reduce()</code>会<strong>从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数</strong>。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数</p><p>相当于跟循环计数类似，只是说写法不同。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1,20,-5,3]</span><br></pre></td></tr></table></figure><p>没有初始值：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526111537204.png" alt="1526111537204"></p><p>这里第一个就是  1+20 ==&gt; 21+-5 ==&gt; 16+3</p><p>指定初始值：</p><p> <img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1526111580742.png" alt="1526111580742"></p><p>这里的第四个就是  -1*1==&gt; -1*20 ==&gt; -20*-5 ==&gt; 100*3</p><h3 id="4-3-6-对象扩展keys-values-entries-assign"><a href="#4-3-6-对象扩展keys-values-entries-assign" class="headerlink" title="4.3.6 对象扩展keys values entries assign"></a>4.3.6 对象扩展keys values entries assign</h3><p>ES6给Object拓展了许多新的方法，如：</p><ul><li><p>keys(obj)：获取对象的<strong>所有key形成的数组</strong>   </p><p>​    使用:  <code>Object.keys(person1)</code></p></li><li><p>values(obj)：获取对象的<strong>所有value形成的数组</strong>    </p><p>​    使用：<code>Object.values(person1)</code></p></li><li><p>entries(obj)：获取对象的<strong>所有key和value形成的二维数组</strong>。格式：<code>[[k1,v1],[k2,v2],...]</code></p><p>​    使用：<code>Object.entries(person1)</code></p></li><li><p>assign(dest, …src) ：将<strong>多个src对象的值 拷贝到 dest中（浅拷贝）</strong>，相同的属性会覆盖，不同属性会添加。</p><p><img src="/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/1527210872966.png" alt="1527210872966"></p></li></ul><h3 id="4-3-7-数组扩展find-findIndex-includes"><a href="#4-3-7-数组扩展find-findIndex-includes" class="headerlink" title="4.3.7 数组扩展find findIndex includes"></a>4.3.7 数组扩展find findIndex includes</h3><p>ES6给数组新增了许多方法：</p><ul><li><p><code>find(callback)</code>：数组实例的find方法，用于找出第一个符合条件的数组成员。它的<strong>参数是一个回调函数</strong>，所有数组成员依次执行该回调函数，<strong>直到找出第一个返回值为true的成员，然后返回该成员</strong>。如果没有符合条件的成员，则返回undefined。</p><p>​    eg:  arr.find(a=&gt;a==30)    arr.find(p=&gt;p.age==30)</p></li><li><p><code>findIndex(callback)</code>：数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的<strong>位置</strong>，如果所有成员都不符合条件，则返回-1。 </p></li><li><p><code>includes(数组元素)</code>：与find类似，如果匹配到元素，则返回true，代表找到了，注意这只能适用基本数据类型。</p></li></ul><h1 id="ES6总结"><a href="#ES6总结" class="headerlink" title="ES6总结"></a>ES6总结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.l</span>et:声明一个变量，不会越界 </span><br><span class="line">  <span class="keyword">const</span>：声明一个常量</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>字符串</span><br><span class="line">    includes</span><br><span class="line">    startsWith</span><br><span class="line">    endsWith</span><br><span class="line">    <span class="keyword">const</span> ss = ``</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>解构表达式</span><br><span class="line">    数组：let [x,y,z]=arr</span><br><span class="line">    对象: let &#123;name:a, age:b&#125;=person</span><br><span class="line">        </span><br><span class="line"><span class="number">4.</span>函数</span><br><span class="line">    赋默认值：方法参数列表赋默认值 (a, b=<span class="number">1</span>)=&gt;&#123;&#125;</span><br><span class="line">    箭头函数：()=&gt;&#123;&#125;</span><br><span class="line">    对象中定义函数：</span><br><span class="line">        传统 eat：function()&#123;&#125;</span><br><span class="line">        箭头 eat：()=&gt;&#123;&#125;</span><br><span class="line">        简写 eat()&#123;&#125;</span><br><span class="line">    箭头函数结合结构表达式：(&#123;name&#125;)=&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>map和reduce</span><br><span class="line">    map(fun)：处理一个数组，遍历数组中的每一个元素用fun处理，把处理结果放入新的数组</span><br><span class="line">    reduce(fun(a, b)[, <span class="number">100</span>])：没有初始值（<span class="number">1.</span> a=<span class="number">10</span> b=<span class="number">20</span>  <span class="number">2.</span> a=<span class="number">30</span> b=<span class="number">30</span>） 有初始值（<span class="number">1.</span>a=<span class="number">100</span> b=<span class="number">10</span>  <span class="number">2.</span>a=<span class="number">110</span> b=<span class="number">20</span>）</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>对象的扩展</span><br><span class="line">    keys</span><br><span class="line">    values</span><br><span class="line">    entries：二维数组</span><br><span class="line">    assign(dest, ...src)</span><br><span class="line">    </span><br><span class="line"><span class="number">7.</span>数组扩展</span><br><span class="line">    find findIndex includes</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;电商行业介绍&lt;/li&gt;
&lt;li&gt;乐优商城整体项目结构&lt;/li&gt;
&lt;li&gt;项目基本框架的搭建（EurekaServer、z</summary>
      
    
    
    
    <category term="乐优商城" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"/>
    
    <category term="乐优商城结构_基本框架_ES6" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6-ES6/"/>
    
    
    <category term="乐优商城结构" scheme="https://mrchen229.github.io/tags/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84/"/>
    
    <category term="基本框架搭建(EurekaServer_zuul_item_common)" scheme="https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA-EurekaServer-zuul-item-common/"/>
    
    <category term="ES6语法" scheme="https://mrchen229.github.io/tags/ES6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix(降级_熔断)_Feign_Zuul_ZuulFilter</title>
    <link href="https://mrchen229.github.io/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/"/>
    <id>https://mrchen229.github.io/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/</id>
    <published>2020-08-29T06:04:08.000Z</published>
    <updated>2020-08-29T06:50:33.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基本流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.引入启动器</span><br><span class="line">2.覆盖默认配置</span><br><span class="line">3.在引导类上启用组件</span><br></pre></td></tr></table></figure><ul><li><p>Eureka</p><ul><li><p>高可用</p></li><li><p>心跳过期 service-provider</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka：</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 心跳时间</span></span><br><span class="line">        <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">15</span> <span class="comment"># 过期时间</span></span><br></pre></td></tr></table></figure></li><li><p>拉取服务的间隔时间 service-consumer</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>关闭自我保护，定期清除无效连接</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">5000</span> </span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>ribbon: 负载均衡组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>eureka集成了</span><br><span class="line"><span class="number">2.</span><span class="meta">@LoadBalanced</span>：开启负载均衡</span><br><span class="line"><span class="number">3.</span><span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;http://service-provider/user/&quot;</span> + id, User.class);</span><br></pre></td></tr></table></figure></li><li><p>hystrix：容错组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务降级：检查每次请求，是否请求超时，或者连接池已满</span><br><span class="line">    <span class="number">1.</span>引入hystrix启动器</span><br><span class="line">    <span class="number">2.</span>熔断时间，默认<span class="number">1</span>s,可以修改</span><br><span class="line">    <span class="number">3.</span>在引导类上添加了一个注解：<span class="meta">@EnableCircuitBreaker</span>  <span class="meta">@SpringCloudApplication</span></span><br><span class="line">    <span class="number">4.</span>定义熔断方法：局部（要和被熔断的方法返回值和参数列表一致）  全局（返回值类型要被熔断的方法一致，参数列表必须为空）</span><br><span class="line">    <span class="number">5.</span><span class="meta">@HystrixCommand(fallbackMethod=&quot;局部熔断方法名&quot;)</span>：声明被熔断的方法</span><br><span class="line">    <span class="number">6.</span><span class="meta">@DefaultProperties(defaultFallback=&quot;全局熔断方法名&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">熔断：不再发送请求</span><br><span class="line">    <span class="number">1.</span>close：闭合状态，所有请求正常方法</span><br><span class="line">    <span class="number">2.</span>open：打开状态，所有请求都无法访问。如果在一定时间内容，失败的比例不小于<span class="number">50</span>%或者次数不少于<span class="number">20</span>次</span><br><span class="line">    <span class="number">3.</span>half open：半开状态，打开状态默认<span class="number">5</span>s休眠期，在休眠期所有请求无法正常访问。过了休眠期会进入半开状态，放部分请求通过</span><br></pre></td></tr></table></figure></li><li><p>feign</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>引入openFeign启动器</span><br><span class="line"><span class="number">2.f</span>eign.hystrix.enable=<span class="keyword">true</span>,开启feign的熔断功能</span><br><span class="line"><span class="number">3.</span>在引导类上 <span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="number">4.</span>创建一个接口，在接口添加<span class="meta">@FeignClient(value=&quot;服务id&quot;, fallback=实现类.class)</span></span><br><span class="line"><span class="number">5.</span>在接口中定义一些方法，这些方法的书写方式跟之前controller类似</span><br><span class="line"><span class="number">6.</span>创建了一个熔断类，实现feign接口，实现对应的方法，这些实现方法就是熔断方法</span><br></pre></td></tr></table></figure></li><li><p>zuul</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    1.引入zuul的启动器</span><br><span class="line">    2.配置：</span><br><span class="line">        zuul.routes.&lt;路由名称&gt;.path&#x3D;&#x2F;service-provider&#x2F;**</span><br><span class="line">        zuul.routes.&lt;路由名称&gt;.url&#x3D;http:&#x2F;&#x2F;localhost:8082</span><br><span class="line">        zuul.routes.&lt;路由名称&gt;.path&#x3D;&#x2F;service-provider&#x2F;**</span><br><span class="line">        zuul.routes.&lt;路由名称&gt;.serviceId&#x3D;service-provider</span><br><span class="line"></span><br><span class="line">        zuul.routes.服务名&#x3D;&#x2F;service-provider&#x2F;**   *******************</span><br><span class="line"></span><br><span class="line">        不用配置，默认就是服务id开头路径</span><br><span class="line">    3.@EnableZuulProxy</span><br><span class="line"></span><br><span class="line">过滤器：</span><br><span class="line">    创建一个类继承ZuulFilter基类</span><br><span class="line">    重写四个方法</span><br><span class="line">        filterType：pre route post error</span><br><span class="line">        filterOrder：返回值越小优先级越高</span><br><span class="line">        shouldFilter：是否执行run方法。true执行</span><br><span class="line">        run：具体的拦截逻辑    </span><br><span class="line">        </span><br><span class="line">设置负载均衡和熔断</span><br></pre></td></tr></table></figure></li></ul><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/springCloud_xmind.png"><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>Hystix配置<ul><li>服务降级</li><li>服务熔断</li></ul></li><li>Feign配置（集成了ribbon与hystrix）</li><li>Zuul网关配置（集成了ribbon与hystrix）</li><li>Zuul的过滤器</li></ul><p>注意点：要区分 注册中心、服务提供方、服务消费方的配置</p><h1 id="1-Hystrix"><a href="#1-Hystrix" class="headerlink" title="1.Hystrix"></a>1.Hystrix</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Hystrix是一种保护机制, 是Netflix公司的一款组件。</p><p>主页：<a href="https://github.com/Netflix/Hystrix/">https://github.com/Netflix/Hystrix/</a></p><p>​        Hystix是Netflix开源的一个延迟和容错库，用于<strong>隔离访问远程服务、第三方库，防止出现级联失败</strong>。</p><h2 id="1-2-雪崩问题"><a href="#1-2-雪崩问题" class="headerlink" title="1.2 雪崩问题"></a>1.2 雪崩问题</h2><p>微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：</p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1533829099748.png" alt="1533829099748" style="zoom:67%;"><p>如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。</p><p>如果此时，某个服务出现异常：</p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1533829198240.png" alt="1533829198240" style="zoom:67%;"><p>例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1533829307389.png" alt="1533829307389" style="zoom:67%;"><p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。</p><p>Hystix解决雪崩问题的手段有两个：</p><ul><li><strong>线程隔离</strong></li><li><strong>服务熔断</strong></li></ul><h2 id="1-3-线程隔离，服务降级"><a href="#1-3-线程隔离，服务降级" class="headerlink" title="1.3 线程隔离，服务降级"></a>1.3 线程隔离，服务降级</h2><h3 id="1-3-1-原理"><a href="#1-3-1-原理" class="headerlink" title="1.3.1 原理"></a>1.3.1 原理</h3><p>线程隔离示意图：</p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1533829598310.png" alt="1533829598310" style="zoom: 67%;"><p>解读：</p><p>​    Hystrix为<strong>每个依赖服务调用分配一个小的线程池</strong>，如果线程池已满调用将被立即拒绝，默认不采用排队。加速失败判定时间。</p><p>​    用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务</p><p>​    如果<strong>线程池已满</strong>，或者<strong>请求超时</strong>，则会进行降级处理，也就是服务降级：</p><blockquote><p>服务降级：优先保证核心服务，而非核心服务不可用或弱可用。</p></blockquote><p>​        用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息）。</p><p>​        服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。</p><p>触发Hystix服务降级的情况：</p><ul><li>1.线程池已满</li><li>2.请求超时</li></ul><h3 id="1-3-2-示例（配置消费方）"><a href="#1-3-2-示例（配置消费方）" class="headerlink" title="1.3.2 示例（配置消费方）"></a>1.3.2 示例（配置消费方）</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>首先在service-consumer的pom.xml中引入<strong>Hystrix依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启熔断"><a href="#开启熔断" class="headerlink" title="开启熔断"></a>开启熔断</h4><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1535341341482.png" alt="1535341341482" style="zoom: 80%;"><p>​        可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：**<code>@SpringCloudApplication</code>**</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1535341390087.png" alt="1535341390087" style="zoom:80%;"><p>因此可以使用这个组合注解来代替之前的3个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写降级逻辑"><a href="#编写降级逻辑" class="headerlink" title="编写降级逻辑"></a>编写降级逻辑</h4><p>改造<strong>service-consumer</strong>，当<strong>目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示</strong>。因此需要提前编写好失败时的降级处理逻辑，要使用<strong>HystixCommond</strong>来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;consumer/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;queryUserByIdFallBack&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;http://service-provider/user/&quot;</span> + id, String.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserByIdFallBack</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求繁忙，请稍后再试！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：<strong>相同的参数列表和返回值声明</strong>。</p><p>​        失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们<strong>把queryById的方法改造为返回String，反正也是Json数据</strong>。这样失败逻辑中返回一个错误说明，会比较方便。</p><p>说明：</p><ul><li><strong>@HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法</strong></li></ul><p>测试：</p><p>​        当<code>itcast-service-provider</code>正常提供服务时，访问与以前一致。但是<strong>将service-provider停机时，页面返回了降级处理信息</strong>：</p><p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1535852634763.png" alt="1535852634763"></p><h4 id="默认FallBack"><a href="#默认FallBack" class="headerlink" title="默认FallBack"></a>默认FallBack</h4><p>​        刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以可以<strong>把Fallback配置加在类上，实现默认fallback</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;consumer/user&quot;)</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;fallBackMethod&quot;)</span> <span class="comment">// 指定一个类的全局熔断方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span> <span class="comment">// 标记该方法需要熔断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;http://service-provider/user/&quot;</span> + id, String.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 熔断方法</span></span><br><span class="line"><span class="comment">     * 返回值要和被熔断的方法的返回值一致</span></span><br><span class="line"><span class="comment">     * 熔断方法不需要参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallBackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求繁忙，请稍后再试！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1）@DefaultProperties(defaultFallback = “defaultFallBack”)：在类上指明统一的默认失败降级方法</li><li>2）@HystrixCommand：在方法上直接使用该注解，使用默认的剪辑方法，若指定了方法则使用指定的。</li><li>3）<strong>defaultFallback</strong>：默认降级方法，<strong>不用任何参数</strong>，以匹配更多方法，但是<strong>返回值一定一致</strong></li></ul><p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1535852634763.png" alt="1535852634763"></p><p>注意：</p><p>​    若熔断方法写了返回值不是String需要自己进行序列化操作(ObjectMapper)。</p><h4 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h4><p>​        在之前的案例中，请求在<strong>超过1秒后都会返回错误信息</strong>，部署时这个时间较小，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：</p><p>​        可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来<strong>设置Hystrix超时时间</strong>。该配置没有提示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">6000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure><p><strong>改造服务提供者</strong></p><p>改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryUserById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-服务熔断"><a href="#1-4-服务熔断" class="headerlink" title="1.4 服务熔断"></a>1.4 服务熔断</h2><h3 id="1-4-1-熔断条件与状态"><a href="#1-4-1-熔断条件与状态" class="headerlink" title="1.4.1 熔断条件与状态"></a>1.4.1 熔断条件与状态</h3><p>熔断器，也叫断路器，其英文单词为：Circuit Breaker </p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1525658640314.png" alt="1525658640314" style="zoom:80%;"><p>熔断状态机3个状态：</p><ul><li><p>1）Closed：关闭状态，所有请求都正常访问。</p></li><li><p>2）Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比<strong>达到阈值</strong>，则触发熔断，断路器会完全打开。</p><p>三个重要参数：快照时间窗、请求总数阈值、错误百分比阈值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.快照时间窗: 断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒</span><br><span class="line">2.请求总数阈值：在快照时间窗内，必须满足请求综述阈值才有资格熔断。默认为20s，意味着10秒内，若该hystrix命令的调用次数不足20次，即使所有的请求都超时或者其他原因失败，断路器都不会打开。</span><br><span class="line">3.错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了20次调用，若在这20次调用中10次发生了超时异常，也就是超过了50%的错误百分比，此时断路器就会打开。</span><br></pre></td></tr></table></figure></li><li><p>3）Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S），随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求成功，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时</p></li></ul><h3 id="1-4-2-配置修改熔断策略"><a href="#1-4-2-配置修改熔断策略" class="headerlink" title="1.4.2 配置修改熔断策略"></a>1.4.2 配置修改熔断策略</h3><p>为了能够精确控制请求的成功或失败，我们在<strong>consumer</strong>的调用业务中加入一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;太忙了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;http://service-provider/user/&quot;</span> + id, String.class);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空service-provider中的休眠逻辑）</p><p>我们准备两个请求窗口：</p><ul><li>一个请求：<a href="http://localhost/consumer/user/1%EF%BC%8C%E6%B3%A8%E5%AE%9A%E5%A4%B1%E8%B4%A5">http://localhost/consumer/user/1，注定失败</a></li><li>一个请求：<a href="http://localhost/consumer/user/2%EF%BC%8C%E8%82%AF%E5%AE%9A%E6%88%90%E5%8A%9F">http://localhost/consumer/user/2，肯定成功</a></li></ul><p>当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会断开，一切请求都会被降级处理。</p><p>此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有几毫秒左右：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1543053265477.png" alt="1543053265477" style="zoom:67%;"><p>不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">circuitBreaker.requestVolumeThreshold</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">circuitBreaker.sleepWindowInMilliseconds</span>=<span class="string">10000</span></span><br><span class="line"><span class="meta">circuitBreaker.errorThresholdPercentage</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure><p>解读：</p><ul><li>requestVolumeThreshold：<strong>触发熔断的最小请求次数</strong>，默认20</li><li>errorThresholdPercentage：触发熔断的失败请求<strong>最小占比</strong>，默认50%</li><li>sleepWindowInMilliseconds：休眠时长，默认是5000毫秒</li></ul><h1 id="2-Feign-集成ribbon与hystrix"><a href="#2-Feign-集成ribbon与hystrix" class="headerlink" title="2. Feign(集成ribbon与hystrix)"></a>2. Feign(集成ribbon与hystrix)</h1><p>Ribbon的负载均衡功能 能大大简化远程调用时的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;http://service-provider/user/&quot;</span> + id, String.class);</span><br></pre></td></tr></table></figure><p>但需要编写类似的大量重复代码，格式基本相同，无非参数不一样。Feign能够对其进一步优化。</p><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>​        Feign就是伪装，Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</p><p>项目主页：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1525652009416.png" alt="1525652009416" style="zoom:67%;"><h2 id="2-2-快速入门（配置消费方）"><a href="#2-2-快速入门（配置消费方）" class="headerlink" title="2.2.快速入门（配置消费方）"></a>2.2.快速入门（配置消费方）</h2><p>改造<strong>service-consumer工程</strong></p><h3 id="2-2-1-导入依赖"><a href="#2-2-1-导入依赖" class="headerlink" title="2.2.1 导入依赖"></a>2.2.1 导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-开启Feign功能"><a href="#2-2-2-开启Feign功能" class="headerlink" title="2.2.2 开启Feign功能"></a>2.2.2 开启Feign功能</h3><p>我们在<strong>service-consumer启动类上</strong>，<strong>添加注解</strong>，开启Feign功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 开启feign客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除RestTemplate</strong>：feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，此处<strong>不需要再注册RestTemplate</strong>。</p><h3 id="2-2-3-Feign的客户端"><a href="#2-2-3-Feign的客户端" class="headerlink" title="2.2.3 Feign的客户端"></a>2.2.3 Feign的客户端</h3><p>在<strong>service-consumer</strong>工程中，添加UserClient接口：</p><p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1540683659305.png" alt="1540683659305"></p><p>内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;service-provider&quot;)</span> <span class="comment">// 标注该类是一个feign接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>; <span class="comment">//这里和service-provider的写法相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先这是一个接口，Feign会通过<strong>动态代理，帮我们生成实现类</strong>。这点跟mybatis的mapper很像</li><li><code>@FeignClient</code>，声明这是一个Feign客户端，类似<code>@Mapper</code>注解。同时通过<code>value</code>属性指定服务名称</li><li>接口中的定义方法，完全采用SpringMVC的注解，Feign<strong>会根据注解帮我们生成URL，并访问获取结果</strong></li></ul><p>改造原来的调用逻辑，调用UserClient接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;consumer/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>     <span class="comment">//@GetMapping(&quot;$&#123;id&#125;&quot;)，下面就要改成@PathVariable(&quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.userClient.queryUserById(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：</p><p>​      @GetMapping,@PostMapping,@PutMapping注解无value值时，不写value值的时候默认调用根路径，所以一个controller中不能有多个注解不写value值。当如果请求方式不一样是可以多个的，但是每种请求方法也只能有一个不写value值。</p><p>​     所以这里还是写上的好。</p><h3 id="2-2-4-启动测试"><a href="#2-2-4-启动测试" class="headerlink" title="2.2.4 启动测试"></a>2.2.4 启动测试</h3><p>访问接口： </p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1535346290987.png" alt="1535346290987" style="zoom: 80%;"><p>正常获取到了结果。</p><h2 id="2-3-负载均衡-ribbon"><a href="#2-3-负载均衡-ribbon" class="headerlink" title="2.3 负载均衡(ribbon)"></a>2.3 负载均衡(ribbon)</h2><p><strong>Feign中本身已经集成了Ribbon依赖和自动配置</strong>：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1528859608579.png" alt="1528859608579" style="zoom:80%;"><p>因此不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p><h2 id="2-4-熔断-Hystrix-配置消费方"><a href="#2-4-熔断-Hystrix-配置消费方" class="headerlink" title="2.4 熔断(Hystrix)(配置消费方)"></a>2.4 熔断(Hystrix)(配置消费方)</h2><p>Feign默认也有对Hystrix的集成：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1528861288636.png" alt="1528861288636" style="zoom:80%;"><p>只不过，默认情况下是关闭的。需要通过下面的参数来开启：**(在service-consumer工程添加配置内容)**</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的熔断功能</span></span><br></pre></td></tr></table></figure><p>但是，Feign中的Fallback配置不像hystrix中那样简单了。</p><p>1）首先，我们要**定义一个类UserClientFallback，实现刚才编写的<code>UserClient</code>**，作为fallback的处理类，注意这里的@Component</p><p>​    @component （把普通pojo实例化到spring容器中，相当于配置文件中的 <code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code> ）</p><p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1540683742479.png" alt="1540683742479"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientFallback</span> <span class="keyword">implements</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">&quot;服务器繁忙，请稍后再试！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）然后<strong>在UserFeignClient中，指定刚才编写的实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;service-provider&quot;, fallback = UserClientFallback.class)</span> <span class="comment">// 标注该类是一个feign接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）重启测试：</p><p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1535346896313.png" alt="1535346896313"></p><h2 id="2-5-请求压缩-了解"><a href="#2-5-请求压缩-了解" class="headerlink" title="2.5 请求压缩(了解)"></a>2.5 请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可<strong>开启请求与响应的压缩功能</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启响应压缩</span></span><br></pre></td></tr></table></figure><p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/html,application/xml,application/json</span> <span class="comment"># 设置压缩的数据类型</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment"># 设置触发压缩的大小下限</span></span><br></pre></td></tr></table></figure><p>注：上面的数据类型、压缩大小下限均为默认值。</p><h2 id="2-6-日志级别-配置消费方"><a href="#2-6-日志级别-配置消费方" class="headerlink" title="2.6 日志级别(配置消费方)"></a>2.6 日志级别(配置消费方)</h2><p>​        前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p><p>1）设置com.leyou包下的日志级别都为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.leyou:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>2）编写配置类，定义日志级别</p><p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1529113196740.png" alt="1529113196740"></p><p>内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignLogConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定的Level级别是FULL，Feign支持4种级别：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1528863525224.png" alt="1528863525224" style="zoom:67%;"><ul><li><ol><li>NONE：不记录任何日志信息，这是默认值。</li></ol></li><li><ol start="2"><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li></ol></li><li><ol start="3"><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li></ol></li><li><ol start="4"><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ol></li></ul><p>3）在FeignClient中指定配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;service-privider&quot;, fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）重启项目，即可看到每次访问的日志：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1528863489923.png" alt="1528863489923" style="zoom: 67%;"><h1 id="3-Zuul网关-集成ribbon与hystrix"><a href="#3-Zuul网关-集成ribbon与hystrix" class="headerlink" title="3. Zuul网关(集成ribbon与hystrix)"></a>3. Zuul网关(集成ribbon与hystrix)</h1><p>通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1525674644660.png" alt="1525674644660" style="zoom:80%;"><pre><code>    我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；    而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。    为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。    在该架构中，我们的服务集群包含：    内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。    在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</code></pre><p>先来说说这样架构需要做的一些事儿以及存在的不足：</p><ul><li><p>破坏了服务无状态特点。</p><pre><code>为了保证对外服务的安全性，我们需要**实现对服务访问的权限控制**(每个需要重复实现权限控制)，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。  从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</code></pre></li><li><p>无法直接复用既有接口。</p><pre><code>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</code></pre></li></ul><p>解决：服务网关！</p><p>​      为了解决这些问题，需要将权限控制这样的东西从服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，需要一个<strong>更强大一些的均衡负载器的 服务网关</strong>。</p><p>​      服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了<strong>具备<code>服务路由</code>、<code>均衡负载</code>功能之外，它还具备了<code>权限控制</code>等功能</strong>。</p><p>​        Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时<strong>将权限控制这些较重的非业务逻辑内容迁移到服务路由层面</strong>，使得服务集群主体能够具备更高的可复用性和可测试性。</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/image-20200717164319022.png" style="zoom:67%;"><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>官网：<a href="https://github.com/Netflix/zuul">https://github.com/Netflix/zuul</a></p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1525675168152.png" alt="1525675168152" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路由：分发给不同的微服务（服务名），service-provider-a， service-provider-b</span><br><span class="line">负载均衡：同一个微服务的不同实例  service-provider</span><br></pre></td></tr></table></figure><h2 id="3-2-Zuul加入后的架构"><a href="#3-2-Zuul加入后的架构" class="headerlink" title="3.2.Zuul加入后的架构"></a>3.2.Zuul加入后的架构</h2><p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1525675648881.png" alt="1525675648881"></p><p>​        不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。<strong>一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作</strong>。</p><p>​        <strong>Zuul就是我们服务的统一入口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意，这个示例中是用zuul代理service-provider，所以说zuul是代理某一些指定的服务，并不是所有。</span><br><span class="line">    这些服务被zuul代理后，请求会经过zuul再到服务之中。</span><br></pre></td></tr></table></figure><h2 id="3-3-快速入门"><a href="#3-3-快速入门" class="headerlink" title="3.3 快速入门"></a>3.3 快速入门</h2><h3 id="3-3-1-新建工程"><a href="#3-3-1-新建工程" class="headerlink" title="3.3.1 新建工程"></a>3.3.1 新建工程</h3><p>填写基本信息：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1529112749084.png" alt="1529112749084" style="zoom:67%;"><p>添加Zuul依赖：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1529112691169.png" alt="1529112691169" style="zoom:67%;"><p>这一步的依赖是自动添加，手动则为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-编写配置"><a href="#3-3-2-编写配置" class="headerlink" title="3.3.2 编写配置"></a>3.3.2 编写配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务名</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3-编写引导类"><a href="#3-3-3-编写引导类" class="headerlink" title="3.3.3 编写引导类"></a>3.3.3 编写引导类</h3><p>通过<code>@EnableZuulProxy </code>注解开启Zuul的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启zuul网关</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-编写路由规则"><a href="#3-3-4-编写路由规则" class="headerlink" title="3.3.4 编写路由规则"></a>3.3.4 编写路由规则</h3><p>我们需要<strong>用Zuul来代理service-provider服务</strong>，先看一下控制面板中的服务状态：</p><p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1542672192226.png" alt="1542672192226"></p><ul><li>ip为：127.0.0.1</li><li>端口为：8081</li></ul><p>映射规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务名</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="comment"># 这里是路由id，随意写,习惯上是路由到哪个服务，就写哪个服务名</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://127.0.0.1:8081</span> <span class="comment"># 映射路径对应的实际url地址</span></span><br></pre></td></tr></table></figure><p>我们<strong>将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</strong></p><p>本例中，我们**将 <code>/service-provider/</code>开头的请求，代理到<a href="http://127.0.0.1:8081/">http://127.0.0.1:8081</a>   **</p><h3 id="3-3-5-启动测试"><a href="#3-3-5-启动测试" class="headerlink" title="3.3.5 启动测试"></a>3.3.5 启动测试</h3><p>访问的路径中<strong>需要加上配置规则的映射路径</strong>，我们访问：<a href="http://127.0.0.1:10010/service-provider/user/1">http://127.0.0.1:10010/service-provider/user/1</a></p><ul><li>即 <strong>域名+端口+服务名称+请求地址</strong>  能访问到该服务，实际上是该<strong>服务对应的负载均衡后的ip+端口+请求地址</strong>。</li></ul><p>这样就路由到了这个服务。</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1543054030005.png" alt="1543054030005" style="zoom: 80%;"><h2 id="3-4-面向服务的路由"><a href="#3-4-面向服务的路由" class="headerlink" title="3.4 面向服务的路由"></a>3.4 面向服务的路由</h2><p>​        在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。</p><p>   我们<strong>应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由</strong>才对！</p><p>​        对<code>itcast-zuul</code>工程修改优化：<strong>将zuul注入到eureka容器，才能拉取服务列表</strong></p><h3 id="3-4-1-添加Eureka客户端依赖"><a href="#3-4-1-添加Eureka客户端依赖" class="headerlink" title="3.4.1 添加Eureka客户端依赖"></a>3.4.1 添加Eureka客户端依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-2-添加Eureka配置，获取服务信息"><a href="#3-4-2-添加Eureka配置，获取服务信息" class="headerlink" title="3.4.2 添加Eureka配置，获取服务信息"></a>3.4.2 添加Eureka配置，获取服务信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3-4-3-开启Eureka客户端发现功能"><a href="#3-4-3-开启Eureka客户端发现功能" class="headerlink" title="3.4.3 开启Eureka客户端发现功能"></a>3.4.3 开启Eureka客户端发现功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-修改映射配置，通过服务名称获取"><a href="#3-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="3.4.4 修改映射配置，通过服务名称获取"></a>3.4.4 修改映射配置，通过服务名称获取</h3><p>​        因为已经有了Eureka客户端，我们可以<strong>从Eureka获取服务的地址信息，因此映射时<code>无需指定IP地址</code>，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">service-provider</span> <span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure><h3 id="3-4-5-启动测试"><a href="#3-4-5-启动测试" class="headerlink" title="3.4.5 启动测试"></a>3.4.5 启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1543054030005.png" alt="1543054030005" style="zoom: 80%;"><h2 id="3-5-简化的路由配置（常用）"><a href="#3-5-简化的路由配置（常用）" class="headerlink" title="3.5 简化的路由配置（常用）"></a>3.5 简化的路由配置（常用）</h2><p>在刚才的配置中，我们的规则是这样的：</p><ul><li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li><li><code>zuul.routes.&lt;route&gt;.serviceId=service-provider</code>：来指定服务名。</li></ul><p>​    而大多数情况下，我们的**<code>&lt;route&gt;</code>路由名称往往和服务名会写成一样的**。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p><p>​        比方说上面我们关于service-provider的配置可以<strong>简化</strong>为一条：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br></pre></td></tr></table></figure><p>省去了对服务名称的配置。这里就是把所有 <code>/service-provider/** </code>的请求代理到service-provider服务</p><h2 id="3-6-默认的路由规则"><a href="#3-6-默认的路由规则" class="headerlink" title="3.6 默认的路由规则"></a>3.6 默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。</p><p>  因此Zuul就指定了默认的路由规则：</p><ul><li>​      默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：<code>service-provider</code>，则默认的映射路径就       是：<code>/service-provider/**</code></li></ul><p>也就是说，刚才的映射规则我们完全不配置也是OK的。eg <a href="http://127.0.0.1:10010/service-provider/user/1">http://127.0.0.1:10010/service-provider/user/1</a></p><h2 id="3-7-路由前缀"><a href="#3-7-路由前缀" class="headerlink" title="3.7 路由前缀"></a>3.7 路由前缀</h2><p>配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="string">/service-provider/**</span></span><br><span class="line">    <span class="attr">service-consumer:</span> <span class="string">/service-consumer/**</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span> <span class="comment"># 添加路由前缀</span></span><br></pre></td></tr></table></figure><p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p><p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1543054221479.png" alt="1543054221479"></p><h2 id="3-8-过滤器"><a href="#3-8-过滤器" class="headerlink" title="3.8 过滤器"></a>3.8 过滤器</h2><p>​        Zuul作为网关的其中一个重要功能，就是<strong>实现请求的鉴权</strong>。</p><p>​        而这个动作我们往往是通过Zuul提供的过滤器来实现的。即对请求的拦截。</p><h3 id="3-8-1-ZuulFilter"><a href="#3-8-1-ZuulFilter" class="headerlink" title="3.8.1 ZuulFilter"></a>3.8.1 ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ZuulFilter implements IZuulFilter&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;<span class="comment">// 来自IZuulFilter</span></span><br><span class="line">    <span class="function">Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException</span>;<span class="comment">// IZuulFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul><li><code>pre</code>：请求在被路由之前执行，路由之前的过滤器</li><li><code>route</code>：在路由请求时调用，路由之中的过滤器</li><li><code>post</code>：在route和errror过滤器之后调用，路由之后的过滤器</li><li><code>error</code>：处理请求时发生错误调用，错误处理</li></ul></li><li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li><li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li><li><code>run</code>：过滤器的具体业务逻辑。</li></ul><h3 id="3-8-2-过滤器执行生命周期"><a href="#3-8-2-过滤器执行生命周期" class="headerlink" title="3.8.2.过滤器执行生命周期"></a>3.8.2.过滤器执行生命周期</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1529152248172.png" alt="1529152248172" style="zoom: 80%;"><p>正常流程：</p><ul><li>请求到达首先会经过pre类型过滤器，而后到达route类型，<strong>进行路由</strong>，请求就到达真正的服务提供者，执行请求，<strong>返回结果后</strong>，会到达post过滤器。而后返回响应。</li></ul><p>异常流程：</p><ul><li>整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li><li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。</li><li>如果是POST过滤器出现异常，会跳转到error过滤器然后响应，但是与pre和route不同的是，请求不会再到达POST过滤器了。</li></ul><p>所有内置过滤器列表：</p><p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1525682427811.png"></p><h3 id="3-8-3-使用场景"><a href="#3-8-3-使用场景" class="headerlink" title="3.8.3 使用场景"></a>3.8.3 使用场景</h3><p>场景非常多：</p><ul><li><strong>请求鉴权</strong>：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li><li><strong>异常处理</strong>：一般会在error类型和post类型过滤器中结合来处理。</li><li><strong>服务调用时长统计</strong>：pre和post结合使用。</li></ul><h2 id="3-9-自定义过滤器"><a href="#3-9-自定义过滤器" class="headerlink" title="3.9 自定义过滤器"></a>3.9 自定义过滤器</h2><p>​        接下来我们来自定义一个过滤器，<strong>模拟一个登录的校验</strong>。</p><p>​        基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><h3 id="3-9-1-定义过滤器类"><a href="#3-9-1-定义过滤器类" class="headerlink" title="3.9.1 定义过滤器类"></a>3.9.1 定义过滤器类</h3><p> <img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1529136926454.png" alt="1529136926454"></p><p>内容：注意@Component放入spring容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器类型，pre route post error，这里是前置过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的执行顺序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该过滤器是否生效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的业务逻辑：登陆校验逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取zuul提供的context上下文对象（zuul包中）</span></span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">// 从上下文对象中获取request请求对象</span></span><br><span class="line">        HttpServletRequest request = context.getRequest();</span><br><span class="line">        <span class="comment">// 获取token信息（获取参数）</span></span><br><span class="line">        String token = request.getParameter(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 过滤该请求，不转发请求，不对其进行路由，即进行拦截</span></span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置响应状态码，401</span></span><br><span class="line">            context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="comment">// 设置响应信息</span></span><br><span class="line">            context.setResponseBody(<span class="string">&quot;&#123;\&quot;status\&quot;:\&quot;401\&quot;, \&quot;text\&quot;:\&quot;request error!\&quot;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验通过，把登陆信息放入上下文信息，继续向后执行</span></span><br><span class="line">        context.set(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        <span class="comment">// 返回值null，代表该过滤器什么都不做，即相当于没有该过滤器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-2-测试"><a href="#3-9-2-测试" class="headerlink" title="3.9.2 测试"></a>3.9.2 测试</h3><p>没有token参数时，访问失败：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1529161460740.png" alt="1529161460740" style="zoom:67%;"><p>添加token参数后：</p><img src="/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/1529161252733.png" alt="1529161252733" style="zoom:67%;"><h2 id="3-10-设置负载均衡和熔断"><a href="#3-10-设置负载均衡和熔断" class="headerlink" title="3.10 设置负载均衡和熔断"></a>3.10 设置负载均衡和熔断</h2><p>​        Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">2000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;基本流程：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="乐优商城" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"/>
    
    <category term="SpringCloud" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/SpringCloud/"/>
    
    
    <category term="Hystrix(降级_熔断)" scheme="https://mrchen229.github.io/tags/Hystrix-%E9%99%8D%E7%BA%A7-%E7%86%94%E6%96%AD/"/>
    
    <category term="Feign" scheme="https://mrchen229.github.io/tags/Feign/"/>
    
    <category term="Zuul" scheme="https://mrchen229.github.io/tags/Zuul/"/>
    
    <category term="ZuulFilter" scheme="https://mrchen229.github.io/tags/ZuulFilter/"/>
    
  </entry>
  
  <entry>
    <title>RPC_HTTP_RestTemplate_Springcloud_搭建Eureka(注册中心_提供_消费)_Eureka配置(心跳_获取服务列表_失效剔除_自我保护)_Ribbon配置</title>
    <link href="https://mrchen229.github.io/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/"/>
    <id>https://mrchen229.github.io/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-29T01:10:08.000Z</published>
    <updated>2020-08-29T01:10:48.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>系统架构演变</li><li>服务调用方式(RPC、HTTP、RestTemplate)</li><li>SpringCloud概念</li><li>独立搭建Eureka注册中心、服务提供者、服务消费者</li><li>Eureka的配置（心跳、获取服务列表、失效剔除、自我保护）</li><li>Ribbon的配置与负载均衡策略</li></ul><h1 id="1-系统架构演变"><a href="#1-系统架构演变" class="headerlink" title="1. 系统架构演变"></a>1. 系统架构演变</h1><p>​        随着互联网的发展，网站应用的规模不断扩大。系统架构不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。</p><p>下面介绍系统架构演变的历程。</p><h2 id="1-1-集中式架构"><a href="#1-1-集中式架构" class="headerlink" title="1.1 集中式架构"></a>1.1 集中式架构</h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。</p><p>例如一个tomcat包括后台、前台、用户管理、订单管理、购物车管理</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525529091749.png" alt="1525529091749" style="zoom: 67%;"><p>存在的问题：</p><ul><li>代码耦合度高，开发维护困难</li><li>无法针对不同模块进行针对性优化</li><li>无法水平扩展</li><li>单点容错率低，并发能力差，并发数低</li></ul><p>好处：维护简单</p><h2 id="1-2-垂直拆分"><a href="#1-2-垂直拆分" class="headerlink" title="1.2 垂直拆分"></a>1.2 垂直拆分</h2><p>当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525529671801.png" alt="1525529671801" style="zoom:80%;"><p>优点：</p><ul><li>系统拆分实现了流量分担，解决了并发问题，提高并发</li><li>可以针对不同模块进行优化</li><li>方便水平扩展，负载均衡，容错率提高</li><li>解耦合</li></ul><p>缺点：</p><ul><li>系统间相互独立，会有很多重复开发工作，影响开发效率</li><li>增加维护成本</li></ul><p>补充：</p><p>​        垂直拆分：功能拆分</p><p>​        水平拆分：分层：web service mapper</p><h2 id="1-3-分布式服务"><a href="#1-3-分布式服务" class="headerlink" title="1.3 分布式服务"></a>1.3 分布式服务</h2><p>​        当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。</p><p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525530657919.png" alt="1525530657919"></p><p>优点：</p><ul><li>将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</li><li>解决了代码冗余和重复开发</li></ul><p>缺点：</p><ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul><h2 id="1-4-流动计算架构（SOA）"><a href="#1-4-流动计算架构（SOA）" class="headerlink" title="1.4 流动计算架构（SOA）"></a>1.4 流动计算架构（SOA）</h2><p>SOA ：面向服务的架构</p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键</p><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525530804753.png" alt="1525530804753"></p><p>过去的问题？</p><ul><li>服务越来越多，需要管理每个服务的地址</li><li>调用关系错综复杂，难以理清依赖关系</li><li>服务过多，服务状态难以管理，无法根据服务情况动态管理</li></ul><p>服务治理要做什么？</p><ul><li>服务注册中心，实现服务自动注册和发现，无需人为记录服务地址</li><li>服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系</li><li>动态监控服务状态监控报告，人为控制服务状态</li></ul><p>缺点：</p><ul><li>服务间会有依赖关系，一旦某个环节出错会影响较大</li><li>服务关系复杂，运维、测试部署困难，不符合DevOps思想</li></ul><h2 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5 微服务"></a>1.5 微服务</h2><p>前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者容易混淆但有一些差别：</p><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525532344817.png" alt="1525532344817"></p><p>微服务的特点：</p><ul><li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li><li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li><li>面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li><li>自治：自治是说服务间互相独立，互不干扰<ul><li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li><li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li><li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开发不同接口</li><li>数据库分离：每个服务都使用自己的数据源</li><li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li></ul></li></ul><p>SpringCloud   dubbo(阿里巴巴，品优购 淘淘   apache)</p><p>微服务结构图：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1526860071166.png" alt="1526860071166" style="zoom: 80%;"><h1 id="2-服务调用方式"><a href="#2-服务调用方式" class="headerlink" title="2. 服务调用方式"></a>2. 服务调用方式</h1><h2 id="2-1-RPC和HTTP"><a href="#2-1-RPC和HTTP" class="headerlink" title="2.1 RPC和HTTP"></a>2.1 RPC和HTTP</h2><p>无论是微服务还是SOA，都面临着服务间的远程调用。那么<strong>服务间的远程调用方式</strong>有哪些呢？</p><p>常见的远程调用方式有以下2种：</p><ul><li><p>RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的<code>webservice</code>，现在热门的<code>dubbo</code>，都是RPC的典型代表</p></li><li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。</p><p>现在热门的Rest风格，就可以通过http协议来实现。</p></li></ul><p>如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。</p><p>​        相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。在项目中会选择SpringCloud套件，因此会使用<strong>Http方式来实现服务间调用</strong>。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。</p><p>通过上面的概念，我们可以知道，实现RPC主要是做到两点： </p><ul><li>实现远程调用其他计算机的服务<ul><li>要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点：<ul><li>1）采用何种网络通讯协议？<ul><li>现在比较流行的RPC框架，都会采用TCP作为底层传输协议</li></ul></li><li>2）数据传输的格式怎样？<ul><li>两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。</li></ul></li></ul></li></ul></li><li>像调用本地服务一样调用远程服务 <ul><li>如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装</li></ul></li></ul><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525568965976.png" alt="1525568965976"></p><h3 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h3><p>Http协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。</p><ul><li>RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。</li><li>Http中还定义了资源定位的路径，RPC中并不需要</li><li>最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。<ul><li>优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台</li><li>缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。</li></ul></li></ul><p>例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。</p><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525569352313.png" alt="1525569352313"></p><h2 id="2-2-Http客户端工具"><a href="#2-2-Http客户端工具" class="headerlink" title="2.2 Http客户端工具"></a>2.2 Http客户端工具</h2><ul><li>速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。</li><li>难度来看，RPC实现较为复杂，http相对比较简单</li><li>灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。</li></ul><p>两者都有不同的使用场景：</p><ul><li>如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。</li><li>如果需要更加灵活，跨语言、跨平台，显然http更合适</li></ul><p>微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。</p><p>既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：</p><ul><li>HttpClient  (apache)</li><li>OKHttp</li><li>URLConnection</li></ul><p>接下来，不过这些不同的客户端，API各不相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以在idea中，<span class="keyword">new</span> <span class="keyword">module</span>选择已经存在的模块导入《资料》中的http_demo</span><br><span class="line">    在test中可以看到相关使用,B笔记中有详解。</span><br></pre></td></tr></table></figure><h2 id="2-3-Spring的RestTemplate-封装Http与实现序列化"><a href="#2-3-Spring的RestTemplate-封装Http与实现序列化" class="headerlink" title="2.3 Spring的RestTemplate(封装Http与实现序列化)"></a>2.3 Spring的RestTemplate(封装Http与实现序列化)</h2><p>Spring提供了一个RestTemplate模板工具类，对<strong>基于Http的客户端进行了封装</strong>，并且<strong>实现了对象与json的序列化和反序列化</strong>，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：</p><ul><li>HttpClient</li><li>OkHttp</li><li>JDK原生的URLConnection（默认的）</li></ul><p>首先导入资料提供的http-demo</p><p>然后在项目中注册一个<code>RestTemplate</code>对象，可以在<strong>启动类</strong>位置注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HttpDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>测试类</strong>中直接<code>@Autowired</code>注入：注意这里的@SpringBootTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = HttpDemoApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">httpGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用springboot案例中的rest接口</span></span><br><span class="line">        User user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;http://localhost/user/1&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化</strong>。</li></ul><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525573702492.png" alt="1525573702492"></p><h1 id="3-SpringCloud"><a href="#3-SpringCloud" class="headerlink" title="3.SpringCloud"></a>3.SpringCloud</h1><p>微服务是一种架构方式，最终肯定需要技术架构去实施。</p><ul><li>后台硬：Spring家族的一员。</li><li>技术强：Spring作为Java领域的前辈，有强力的技术团队支撑。SpringCloud与Spring的各个框架无缝整合。</li><li>使用方便：SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建</li></ul><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>SpringCloud是Spring旗下的项目之一，<a href="http://projects.spring.io/spring-cloud/">官网地址：http://projects.spring.io/spring-cloud/</a></p><p>Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。</p><p>SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：</p><ul><li><strong>Eureka</strong>：服务治理组件，包含<strong>服务注册中心</strong>，服务注册与发现机制的实现。（服务治理，服务注册/发现） </li><li><strong>Zuul</strong>：网关组件，提供智能路由，访问过滤功能 </li><li><strong>Ribbon</strong>：客户端负载均衡的服务调用组件（客户端负载） </li><li><strong>Feign</strong>：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） </li><li><strong>Hystrix</strong>：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) </li></ul><p>架构图：</p><p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525575656796.png" alt="1525575656796"></p><p>以上只是其中一部分。</p><h2 id="3-2-版本"><a href="#3-2-版本" class="headerlink" title="3.2 版本"></a>3.2 版本</h2><p>版本是版本名+版本号 （如Angel.SR6）。  </p><p>​    版本名：是伦敦的地铁名  </p><p>​    版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 </p><p>所以 Edgware.SR3就是Edgware的第3个Release版本。  </p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528263985902.png" alt="1528263985902" style="zoom:67%;"><p>项目中会是以Finchley的版本。</p><p>其中包含的组件，也都有各自的版本，如下表：</p><table><thead><tr><th>Component</th><th>Edgware.SR3</th><th>Finchley.RC1</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR3</td><td>Elmhurst.RELEASE</td><td>Elmhurst.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.10.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.RELEASE</td></tr><tr><td>spring-cloud-vault</td><td>1.1.0.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr></tbody></table><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528263942152.png" alt="1528263942152"></p><p>接下来学习SpringCloud中的重要组件。</p><h1 id="4-微服务场景模拟"><a href="#4-微服务场景模拟" class="headerlink" title="4. 微服务场景模拟"></a>4. 微服务场景模拟</h1><p>首先，我们需要模拟一个服务调用的场景，搭建两个工程：<code>itcast-service-provider</code>（服务提供方）和<code>itcast-service-consumer</code>（服务调用方）。</p><p>​        服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并<strong>对外提供rest接口服务</strong>。</p><p>​        服务消费方：使用restTemplate<strong>远程调用服务提供方的rest接口服务</strong>，<strong>获取数据</strong>。</p><h2 id="4-1-服务提供者"><a href="#4-1-服务提供者" class="headerlink" title="4.1 服务提供者"></a>4.1 服务提供者</h2><p>我们新建一个项目：itcast-service-provider，对外提供根据id查询用户的服务。</p><h3 id="4-1-1-Spring脚手架创建工程"><a href="#4-1-1-Spring脚手架创建工程" class="headerlink" title="4.1.1 Spring脚手架创建工程"></a>4.1.1 Spring脚手架创建工程</h3><p>借助于Spring提供的快速搭建工具：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528266515225.png" alt="1528266515225" style="zoom: 50%;"><p>next–&gt;填写项目信息：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528266803455.png" alt="1528266803455" style="zoom:50%;"><p>next –&gt;  添加web依赖：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528266923967.png" alt="1528266923967" style="zoom:50%;"><p>添加mybatis依赖：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528267588935.png" alt="1528267588935" style="zoom:50%;"><p>Next –&gt;  填写项目位置：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528267665004.png" alt="1528267665004" style="zoom:50%;"><p>生成的项目结构，已经包含了引导类（itcastServiceProviderApplication）：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528267830854.png" alt="1528267830854" style="zoom:50%;"><p>依赖也已经全部自动引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 需要手动引入通用mapper的启动器，spring没有收录该依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为要使用通用mapper，<strong>需要手动加一条依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-编写代码"><a href="#4-1-2-编写代码" class="headerlink" title="4.1.2 编写代码"></a>4.1.2 编写代码</h3> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1535671376231.png" alt="1535671376231" style="zoom:67%;"><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>属性文件,这里我们采用了yaml语法，而不是properties：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis</span> <span class="comment">#你学习mybatis时，使用的数据库地址</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.itcast.service.pojo</span></span><br></pre></td></tr></table></figure><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别，1男性，2女性</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出生日期</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updated;</span><br><span class="line"></span><br><span class="line">    ...省略get和set方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UserMapper"><a href="#UserMapper" class="headerlink" title="UserMapper"></a>UserMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">tk</span>.<span class="title">mybatis</span>.<span class="title">mapper</span>.<span class="title">common</span>.<span class="title">Mapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UserController"><a href="#UserController" class="headerlink" title="UserController"></a>UserController</h4><p>添加一个对外查询的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，需要在启动类中添加 <code>@MapperScan(&quot;cn.itcast.service.mapper&quot;)</code>    //Mapper接口的包扫描  </p><p>加了后UserMapper上就不用加@Mapper了</p><h3 id="4-1-3-启动并测试"><a href="#4-1-3-启动并测试" class="headerlink" title="4.1.3 启动并测试"></a>4.1.3 启动并测试</h3><p>启动项目，访问接口：<a href="http://localhost:8081/user/1">http://localhost:8081/user/1</a></p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528272537927.png" alt="1528272537927" style="zoom:67%;"><h2 id="4-2-服务消费者"><a href="#4-2-服务消费者" class="headerlink" title="4.2 服务消费者"></a>4.2 服务消费者</h2><p>搭建<code>itcast-service-consumer</code>服务消费方工程。</p><h3 id="4-2-1-创建工程"><a href="#4-2-1-创建工程" class="headerlink" title="4.2.1 创建工程"></a>4.2.1 创建工程</h3><p>与上面类似，这里不再赘述，需要注意的是，我们调用itcast-service-provider的解耦获取数据，因此不需要mybatis相关依赖了。</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528272829384.png" alt="1528272829384" style="zoom:67%;"><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528272875502.png" alt="1528272875502" style="zoom:67%;"><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528273029361.png" alt="1528273029361" style="zoom:67%;"><p>pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-2-编写代码"><a href="#4-2-2-编写代码" class="headerlink" title="4.2.2 编写代码"></a>4.2.2 编写代码</h3> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1540643087305.png" alt="1540643087305" style="zoom:67%;"><p>首先在<strong>引导类</strong>中注册<code>RestTemplate</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写配置（application.yml）：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>编写UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;consumer/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;http://localhost:8081/user/&quot;</span> + id, User.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pojo对象（User）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别，1男性，2女性</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出生日期</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updated;</span><br><span class="line"></span><br><span class="line">    ...set和get方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-启动测试"><a href="#4-2-3-启动测试" class="headerlink" title="4.2.3 启动测试"></a>4.2.3 启动测试</h3><p>因为我们没有配置端口，那么默认就是8080，我们访问：<a href="http://localhost/consumer/user?id=1">http://localhost/consumer/user?id=1</a></p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1535587919022.png" alt="1535587919022" style="zoom:67%;"><h2 id="4-3-问题"><a href="#4-3-问题" class="headerlink" title="4.3 问题?"></a>4.3 问题?</h2><p>刚才的工程包含：</p><ul><li>itcast-service-provider：一个提供根据id查询用户的微服务。</li><li>itcast-service-consumer：一个服务调用者，通过RestTemplate远程调用itcast-service-provider。</li></ul><p>存在什么问题？</p><ul><li>在consumer中把url地址硬编码到了代码中，不方便后期维护</li><li>consumer需要记忆provider的地址，如果出现变更，可能得不到通知，地址将失效</li><li>consumer不清楚provider的状态，服务宕机也不知道</li><li>provider只有1台服务，不具备高可用性</li><li>即便provider形成集群，consumer还需自己实现负载均衡</li></ul><p>其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p><ul><li>服务管理<ul><li>如何自动注册和发现</li><li>如何实现状态监管</li><li>如何实现动态路由</li></ul></li><li>服务如何实现负载均衡</li><li>服务如何解决容灾问题</li><li>服务如何实现统一配置</li></ul><p>以上的问题SpringCloud都能解决。</p><h1 id="5-Eureka注册中心"><a href="#5-Eureka注册中心" class="headerlink" title="5.Eureka注册中心"></a>5.Eureka注册中心</h1><h2 id="5-1-认识Eureka"><a href="#5-1-认识Eureka" class="headerlink" title="5.1.认识Eureka"></a>5.1.认识Eureka</h2><p>​        解决第一问题，服务的管理。</p><blockquote><p>问题分析</p></blockquote><p>​        在刚才的案例中，itcast-service-provider对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。</p><p>​        当一个项目拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。</p><blockquote><p>Eureka做什么？</p></blockquote><p>​        Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。</p><p>​        同时，服务提供方与Eureka之间通过<code>“心跳”</code>机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。</p><p>这就实现了服务的<strong>自动注册、发现、状态监控</strong>。</p><h2 id="5-2-原理图"><a href="#5-2-原理图" class="headerlink" title="5.2.原理图"></a>5.2.原理图</h2><blockquote><p>基本架构：</p></blockquote><p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525597885059.png" alt="1525597885059"></p><ul><li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li><li>提供者：启动后<strong>向Eureka注册</strong>自己信息（地址，提供什么服务）</li><li>消费者：<strong>向Eureka订阅服务</strong>，Eureka会<strong>将对应服务的所有提供者地址列表发送给消费者</strong>，并且定期更新</li><li>心跳(续约)：<strong>提供者定期</strong>通过http方式向Eureka<strong>刷新自己的状态</strong></li></ul><h2 id="5-3-案例"><a href="#5-3-案例" class="headerlink" title="5.3 案例"></a>5.3 案例</h2><h3 id="5-3-1-搭建EurekaServer"><a href="#5-3-1-搭建EurekaServer" class="headerlink" title="5.3.1 搭建EurekaServer"></a>5.3.1 搭建EurekaServer</h3><p>接下来我们创建一个项目，启动一个EurekaServer：</p><p>依然使用spring提供的快速搭建工具：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528295484808.png" alt="1528295484808" style="zoom:50%;"><p>选择依赖：EurekaServer-服务注册中心依赖，Eureka Discovery-服务提供方和服务消费方。</p><ul><li>因为，<strong>对于eureka来说：服务提供方和服务消费方都属于客户端</strong></li></ul><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528295612501.png" alt="1528295612501" style="zoom:67%;"><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528295690203.png" alt="1528295690203" style="zoom:67%;"><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.eureka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RC2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示，将来作为微服务名称注入到eureka容器</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span></span><br><span class="line">                 <span class="comment"># 忘记写时可以点击这个文件中的属性进去类中查看。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure><h4 id="引导类添加-EnableEurekaServer"><a href="#引导类添加-EnableEurekaServer" class="headerlink" title="引导类添加@EnableEurekaServer"></a>引导类添加@EnableEurekaServer</h4><p>修改<strong>引导类</strong>，在类上添加@EnableEurekaServer注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 声明当前springboot应用是一个eureka服务中心，启用eureka服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastEurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastEurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务，并访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525604959508.png" alt="1525604959508" style="zoom:67%;"><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1533793804268.png" alt="1533793804268" style="zoom:67%;"><h3 id="5-3-2-注册到Eureka"><a href="#5-3-2-注册到Eureka" class="headerlink" title="5.3.2 注册到Eureka"></a>5.3.2 注册到Eureka</h3><p>注册服务，就是<strong>在服务上添加Eureka的客户端依赖</strong>，客户端代码会<strong>自动把服务注册到EurekaServer中</strong>。</p><p>修改<code>itcast-service-provider</code>工程</p><ol><li>在<code>pom.xml</code>中，添加<code>springcloud</code>的相关依赖。</li><li>在<code>application.yml</code>中，添加springcloud的相关依赖。</li><li>在引导类上添加注解，把服务注入到eureka注册中心。</li></ol><p>具体操作</p><h4 id="pom-xml-1"><a href="#pom-xml-1" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>参照itcast-eureka，先添加SpringCloud依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是Eureka客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/heima</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-provider</span> <span class="comment"># 应用名称，注册到eureka后的服务名称,将来会作为微服务的名称</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.itcast.service.pojo</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这里我们添加了<strong>spring.application.name属性来指定应用名称</strong>，将来会作为应用的id使用。</li></ul><h4 id="引导类添加-EnableDiscoveryClient"><a href="#引导类添加-EnableDiscoveryClient" class="headerlink" title="引导类添加@EnableDiscoveryClient"></a>引导类添加@EnableDiscoveryClient</h4><p>在引导类上开启Eureka客户端功能</p><p>通过<strong>添加<code>@EnableDiscoveryClient</code>来开启Eureka客户端功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//启用eureka客户端，也可以用@EnableEurekaClient,一般不用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重启项目，访问<a href="http://127.0.0.1:10086/">Eureka监控页面</a>查看</p></blockquote><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1545178177947.png" alt="1545178177947" style="zoom:67%;"><p>service-provider服务已经注册成功了</p><h3 id="5-3-3-从Eureka获取服务"><a href="#5-3-3-从Eureka获取服务" class="headerlink" title="5.3.3 从Eureka获取服务"></a>5.3.3 从Eureka获取服务</h3><p>接下来我们修改**<code>itcast-service-consumer</code><strong>，尝试从</strong>EurekaServer获取服务**。</p><p>方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！</p><h4 id="pom-xml-2"><a href="#pom-xml-2" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="application-yml-2"><a href="#application-yml-2" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:10086/eureka</span></span><br></pre></td></tr></table></figure><h4 id="在启动类开启Eureka客户端"><a href="#在启动类开启Eureka客户端" class="headerlink" title="在启动类开启Eureka客户端"></a>在启动类开启Eureka客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启Eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时已经注册成功。</p><h4 id="UserController-1"><a href="#UserController-1" class="headerlink" title="UserController"></a>UserController</h4><p>​        修改UserController代码，用DiscoveryClient类的方法，<strong>根据服务名称，获取服务实例</strong>，下面的示例<strong>能解决硬编码的问题</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;consumer/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient; <span class="comment">// eureka客户端，可以获取到eureka中服务的信息</span></span><br><span class="line">                                             <span class="comment">//包含了拉取的所有服务信息。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;service-provider&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为只有一个Service-provider。所以获取第一个实例</span></span><br><span class="line">        ServiceInstance instance = instances.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取ip和端口信息，拼接成服务地址</span></span><br><span class="line">        String baseUrl = <span class="string">&quot;http://&quot;</span> + instance.getHost() + <span class="string">&quot;:&quot;</span> + instance.getPort() + <span class="string">&quot;/user/&quot;</span> + id;</span><br><span class="line">        User user = <span class="keyword">this</span>.restTemplate.getForObject(baseUrl, User.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Debug跟踪运行：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528534110188.png" alt="1528534110188" style="zoom:67%;"><p>生成的URL：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528534148651.png" alt="1528534148651" style="zoom:67%;"><p>访问结果：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1535674665806.png" alt="1535674665806" style="zoom:67%;"><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/image-20200715211910236.png" style="zoom: 67%;"><h2 id="5-4-Eureka详解"><a href="#5-4-Eureka详解" class="headerlink" title="5.4 Eureka详解"></a>5.4 Eureka详解</h2><p>详解Eureka的原理及配置。</p><h3 id="5-4-1-基础架构"><a href="#5-4-1-基础架构" class="headerlink" title="5.4.1 基础架构"></a>5.4.1 基础架构</h3><p>Eureka架构中的三个核心角色：</p><ul><li><p><strong>服务注册中心</strong></p><p>Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的<strong>itcast-eureka</strong>。</p></li><li><p><strong>服务提供者</strong></p><p><strong>提供服务的应用</strong>，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是<strong>Rest风格服务</strong>即可。本例中就是我们实现的<strong>itcast-service-provider</strong>。</p></li><li><p><strong>服务消费者</strong></p><p>消费应用<strong>从注册中心获取服务列表</strong>，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的<strong>itcast-service-consumer</strong>。</p></li></ul><h3 id="5-4-2-高可用的Eureka-Server模拟"><a href="#5-4-2-高可用的Eureka-Server模拟" class="headerlink" title="5.4.2 高可用的Eureka Server模拟"></a>5.4.2 高可用的Eureka Server模拟</h3><p>​        Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个<strong>集群</strong>，形成高可用的Eureka中心。</p><blockquote><p>服务同步</p></blockquote><p>​        多个Eureka Server之间也会<strong>互相注册为服务</strong>，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把<strong>服务的信息同步给集群中的每个节点</strong>，从而实现<strong>数据同步</strong>。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。因此相互注册只要注册一个就可以了，会进行同步。</p><blockquote><p>动手搭建高可用的EurekaServer</p></blockquote><p>​        我们假设要运行两个EurekaServer的集群，端口分别为：10086和10087。只需要<strong>把itcast-eureka启动两次</strong>即可。</p><h4 id="第一个eurekaServer"><a href="#第一个eurekaServer" class="headerlink" title="第一个eurekaServer"></a>第一个eurekaServer</h4><p>1）启动第一个eurekaServer，我们修改原来的EurekaServer配置，以下就是10086注册给10087：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10087/eureka</span></span><br></pre></td></tr></table></figure><p>所谓的高可用注册中心，其实就是<strong>把EurekaServer自己也作为一个服务进行注册</strong>，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：</p><ul><li>把service-url的值改成了另外一台EurekaServer的地址，而不是自己</li></ul><p>启动报错，很正常。因为10087服务没有启动：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528691515859.png" alt="1528691515859" style="zoom:67%;"><h4 id="第二个eurekaServer"><a href="#第二个eurekaServer" class="headerlink" title="第二个eurekaServer"></a>第二个eurekaServer</h4><p>2）启动第二个eurekaServer，再次修改itcast-eureka的配置（另一个已经部署，不会影响运行）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10087</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 配置其他Eureka服务的地址，而不是自己，比如10086</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：(也可以在<strong>Run Dashboard中右键启动器–Copy Configuration</strong>)</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528540668018.png" alt="1528540668018" style="zoom:67%;"><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528691728618.png" alt="1528691728618" style="zoom: 67%;"><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528693484031.png" alt="1528693484031" style="zoom:67%;"><p>然后启动即可。</p><h4 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h4><p>3）访问集群，测试：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528693648200.png" alt="1528693648200" style="zoom: 50%;"><h4 id="客户端注册服务到集群"><a href="#客户端注册服务到集群" class="headerlink" title="客户端注册服务到集群"></a>客户端注册服务到集群</h4><p>4）<strong>客户端注册服务到集群</strong></p><p>因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址,多个地址以&#x27;,&#x27;隔开</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></span><br></pre></td></tr></table></figure><p>10086：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528693943950.png" alt="1528693943950" style="zoom:50%;"><p>10087：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528693979654.png" alt="1528693979654" style="zoom:50%;"><h3 id="5-4-3-服务提供者"><a href="#5-4-3-服务提供者" class="headerlink" title="5.4.3 服务提供者"></a>5.4.3 服务提供者</h3><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p><h4 id="服务注册细节"><a href="#服务注册细节" class="headerlink" title="服务注册细节"></a>服务注册细节</h4><blockquote><p>服务注册</p></blockquote><p>​        <strong>服务提供者</strong>在启动时，会检测<strong>配置属性中的：<code>eureka.client.register-with-eureka=true</code>参数是否正确</strong>，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个<strong>Rest请求，并携带自己的元数据信息</strong>，Eureka Server会把这些信息保存到一个<strong>双层Map结构中</strong>。</p><p>​        也就是说若该属性设置为false则不会注册到EurekaServer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;serviceId, Map&lt;服务示例名， 实例对象 (instance)&gt; &gt;</span><br></pre></td></tr></table></figure><ul><li>第一层Map的Key就是<strong>服务id</strong>，一般是<strong>配置中的<code>spring.application.name</code>属性</strong></li><li>第二层Map的key是<strong>服务的实例id</strong>。一般<strong>host+ serviceId + port</strong>，例如：<code>locahost:service-provider:8081</code></li><li>值则是<strong>服务的实例对象</strong>，也就是说<strong>一个服务，可以同时启动多个不同实例，形成集群</strong>。</li></ul><h4 id="服务续约配置心跳"><a href="#服务续约配置心跳" class="headerlink" title="服务续约配置心跳)"></a>服务续约配置心跳)</h4><blockquote><p>服务续约</p></blockquote><p>在注册服务完成以后，<strong>服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求）</strong>，告诉EurekaServer：“我还活着”。这个我们称为 <code>服务的续约（renew）</code> ；</p><p>有两个重要参数可以修改服务续约的行为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><ul><li>lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒</li><li>lease-expiration-duration-in-seconds：服务失效时间，默认值90秒</li></ul><p>也就是说，默认情况下<strong>每个30秒服务会向注册中心发送一次心跳</strong>，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除（应该是失效？），这两个值在生产环境不要修改，默认即可。</p><p>​        开发时经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span> <span class="comment"># 10秒即过期</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 5秒一次心跳</span></span><br></pre></td></tr></table></figure><h3 id="5-4-4-服务消费者"><a href="#5-4-4-服务消费者" class="headerlink" title="5.4.4 服务消费者"></a>5.4.4 服务消费者</h3><h4 id="获取服务列表配置"><a href="#获取服务列表配置" class="headerlink" title="获取服务列表配置"></a>获取服务列表配置</h4><blockquote><p>获取服务列表</p></blockquote><p>​        当服务消费者启动时，会<strong>检测<code>eureka.client.fetch-registry=true</code>参数的值</strong>，如果为true，则会拉取Eureka Server服务的列表<strong>只读备份，然后缓存在本地</strong>。并且<code>每隔30秒</code>会重新获取并更新数据。</p><p>​        若该参数为false则不会拉取Eureka Server服务的列表。</p><p>我们可以通过下面的参数来修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>生产环境中，我们不需要修改这个值。</p><p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p><h3 id="5-4-5-失效剔除和自我保护"><a href="#5-4-5-失效剔除和自我保护" class="headerlink" title="5.4.5 失效剔除和自我保护"></a>5.4.5 失效剔除和自我保护</h3><h4 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h4><blockquote><p>服务下线</p></blockquote><p>​        当服务进行正常关闭操作时，它会触发一个<strong>服务下线的REST请求给Eureka Server</strong>，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。</p><h4 id="服务提供方的失效剔除配置"><a href="#服务提供方的失效剔除配置" class="headerlink" title="服务提供方的失效剔除配置"></a>服务提供方的失效剔除配置</h4><blockquote><p>失效剔除</p></blockquote><p>​        有些时候，我们的<strong>服务提供方</strong>并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个<strong>定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除</strong>。（可以理解成之前的失效但是没有剔除，这里进行剔除）</p><p>​        可以<strong>通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒</strong>，生产环境不要修改。</p><p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528696142799.png" alt="1528696142799" style="zoom:67%;"><h4 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h4><blockquote><p>自我保护</p></blockquote><p>​        我们关停一个服务，就会在Eureka面板看到一条警告：</p><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525618396076.png" alt="1525618396076"></p><p>​        这是触发了Eureka的自我保护机制。当一个服务<strong>未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%**。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会</strong>把当前实例的注册信息保护起来，不予剔除**。生产环境下这很有效，保证了大多数服务依然可用。</p><p>​        但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（itcast-eureka）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护模式（缺省为打开）</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 扫描失效服务的间隔时间（缺省为60*1000ms）</span></span><br></pre></td></tr></table></figure><h3 id="失效剔除与续约失效时间的区别"><a href="#失效剔除与续约失效时间的区别" class="headerlink" title="失效剔除与续约失效时间的区别"></a>失效剔除与续约失效时间的区别</h3><p>同一个服务部署了多个实例，在通过网关调用时会随机调用其中一个。但是，当某个服务挂掉之后，依然在注册中心中，依然会随机被调用到，调用时便会超时报错。</p><ul><li>也就是说，续约失效时间是指客户端最后一次续约后，经过默认的90秒后失效。</li><li>而失效剔除则是对失效的服务进行剔除（默认60秒）</li></ul><p>注册中心的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册中心的配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment"># 过期时间，默认90s, 可不配置</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br><span class="line">    <span class="comment"># 续约时间，默认30s，可不配置</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="comment"># ip地址优先</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment"># 关闭注册中心自我保护模式，避免注册中心不移除失效的服务，默认为true</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 去除失效服务的时间间隔（毫秒），默认是60s</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 启用eureka客户端，默认为true, 可不配置</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 取注册信息，默认为true，可不配置</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 两个心跳参数，默认都是30s,可不配置</span></span><br><span class="line">    <span class="attr">instance-info-replication-interval-seconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="comment"># 注册到注册中心，默认为true,可不配置</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>业务微服务配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#业务微服务配置示例</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#以IP地址注册到服务中心</span></span><br><span class="line">        <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="comment">#eureka实例id</span></span><br><span class="line">        <span class="attr">ip-address:</span> <span class="number">192.168</span><span class="number">.217</span><span class="number">.211</span></span><br><span class="line">        <span class="comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒（客户端告诉服务端自己会按照该规则），默认30</span></span><br><span class="line">        <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#Eureka服务端在收到最后一次心跳之后等待的时间上限，单位为秒，超过则剔除（客户端告诉服务端按照此规则等待自己），默认90</span></span><br><span class="line">        <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">service-url:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span> <span class="comment">#微服务</span></span><br></pre></td></tr></table></figure><ul><li>Eureka Server提供服务发现的能力，各个微服务启动时，会向Eureke Server注册自己的信息（如IP、端口、微服务名称等），Eureka  Server会存储这些信息。</li><li>Eureka Client是一个Java客户端，用于简化与Eureke Server的交互（启动时会向Eureke Server注册自己的信息）</li><li>微服务启动后renew，会周期性（默认30秒）向Eureke Server发送心跳以续约自己的“租期”</li><li>若Eureke Server一定时间内没有接收到某个微服务实例的心跳（最后一次续约时间开始计算），Eureke Server将会注销该实例（默认90秒）</li><li>默认情况下，Eureke Server同时也是Eureke Client。多个Eureke Server实例互相之间通过增量复制的方式来实现服务注册表中数据的同步。Eureke Server默认保证在90秒内，Eureke Server集群内的所有实例中的数据达到一致。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span>架构的演变</span><br><span class="line">    传统架构--&gt;水平拆分--&gt;垂直拆分（最早的分布式）--&gt;soa(dubbo)--&gt;微服务(springCloud)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>远程调用技术：rpc http</span><br><span class="line">    rpc协议：自定义数据格式，限定技术，传输速度快，效率高 tcp，dubbo</span><br><span class="line">    http协议：统一的数据格式，不限定技术 rest接口  tcp协议 springCloud</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>什么是springCloud</span><br><span class="line">    微服务架构的解决方案，是很多组件的集合</span><br><span class="line">    eureka：注册中心，服务的注册与发现</span><br><span class="line">    zull：网关协议，路由请求，过滤器（ribbon hystrix）</span><br><span class="line">    ribbon：负载均衡组件</span><br><span class="line">    hystrix：熔断组件</span><br><span class="line">    feign：远程调用组件(ribbon hystrix)</span><br><span class="line"></span><br><span class="line">*<span class="number">4.</span>eureka</span><br><span class="line">    注册中心：itcast-eureka</span><br><span class="line">    （<span class="number">1.</span>引入启动器， </span><br><span class="line">      <span class="number">2.</span>配置spring.application.name=itcast-eureka </span><br><span class="line">      <span class="number">3.</span>在引导类上<span class="meta">@EnableEurekaServer</span>）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    客户端：itcast-service-provider itcast-service-consumer</span><br><span class="line">    （<span class="number">1.</span>引入启动器 </span><br><span class="line">      <span class="number">2.</span>配置spring.application.name eureka.client.service-url.defaultZone=http:<span class="comment">//localhost:10086/eureka           3.在引导类上@EnableDiscoveryClient(启用eureka客户端)）</span></span><br><span class="line">      itcast-service-consumer能通过注入的DiscoveryClient获取服务信息</span><br></pre></td></tr></table></figure><h1 id="6-负载均衡Ribbon"><a href="#6-负载均衡Ribbon" class="headerlink" title="6.负载均衡Ribbon"></a>6.负载均衡Ribbon</h1><p>​        在刚才的案例中，我们启动了一个<code>itcast-service-provider</code>，然后<strong>通过<code>DiscoveryClient</code>来获取服务实例信息</strong>，然后获取<code>ip</code>和<code>端口</code>来访问。但实际环境中，我们往往会开启很多个<strong>itcast-service-provider的集群</strong>。此时我们获取的<strong>服务列表中就会有多个</strong>，到底该访问哪一个呢？</p><p>​        一般这种情况下我们就需要编写负载均衡算法，在<strong>多个实例列表中进行选择</strong>。</p><p>​        不过Eureka中已经帮我们集成了<strong>负载均衡组件：Ribbon</strong>，简单修改代码即可使用。</p><p>什么是Ribbon：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525619257397.png" alt="1525619257397" style="zoom:67%;"><p>接下来，我们就来使用Ribbon实现负载均衡。</p><h2 id="6-1-启动两个服务实例"><a href="#6-1-启动两个服务实例" class="headerlink" title="6.1 启动两个服务实例"></a>6.1 启动两个服务实例</h2><p>首先参照itcast-eureka启动<strong>两个ItcastService<code>Provider</code>Application实例</strong>，一个8081，一个8082。</p><p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1540644966386.png" alt="1540644966386"></p><p>Eureka监控面板：</p><p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1540645032363.png" alt="1540645032363"></p><h2 id="6-2-消费方开启负载均衡"><a href="#6-2-消费方开启负载均衡" class="headerlink" title="6.2 消费方开启负载均衡"></a>6.2 消费方开启负载均衡</h2><p>因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖，直接修改代码。</p><p>修改**<code>itcast-service-consumer</code> 的引导类<strong>，在RestTemplate的配置方法上</strong>添加<code>@LoadBalanced</code>注解**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span>   <span class="comment">//开启负载均衡</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改调用方式，<strong>不再手动获取ip和端口，而是直接通过服务名称调用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;consumer/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private DiscoveryClient discoveryClient; // 注入discoveryClient，通过该客户端获取服务列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 通过client获取服务提供方的服务列表，这里我们只有一个</span></span><br><span class="line">        <span class="comment">// ServiceInstance instance = discoveryClient.getInstances(&quot;service-provider&quot;).get(0);</span></span><br><span class="line">        String baseUrl = <span class="string">&quot;http://service-provider/user/&quot;</span> + id;</span><br><span class="line">        User user = <span class="keyword">this</span>.restTemplate.getForObject(baseUrl, User.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问页面，查看结果：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1535674665806.png" alt="1535674665806" style="zoom:67%;"><h2 id="6-3-源码跟踪"><a href="#6-3-源码跟踪" class="headerlink" title="6.3 源码跟踪"></a>6.3 源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人<strong>帮我们根据service名称，获取到了服务实例的ip和端口</strong>。它就是<code>LoadBalancerInterceptor</code></p><p>在如下代码打断点：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528774637934.png" alt="1528774637934" style="zoom:67%;"><p>一路源码跟踪：<strong>RestTemplate.getForObject –&gt; RestTemplate.execute –&gt; RestTemplate.doExecute</strong>：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528776129378.png" alt="1528776129378" style="zoom:67%;"><p>点击进入<strong>AbstractClientHttpRequest.execute –&gt; AbstractBufferingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.execute</strong>:</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528776489965.png" alt="1528776489965" style="zoom:67%;"><p>继续跟入：<strong>LoadBalancerInterceptor.intercept方法</strong></p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528775270103.png" alt="1528775270103" style="zoom:67%;"><p>继续跟入execute方法：发现获取了8082端口的服务</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528775890956.png" alt="1528775890956" style="zoom:67%;"><p>再跟下一次，发现获取的是8081：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528775845812.png" alt="1528775845812" style="zoom:67%;"><h2 id="6-4-负载均衡策略"><a href="#6-4-负载均衡策略" class="headerlink" title="6.4 负载均衡策略"></a>6.4 负载均衡策略</h2><p>Ribbon默认的负载均衡策略是<strong>简单的轮询</strong>，可以测试一下：</p><p>​        编写测试类，在刚才的源码中我们看到拦截中是使用 <code>RibbonLoadBalanceClient</code> 来进行负载均衡的，其中<strong>有一个choose方法</strong>，找到choose方法的接口方法，是这样介绍的：</p><p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525622320277.png" alt="1525622320277"></p><p>现在这个就是负载均衡获取实例的方法。</p><p>我们注入这个类的对象，然后对其测试：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528780835917.png" alt="1528780835917" style="zoom: 67%;"><p>测试内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = ItcastServiceConsumerApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalanceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RibbonLoadBalancerClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            ServiceInstance instance = <span class="keyword">this</span>.client.choose(<span class="string">&quot;service-provider&quot;</span>);</span><br><span class="line">            System.out.println(instance.getHost() + <span class="string">&quot;:&quot;</span> +instance.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1535338345659.png" alt="1535338345659" style="zoom:67%;"><p>修改负载均衡的策略:</p><p>​    继续跟踪源码，发现这么一段代码：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525622652849.png" alt="1525622652849" style="zoom:67%;"><p>​        我们看看这个rule是谁：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525622699666.png" alt="1525622699666" style="zoom:67%;"><p>​        这里的**rule默认值是一个<code>RoundRobinRule</code>**，看类的介绍：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525622754316.png" alt="1525622754316" style="zoom:67%;"><p>这不就是轮询的意思嘛。</p><p>我们注意到，这个类其实是实现了接口IRule的，查看一下：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1525622817451.png" alt="1525622817451" style="zoom: 80%;"><p>定义负载均衡的规则接口。</p><p>它有以下实现：</p> <img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528782624098.png" alt="1528782624098" style="zoom:80%;"><p>SpringBoot也帮我们提供了<strong>修改负载均衡规则的配置入口</strong>，在<strong>itcast-service-<code>consumer</code>的application.yml</strong>中添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line"><span class="attr">service-provider:</span>  <span class="comment"># 服务提供方的服务id</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p><strong>格式是：<code>&#123;服务名称&#125;.ribbon.NFLoadBalancerRuleClassName</code>，值就是IRule的实现类</strong>。</p><p>再次测试，发现结果变成了随机：</p><img src="/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/1528782514987.png" alt="1528782514987" style="zoom:67%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;系统架构演变&lt;/li&gt;
&lt;li&gt;服务调用方式(RPC、HTTP、RestTemplate)&lt;/li&gt;
&lt;li&gt;Sprin</summary>
      
    
    
    
    <category term="乐优商城" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"/>
    
    <category term="SpringCloud" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/SpringCloud/"/>
    
    
    <category term="系统架构演变" scheme="https://mrchen229.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/"/>
    
    <category term="RPC_HTTP_RestTemplate" scheme="https://mrchen229.github.io/tags/RPC-HTTP-RestTemplate/"/>
    
    <category term="Springcloud概念" scheme="https://mrchen229.github.io/tags/Springcloud%E6%A6%82%E5%BF%B5/"/>
    
    <category term="搭建Eureka(注册中心_提供_消费)" scheme="https://mrchen229.github.io/tags/%E6%90%AD%E5%BB%BAEureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E6%8F%90%E4%BE%9B-%E6%B6%88%E8%B4%B9/"/>
    
    <category term="Eureka配置(心跳_获取服务列表_失效剔除_自我保护)" scheme="https://mrchen229.github.io/tags/Eureka%E9%85%8D%E7%BD%AE-%E5%BF%83%E8%B7%B3-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8-%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/"/>
    
    <category term="Ribbon配置与负载均衡策略" scheme="https://mrchen229.github.io/tags/Ribbon%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>栈_队列_数组_链表_红黑树_ArrayList_LinkedList_HashSet_LinkedHashSet_可变参数_Collections工具_Comparable_Comparator</title>
    <link href="https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/"/>
    <id>https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/</id>
    <published>2020-08-28T11:58:08.000Z</published>
    <updated>2020-08-28T12:00:01.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li><p>栈、队列、数组、链表、红黑树</p></li><li><p>List集合</p><ul><li>ArrayList</li><li>LinkedList</li></ul></li><li><p>Set集合</p><ul><li>HashSet</li><li>LinkedHashSet</li></ul></li><li><p>可变参数</p></li><li><p>Collections工具类</p></li><li><p>Comparable与Comparator</p></li></ul><h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h1><h2 id="1-1-数据结构有什么用？"><a href="#1-1-数据结构有什么用？" class="headerlink" title="1.1 数据结构有什么用？"></a>1.1 数据结构有什么用？</h2><p>常见的数据结构：堆栈、队列、数组、链表和红黑树，了解它们的特点。</p><h2 id="1-2-常见的数据结构"><a href="#1-2-常见的数据结构" class="headerlink" title="1.2 常见的数据结构"></a>1.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>对元素的存取有如下的特点:</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/%E5%A0%86%E6%A0%88.png"></p></li></ul><p>注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>对元素的存取有如下的特点：</p><ul><li><strong>先进先出</strong>（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/队列图.bmp" style="zoom: 67%;"><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/01_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88&%E9%98%9F%E5%88%97.bmp"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/02_数据结构_数组.bmp"><ul><li><strong>数组</strong>：<strong>Array</strong>，是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。</li></ul><p>对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p></li><li><p>增删元素慢</p><ul><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/数组添加.png" style="zoom: 80%;"></li><li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/数组删除.png" style="zoom:80%;"></li></ul></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/03_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8.bmp"></p><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。</p><p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p></li></ul><p>对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li><p>增加元素：只需要修改连接下个元素的地址即可。</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png"></p></li><li><p>删除元素：只需要修改连接下个元素的地址即可。</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp"></p></li></ul></li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/04_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%A2%E9%BB%91%E6%A0%91.bmp"></p><ul><li><p><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><p>如图：</p></li></ul><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/二叉树.bmp" style="zoom:50%;"><p>​        二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是<strong>一颗二叉查找树</strong>。也就意味着，<strong>树的键值仍然是有序的</strong>。</p><p><strong>红黑树的约束</strong>:</p><ol><li>节点可以是红色的或者黑色的</li></ol><ol start="2"><li>根节点是黑色的</li></ol><ol start="3"><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><p>红黑树的特点:</p><p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p><h1 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2. List集合"></a>2. List集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.List接口 extends Collection接口</span><br><span class="line">List接口的特点:</span><br><span class="line">    <span class="number">1.</span>有序的集合,存储元素和取出元素的顺序是一致的(存储<span class="number">123</span> 取出<span class="number">123</span>)</span><br><span class="line">    <span class="number">2.</span>有索引,包含了一些带索引的方法</span><br><span class="line">    <span class="number">3.</span>允许存储重复的元素</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List接口中带索引的方法(特有)</span><br><span class="line">    - <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span>: 将指定的元素，添加到该集合中的指定位置上。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>:返回集合中指定位置的元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>: 移除列表中指定位置的元素, 返回的是被移除的元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span></span><br><span class="line"><span class="function">注意:</span></span><br><span class="line"><span class="function">    操作索引的时候,一定要防止索引越界异常</span></span><br><span class="line"><span class="function">    IndexOutOfBoundsException:索引越界异常,集合会报</span></span><br><span class="line"><span class="function">    ArrayIndexOutOfBoundsException:数组索引越界异常</span></span><br><span class="line"><span class="function">    StringIndexOutOfBoundsException:字符串索引越界异常</span></span><br></pre></td></tr></table></figure><h2 id="2-1-List接口介绍"><a href="#2-1-List接口介绍" class="headerlink" title="2.1 List接口介绍"></a>2.1 List接口介绍</h2><p>​        <code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，将实现了<code>List</code>接口的对象称为List集合。在List集合中<strong>允许出现重复的元素</strong>，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是<strong>元素有序</strong>，即元素的存入顺序和取出顺序一致。</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h2 id="2-2-List接口中常用方法"><a href="#2-2-List接口中常用方法" class="headerlink" title="2.2 List接口中常用方法"></a>2.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，<strong>添加</strong>到该集合中的指定位置上。</li><li><code>public E get(int index)</code>: 返回集合中<strong>指定位置的元素</strong>。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, <strong>返回的是被移除的元素</strong>。</li><li><code>public E set(int index, E element)</code>: 用指定元素<strong>替换</strong>集合中指定位置的元素, <strong>返回值的更新前的元素</strong>。</li></ul><p>List集合特有的方法都是跟索引相关：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">        list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">        <span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">        System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String set(int index,String s)</span></span><br><span class="line">        <span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">        <span class="comment">// 修改指定位置元素</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还可以使用增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-List的子类"><a href="#3-List的子类" class="headerlink" title="3. List的子类"></a>3. List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是<strong>数组结构</strong>。<strong>元素增删慢，查找快</strong>。</p><h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList集合 implements List接口</span><br><span class="line">LinkedList集合的特点:</span><br><span class="line">    <span class="number">1.</span>底层是一个链表结构:查询慢,增删快</span><br><span class="line">    <span class="number">2.</span>里边包含了大量操作首尾元素的方法</span><br><span class="line">    注意:使用LinkedList集合特有的方法,不能使用多态</span><br><span class="line"></span><br><span class="line">    - <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span>:将元素推入此列表所表示的堆栈。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span>:从此列表所表示的堆栈处弹出一个元素。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：如果列表不包含元素，则返回<span class="keyword">true</span>。</span></span><br></pre></td></tr></table></figure><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>: 将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>: 将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>: 返回此列表的第一个元素。</li><li><code>public E getLast()</code>: 返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>: 移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>: 移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>: 从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>: 将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Set接口"><a href="#4-Set接口" class="headerlink" title="4. Set接口"></a>4. Set接口</h1><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/06_Set%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8E%9F%E7%90%86.bmp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Set接口 extends Collection接口</span><br><span class="line">Set接口的特点:</span><br><span class="line">    <span class="number">1.</span>不允许存储重复的元素</span><br><span class="line">    <span class="number">2.</span>没有索引,没有带索引的方法,也不能使用普通的<span class="keyword">for</span>循环遍历</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashSet集合 implements Set接口</span><br><span class="line">HashSet特点:</span><br><span class="line">     <span class="number">1.</span>不允许存储重复的元素</span><br><span class="line">     <span class="number">2.</span>没有索引,没有带索引的方法,也不能使用普通的<span class="keyword">for</span>循环遍历</span><br><span class="line">     <span class="number">3.</span>是一个无序的集合,存储元素和取出元素的顺序有可能不一致</span><br><span class="line">     <span class="number">4.</span>底层是一个哈希表结构(查询的速度非常的快)</span><br></pre></td></tr></table></figure><p>​        <code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。</p><p>​        与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p>​        <code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>tips: Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="4-1-HashSet集合介绍"><a href="#4-1-HashSet集合介绍" class="headerlink" title="4.1 HashSet集合介绍"></a>4.1 HashSet集合介绍</h2><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/05_HashSet%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89.bmp"></p><p>​        <code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是<strong>不可重复</strong>的，并且<strong>元素都是无序</strong>的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持。</p><p>​        <code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。</p><p>保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>使用Set集合存储:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> String(<span class="string">&quot;cba&quot;</span>));</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bac&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;cba&quot;</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，说明集合中不能存储重复元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure><blockquote><p>tips: 字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="4-2-HashSet集合存储数据的结构（哈希表）"><a href="#4-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="4.2  HashSet集合存储数据的结构（哈希表）"></a>4.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>​        在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/哈希表.png" style="zoom:80%;"><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/哈希流程图.png" style="zoom:80%;"><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">哈希值:是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址)</span><br><span class="line">在Object类有一个方法,可以获取对象的哈希值</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> 返回该对象的哈希码值。</span></span><br><span class="line"><span class="function">hashCode方法的源码:</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">native</span>:代表该方法调用的是本地操作系统的方法</span><br></pre></td></tr></table></figure><h2 id="4-3-HashSet存储自定义类型元素"><a href="#4-3-HashSet存储自定义类型元素" class="headerlink" title="4.3  HashSet存储自定义类型元素"></a>4.3  HashSet存储自定义类型元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet存储自定义类型元素</span><br><span class="line"></span><br><span class="line">set集合报错元素唯一:</span><br><span class="line">    存储的元素(String,Integer,...Student,Person...),必须重写hashCode方法和equals方法</span><br></pre></td></tr></table></figure><p>​        给HashSet中存放自定义类型元素时，<strong>需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</strong></p><p>创建自定义Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭德纲&quot;</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭麒麟&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure><h2 id="4-4-LinkedHashSet"><a href="#4-4-LinkedHashSet" class="headerlink" title="4.4 LinkedHashSet"></a>4.4 LinkedHashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedHashSet集合 extends HashSet集合</span><br><span class="line">LinkedHashSet集合特点:</span><br><span class="line">    底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序</span><br></pre></td></tr></table></figure><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure><h2 id="4-5-可变参数"><a href="#4-5-可变参数" class="headerlink" title="4.5  可变参数"></a>4.5  可变参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可变参数:是JDK1.<span class="number">5</span>之后出现的新特性</span><br><span class="line">使用前提:</span><br><span class="line">    当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数.</span><br><span class="line">使用格式:定义方法时使用</span><br><span class="line">    修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;</span><br><span class="line">可变参数的原理:</span><br><span class="line">    可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数</span><br><span class="line">    传递的参数个数,可以是<span class="number">0</span>个(不传递),<span class="number">1</span>,<span class="number">2.</span>..多个</span><br></pre></td></tr></table></figure><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>其实这个书写完全等价与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。</p><p>​    <strong>…</strong> 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><h1 id="5-Collections工具类"><a href="#5-Collections工具类" class="headerlink" title="5. Collections工具类"></a>5. Collections工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下：</span><br><span class="line">    - <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; c, T... elements)</span>:往集合中添加一些元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span> 打乱顺序:打乱集合顺序。</span></span><br></pre></td></tr></table></figure><h2 id="5-1-常用方法"><a href="#5-1-常用方法" class="headerlink" title="5.1 常用方法"></a>5.1 常用方法</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h2 id="5-2-Comparator比较器"><a href="#5-2-Comparator比较器" class="headerlink" title="5.2 Comparator比较器"></a>5.2 Comparator比较器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span>:将集合中元素按照默认规则排序。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注意:</span></span><br><span class="line"><span class="function">     <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span>使用前提</span></span><br><span class="line"><span class="function">     被排序的集合 里边 存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Comparable接口的排序规则:</span></span><br><span class="line"><span class="function">    自己<span class="params">(<span class="keyword">this</span>)</span>-参数:升序</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list，Comparator&lt;? <span class="keyword">super</span> T&gt; )</span>:将集合中元素按照指定规则排序。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Comparator和Comparable的区别</span></span><br><span class="line"><span class="function">    Comparable:自己<span class="params">(<span class="keyword">this</span>)</span>和别人<span class="params">(参数)</span>比较,自己需要实现Comparable接口,重写比较的规则compareTo方法</span></span><br><span class="line"><span class="function">    Comparator:相当于找一个第三方的裁判,比较两个</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Comparator的排序规则:</span></span><br><span class="line"><span class="function">    o1-o2:升序</span></span><br></pre></td></tr></table></figure><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>​        说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>​        那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要<strong>实现Comparable接口</strong>完成比较的功能，在String类型上如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>​        String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p>​        <code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一, 该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure><h2 id="5-3-简述Comparable和Comparator两个接口的区别。"><a href="#5-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="5.3 简述Comparable和Comparator两个接口的区别。"></a>5.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="5-4-练习Comparable"><a href="#5-4-练习Comparable" class="headerlink" title="5.4  练习Comparable"></a>5.4  练习Comparable</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;rose&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;jack&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;abc&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;ace&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试，代码就OK 了效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;jack&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;abc&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;mark&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;ace&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;rose&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-练习Comparator"><a href="#5-5-练习Comparator" class="headerlink" title="5.5 练习Comparator"></a>5.5 练习Comparator</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor&lt;T&gt; c)方式，自己定义规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure><p>如果想要规则更多一些，可以参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="keyword">int</span> result = o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;栈、队列、数组、链表、红黑树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;List集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Array</summary>
      
    
    
    
    <category term="集合" scheme="https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="栈_队列_数组_链表_红黑树" scheme="https://mrchen229.github.io/tags/%E6%A0%88-%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="ArrayList" scheme="https://mrchen229.github.io/tags/ArrayList/"/>
    
    <category term="LinkedList" scheme="https://mrchen229.github.io/tags/LinkedList/"/>
    
    <category term="HashSet" scheme="https://mrchen229.github.io/tags/HashSet/"/>
    
    <category term="可变参数" scheme="https://mrchen229.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    
    <category term="Collections工具类" scheme="https://mrchen229.github.io/tags/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    <category term="Comparable与Comparator" scheme="https://mrchen229.github.io/tags/Comparable%E4%B8%8EComparator/"/>
    
  </entry>
  
  <entry>
    <title>Collection_Iterator(增强for)_泛型(泛型通配符)</title>
    <link href="https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/"/>
    <id>https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/</id>
    <published>2020-08-28T06:51:08.000Z</published>
    <updated>2020-08-28T07:16:29.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>Collection集合</li><li>Iterator迭代器<ul><li>增强for</li></ul></li><li>泛型<ul><li>泛型类、方法、接口</li><li>泛型通配符(只能使用Object类中的共性方法)</li></ul></li></ul><h1 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1. Collection集合"></a>1. Collection集合</h1><h2 id="共性的方法"><a href="#共性的方法" class="headerlink" title="共性的方法"></a>共性的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collection接口</span><br><span class="line">    所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法</span><br><span class="line">    任意的单列集合都可以使用Collection接口中的方法</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">共性的方法:</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>：  把给定的对象添加到当前集合中 。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> :清空集合中所有的元素。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span>: 把给定的对象在当前集合中删除。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span>: 判断当前集合中是否包含给定的对象。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>: 判断当前集合是否为空。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>: 返回集合中元素的个数。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span>: 把集合中的元素，存储到数组中。</span></span><br></pre></td></tr></table></figure><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。<strong>集合的长度是可变的</strong>。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且<strong>对象的类型可以不一致</strong>。一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是<strong>单列集合</strong><code>java.util.Collection</code>和<strong>双列集合</strong><code>java.util.Map</code>。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别**是<code>java.util.List</code>和<code>java.util.Set</code>**。<ul><li>其中，<code>List</code>的特点是<strong>元素有序、元素可重复</strong>。</li><li><code>Set</code>的特点是<strong>元素无序，而且不可重复</strong>。</li><li><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code></li><li><code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul></li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/01_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.bmp"></p><p>​        集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="1-3-Collection-常用方法"><a href="#1-3-Collection-常用方法" class="headerlink" title="1.3 Collection 常用方法"></a>1.3 Collection 常用方法</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了<strong>单列集合(List和Set)通用的一些方法</strong>，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象<strong>添加</strong>到当前集合中 。</li><li><code>public void clear()</code> : <strong>清空</strong>集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中<strong>删除</strong>。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中<strong>是否包含</strong>给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合<strong>是否为空</strong>。</li><li><code>public int size()</code>: 返回集合中<strong>元素的个数</strong>。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，<strong>存储到数组</strong>中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合对象 </span></span><br><span class="line">        <span class="comment">// 使用多态形式</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 使用方法</span></span><br><span class="line">        <span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">        Object[] objects = coll.toArray();</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            System.out.println(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// void  clear() 清空集合</span></span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line">        <span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">        System.out.println(coll.isEmpty());      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h1 id="2-Iterator迭代器"><a href="#2-Iterator迭代器" class="headerlink" title="2. Iterator迭代器"></a>2. Iterator迭代器</h1><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.Iterator接口:迭代器(对集合进行遍历)</span><br><span class="line">有两个常用的方法</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> 如果仍有元素可以迭代，则返回 <span class="keyword">true</span>。</span></span><br><span class="line"><span class="function">        判断集合中还有没有下一个元素,有就返回<span class="keyword">true</span>,没有就返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function">    E <span class="title">next</span><span class="params">()</span> 返回迭代的下一个元素。</span></span><br><span class="line"><span class="function">        取出集合中的下一个元素</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象,获取实现类的方式比较特殊</span><br><span class="line">Collection接口中有一个方法,叫iterator(),这个方法返回的就是迭代器的实现类对象</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> 返回在此 collection 的元素上进行迭代的迭代器。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">迭代器的使用步骤(重点):</span><br><span class="line">    <span class="number">1.</span>使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态)</span><br><span class="line">    <span class="number">2.</span>使用Iterator接口中的方法hasNext判断还有没有下一个元素</span><br><span class="line">    <span class="number">3.</span>使用Iterator接口中的方法next取出集合中的下一个元素</span><br></pre></td></tr></table></figure><p>​        在程序开发中，经常需要<strong>遍历集合中的所有元素</strong>。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。</p><p>​        <code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而**<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素**，因此<code>Iterator</code>对象也被称为迭代器。</p><h3 id="获取迭代器的方法"><a href="#获取迭代器的方法" class="headerlink" title="获取迭代器的方法"></a>获取迭代器的方法</h3><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><blockquote><p><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p></blockquote><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><blockquote><p>当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p></blockquote><p>Iterator迭代器对象在遍历集合时，内部采用<strong>指针的方式来跟踪集合中的元素</strong>，演示Iterator对象迭代元素的过程：</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/02_%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(1).bmp"></p><p>​        在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，<strong>当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回</strong>，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for-foreach"><a href="#2-3-增强for-foreach" class="headerlink" title="2.3 增强for(foreach)"></a>2.3 增强for(foreach)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">增强<span class="keyword">for</span>循环:底层使用的也是迭代器,使用<span class="keyword">for</span>循环的格式,简化了迭代器的书写</span><br><span class="line">是JDK1.<span class="number">5</span>之后出现的新特性</span><br><span class="line"></span><br><span class="line">Collection &lt;E&gt; extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强<span class="keyword">for</span></span><br><span class="line">public interface Iterable&lt;T&gt; 实现这个接口允许对象成为 &quot;foreach&quot; 语句的目标。</span><br><span class="line"></span><br><span class="line">增强<span class="keyword">for</span>循环:用来遍历集合和数组</span><br><span class="line"></span><br><span class="line">格式:</span><br><span class="line">    <span class="keyword">for</span>(集合/数组的数据类型 变量名: 集合名/数组名)&#123;</span><br><span class="line">        sout(变量名);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，<strong>专门用来遍历数组和集合的</strong>。它的<strong>内部原理其实是个Iterator迭代器</strong>，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">      <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</strong></p><h4 id="练习1-遍历数组"><a href="#练习1-遍历数组" class="headerlink" title="练习1: 遍历数组"></a>练习1: 遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">           <span class="comment">//使用增强for遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2: 遍历集合"></a>练习2: 遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h1 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3. 泛型"></a>3. 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><pre><code>    创建集合对象,使用泛型    好处:        1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型        2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错)     弊端:        泛型是什么类型,只能存储什么类型的数据</code></pre><p>在前面学习集合时，我们<strong>都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型</strong>。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p><img src="/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/03_%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5.bmp"></p><p>创建集合对象，不使用泛型</p><p>好处：</p><p>​        集合不使用泛型，默认是Object类型，可以存储任意类型的数据</p><p>弊端：</p><p>​        不安全，会引发异常</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">        Iterator it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">            String str = (String) it.next();</span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。</p><p>为什么会发生类型转换异常呢？  </p><p>​        我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。</p><p>怎么来解决这个问题呢？</p><p>​        Collection虽然可以存储各种对象，但实际上<strong>通常Collection只存储同一类型对象</strong>。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。<strong>当没有指定泛型时，默认类型为Object类型。</strong></p></blockquote><h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li><strong>将运行时期的ClassCastException，转移到了编译时期变成了编译失败</strong>。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">       ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><h4 id="在创建对象的时候确定泛型"><a href="#在创建对象的时候确定泛型" class="headerlink" title="在创建对象的时候确定泛型"></a>在创建对象的时候确定泛型</h4><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">    <span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;         </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();        </span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);         </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重写的next方法泛型默认就是String</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Scanner</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><pre><code>泛型的通配符:    ?:代表任意的数据类型使用方式:    不能创建对象使用    只能作为方法的参数使用</code></pre><p>当使用泛型类或者接口时，<strong>传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示</strong>。</p><ul><li><strong>一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</strong></li></ul><h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时<strong>只能接受数据,不能往该集合中存储数据</strong>。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的。</p></blockquote><h3 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h3><pre><code>泛型的上限限定: ? extends E  代表使用的泛型只能是E类型的子类/本身泛型的下限限定: ? super E    代表使用的泛型只能是E类型的父类/本身</code></pre><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Collection集合&lt;/li&gt;
&lt;li&gt;Iterator迭代器&lt;ul&gt;
&lt;li&gt;增强for&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="集合" scheme="https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Collection集合" scheme="https://mrchen229.github.io/tags/Collection%E9%9B%86%E5%90%88/"/>
    
    <category term="Iterator迭代器" scheme="https://mrchen229.github.io/tags/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="增强for" scheme="https://mrchen229.github.io/tags/%E5%A2%9E%E5%BC%BAfor/"/>
    
    <category term="泛型类_方法_接口" scheme="https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%96%B9%E6%B3%95-%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="泛型通配符" scheme="https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_包装类与拆装箱_基本类型与String转换</title>
    <link href="https://mrchen229.github.io/2020/08/28/03.%E5%B8%B8%E7%94%A8API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E6%8B%86%E8%A3%85%E7%AE%B1_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E8%BD%AC%E6%8D%A2/"/>
    <id>https://mrchen229.github.io/2020/08/28/03.%E5%B8%B8%E7%94%A8API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E6%8B%86%E8%A3%85%E7%AE%B1_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-08-28T05:20:08.000Z</published>
    <updated>2020-08-28T07:15:36.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>Object类<ul><li>Object类的toString方法</li><li>Object类的equals方法</li></ul></li><li>Objects类</li><li>Date类</li><li>DateFormat类(Date与String之间的转换)</li><li>Calendar类（方便获取各个时间属性）</li><li>System类<ul><li>currentTimeMillis方法</li><li>arraycopy方法</li></ul></li><li>StringBuilder类</li><li>包装类与自动拆装箱</li><li>基本类型与字符串之间的转换</li></ul><h1 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1. Object类"></a>1. Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的<strong>根类，即所有类的父类</strong>。它其中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是<strong>对象的类型+@+内存地址值</strong>。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。</p><blockquote><p>tips: 直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><p><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</p><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的<strong>“相同”有默认和自定义两种方式</strong>。</p></li></ul><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>​        如果没有覆盖重写equals方法，那么Object类中<strong>默认进行<code>==</code>运算符的对象地址比较</strong>，只要<strong>不是同一个对象，结果必然为false。</strong></p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>​        如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以<strong>覆盖重写equals方法</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是 <strong><code>null-save</code>（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象</strong>。</p><p>在<strong>比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题</strong>。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>: 判断两个对象是否相等。</li></ul><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-日期时间类"><a href="#2-日期时间类" class="headerlink" title="2. 日期时间类"></a>2. 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：<strong>使用无参构造，可以自动设置当前系统时间的毫秒时刻</strong>；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="getTime-方法（返回毫秒值）"><a href="#getTime-方法（返回毫秒值）" class="headerlink" title="getTime()方法（返回毫秒值）"></a>getTime()方法（返回毫秒值）</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的<strong>时间毫秒值</strong>。</li></ul><h2 id="2-2-DateFormat类（Date的转换）"><a href="#2-2-DateFormat类（Date的转换）" class="headerlink" title="2.2 DateFormat类（Date的转换）"></a>2.2 DateFormat类（Date的转换）</h2><p>​        <code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,</p><blockquote><p>也就是可以在Date对象与String对象之间进行来回转换。</p></blockquote><ul><li><strong>格式化</strong>：按照指定的格式，从<strong>Date对象</strong>转换为<strong>String对象</strong>。</li><li><strong>解析</strong>：按照指定的格式，从<strong>String对象</strong>转换为<strong>Date对象</strong>。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>​        由于DateFormat为<strong>抽象类</strong>，不能直接使用，所以需要**常用的子类<code>java.text.SimpleDateFormat</code>**。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><p><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</p><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p></li></ul><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。</p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法format-parse"><a href="#常用方法format-parse" class="headerlink" title="常用方法format parse"></a>常用方法format parse</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        Date date = df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Calendar类（方便获取各个时间属性）"><a href="#2-3-Calendar类（方便获取各个时间属性）" class="headerlink" title="2.3 Calendar类（方便获取各个时间属性）"></a>2.3 Calendar类（方便获取各个时间属性）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。<strong>该类将所有可能用到的时间信息封装为静态成员变量</strong>，方便获取。日历类就是<strong>方便获取各个时间属性</strong>的。</p><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，<strong>为给定的日历字段添加或减去指定的时间量</strong>。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（<strong>从历元到现在的毫秒偏移量</strong>）的<strong>Date对象</strong>。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getTime方法（返回Date对象）"><a href="#getTime方法（返回Date对象）" class="headerlink" title="getTime方法（返回Date对象）"></a>getTime方法（返回Date对象）</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是<strong>拿到对应的Date对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h1 id="3-System类"><a href="#3-System类" class="headerlink" title="3. System类"></a>3. System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11SystemArrayCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-StringBuilder类"><a href="#4-StringBuilder类" class="headerlink" title="4. StringBuilder类"></a>4. StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在API中对String类有这样的描述：<strong>字符串是常量，它们的值在创建后不能被更改</strong>。</p><blockquote><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p></blockquote><p>​        由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p><p><img src="/2020/08/28/03.%E5%B8%B8%E7%94%A8API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E6%8B%86%E8%A3%85%E7%AE%B1_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E8%BD%AC%E6%8D%A2/01_StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.bmp" alt="06-StringBuilder的原理"></p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">        StringBuilder builder2 = builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//对比一下</span></span><br><span class="line">        System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">        System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">        System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">        builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        builder.append(<span class="keyword">true</span>);</span><br><span class="line">        builder.append(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-包装类"><a href="#5-包装类" class="headerlink" title="5. 包装类"></a>5. 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><img src="/2020/08/28/03.%E5%B8%B8%E7%94%A8API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E6%8B%86%E8%A3%85%E7%AE%B1_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E8%BD%AC%E6%8D%A2/02_%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5.bmp"></p><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure><h2 id="5-3-自动装箱与自动拆箱"><a href="#5-3-自动装箱与自动拆箱" class="headerlink" title="5.3 自动装箱与自动拆箱"></a>5.3 自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="String转换成对应的基本类型"><a href="#String转换成对应的基本类型" class="headerlink" title="String转换成对应的基本类型"></a>String转换成对应的基本类型</h3><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Object类&lt;ul&gt;
&lt;li&gt;Object类的toString方法&lt;/li&gt;
&lt;li&gt;Object类的equals方法</summary>
      
    
    
    
    <category term="常用API" scheme="https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"/>
    
    
    <category term="Object类(toString_equals)" scheme="https://mrchen229.github.io/tags/Object%E7%B1%BB-toString-equals/"/>
    
    <category term="Objects类" scheme="https://mrchen229.github.io/tags/Objects%E7%B1%BB/"/>
    
    <category term="Date类" scheme="https://mrchen229.github.io/tags/Date%E7%B1%BB/"/>
    
    <category term="DateFormat类(Date与String之间的转换)" scheme="https://mrchen229.github.io/tags/DateFormat%E7%B1%BB-Date%E4%B8%8EString%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="Calendar类(方便获取各个时间属性)" scheme="https://mrchen229.github.io/tags/Calendar%E7%B1%BB-%E6%96%B9%E4%BE%BF%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"/>
    
    <category term="System类" scheme="https://mrchen229.github.io/tags/System%E7%B1%BB/"/>
    
    <category term="StringBuilder类" scheme="https://mrchen229.github.io/tags/StringBuilder%E7%B1%BB/"/>
    
    <category term="包装类与自动拆装箱" scheme="https://mrchen229.github.io/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"/>
    
    <category term="基本类型与字符串之间的转换" scheme="https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>final_权限修饰符_成员内部类_匿名内部类_引用类型用法(class_interface)</title>
    <link href="https://mrchen229.github.io/2020/08/28/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95(class_interface)/"/>
    <id>https://mrchen229.github.io/2020/08/28/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95(class_interface)/</id>
    <published>2020-08-28T01:40:08.000Z</published>
    <updated>2020-08-28T01:40:55.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>final关键字</li><li>权限修饰符</li><li>成员内部类</li><li>匿名内部类</li><li>引用类型用法(class interface)</li></ul><h1 id="1-final关键字"><a href="#1-final关键字" class="headerlink" title="1. final关键字"></a>1. final关键字</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 final 关键字，用于<strong>修饰不可改变内容</strong>。</p><ul><li><strong>final</strong>： 不可改变。可以用于修饰类、方法和变量。<ul><li><strong>类</strong>：被修饰的类，<strong>不能被继承</strong>。</li><li><strong>方法</strong>：被修饰的方法，<strong>不能被重写</strong>。</li><li><strong>变量</strong>：被修饰的变量，<strong>不能被重新赋值</strong>。</li></ul></li></ul><h2 id="1-2-使用方式"><a href="#1-2-使用方式" class="headerlink" title="1.2 使用方式"></a>1.2 使用方式</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询API发现像 <code>public final class String</code> 、 <code>public final class Math</code> 、 <code>public final class Scanner</code>等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重写被 final 修饰的方法，编译时就会报错。  </p></blockquote><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><h4 id="局部变量——基本类型"><a href="#局部变量——基本类型" class="headerlink" title="局部变量——基本类型"></a>局部变量——基本类型</h4><p><strong>基本类型的局部变量，被final修饰后，只能赋值一次</strong>，不能再更改。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明变量，使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="comment">// 第一次赋值</span></span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 第二次赋值</span></span><br><span class="line">        a = <span class="number">20</span>; <span class="comment">// 报错,不可重新赋值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明变量，直接赋值，使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 第二次赋值</span></span><br><span class="line">        b = <span class="number">20</span>; <span class="comment">// 报错,不可重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部变量——引用类型"><a href="#局部变量——引用类型" class="headerlink" title="局部变量——引用类型"></a>局部变量——引用类型</h4><p>引用类型的局部变量，被final修饰后<strong>，只能指向一个对象，地址不能再更改</strong>。但是<strong>不影响对象内部的成员变量值的修改</strong>，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 User 对象</span></span><br><span class="line">        <span class="keyword">final</span> User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 创建 另一个 User对象</span></span><br><span class="line">        u = <span class="keyword">new</span> User(); <span class="comment">// 报错，指向了新的对象，地址值改变。</span></span><br><span class="line">        <span class="comment">// 调用setName方法</span></span><br><span class="line">        u.setName(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 可以修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：</p><ul><li><p>显示初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String USERNAME = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法初始化  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String USERNAME ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.USERNAME = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。  </p></blockquote></li></ul><h1 id="2-权限修饰符public-protected-default-private"><a href="#2-权限修饰符public-protected-default-private" class="headerlink" title="2. 权限修饰符public protected default private"></a>2. 权限修饰符public protected default private</h1><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，</p><ul><li>public：公共的。</li><li>protected：受保护的</li><li>default：默认的</li><li>private：私有的</li></ul><h2 id="2-1-不同权限的访问能力"><a href="#2-1-不同权限的访问能力" class="headerlink" title="2.1 不同权限的访问能力"></a>2.1 不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>default（空的）</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中(子类与无关类)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>建议：</p><ul><li>成员变量使用 <code>private</code> ，隐藏细节。</li><li>构造方法使用 <code>public</code> ，方便创建对象。</li><li>成员方法使用 <code>public</code> ，方便调用方法。</li></ul><blockquote><p>小贴士：不加权限修饰符，其访问能力与default修饰符相同  </p></blockquote><h1 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>​        将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。</p><h2 id="3-2-成员内部类"><a href="#3-2-成员内部类" class="headerlink" title="3.2 成员内部类"></a>3.2 成员内部类</h2><p>成员内部类 ：定义在<strong>类中方法外</strong>的类。</p><p>定义格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> 内部类</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。  </p></blockquote><h3 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h3><ul><li><strong>内部</strong>类可以直接访问<strong>外部</strong>类的成员，包括<strong>私有成员</strong>。</li><li><strong>外部</strong>类要访问<strong>内部</strong>类的成员，必须<strong>要建立内部类的对象</strong>。</li></ul><p>创建内部类对象格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类型().new 内部类型()；</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> live = <span class="keyword">true</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接访问外部类成员</span></span><br><span class="line">            <span class="keyword">if</span> (live) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;心脏在跳动&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;心脏不跳了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> live;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLive</span><span class="params">(<span class="keyword">boolean</span> live)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.live = live;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建外部类对象</span></span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="comment">// 创建内部类对象</span></span><br><span class="line">    Heart heart = p.<span class="function">new <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 调用内部类方法</span></span><br><span class="line">    heart.jump();</span><br><span class="line">    <span class="comment">// 调用外部类方法</span></span><br><span class="line">    p.setLive(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 调用内部类方法</span></span><br><span class="line">    heart.jump();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。<br>比如，Person$Heart.class  </p></blockquote><h2 id="3-3-匿名内部类【重点】"><a href="#3-3-匿名内部类【重点】" class="headerlink" title="3.3 匿名内部类【重点】"></a>3.3 匿名内部类【重点】</h2><p>匿名内部类 ：是内部类的简化写法。它的本质是一个 <code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的</code> <code>子类对象</code>。<br>开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，</p><ol><li><strong>定义子类</strong></li><li><strong>重写接口中的方法</strong></li><li><strong>创建子类对象</strong></li><li>调用重写后的方法</li></ol><p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>​        匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>以接口为例，匿名内部类的使用示例：<br>定义接口：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyAble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建匿名内部类，并调用：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.等号右边:是匿名内部类，定义并创建该接口的子类对象</span></span><br><span class="line"><span class="comment">            2.等号左边:是多态赋值,接口类型引用指向子类对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        FlyAble f = <span class="keyword">new</span> FlyAble()&#123;  <span class="comment">//相当于重写接口方法的子类，并且创建对象</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我飞了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//调用 fly方法,执行重写后的方法</span></span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。  </p></blockquote><h1 id="4-引用类型用法总结"><a href="#4-引用类型用法总结" class="headerlink" title="4. 引用类型用法总结"></a>4. 引用类型用法总结</h1><p>​        实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。</p><h2 id="4-1-class作为成员变量"><a href="#4-1-class作为成员变量" class="headerlink" title="4.1 class作为成员变量"></a>4.1 class作为成员变量</h2><blockquote><p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。  </p></blockquote><h2 id="4-2-interface作为成员变量"><a href="#4-2-interface作为成员变量" class="headerlink" title="4.2 interface作为成员变量"></a>4.2 interface作为成员变量</h2><blockquote><p>接口是对方法的封装<br>接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。  </p></blockquote><h2 id="4-3-interface作为方法参数和返回值类型"><a href="#4-3-interface作为方法参数和返回值类型" class="headerlink" title="4.3 interface作为方法参数和返回值类型"></a>4.3 interface作为方法参数和返回值类型</h2><p>​        当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 </p><p><code>ArrayList</code> 类我们并不陌生，查看API我们发现，实际上，它是 <code>java.util.List</code> 接口的<strong>实现类</strong>。所以，当我们看见 List 接口作为参数或者返回值类型时，当然可以将 ArrayList 的对象进行传递或返回。  </p><blockquote><p>接口作为参数时，传递它的子类对象。<br>接口作为返回值类型时，返回它的子类对象。  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;final关键字&lt;/li&gt;
&lt;li&gt;权限修饰符&lt;/li&gt;
&lt;li&gt;成员内部类&lt;/li&gt;
&lt;li&gt;匿名内部类&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="继承与多态" scheme="https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    
    
    <category term="final关键字" scheme="https://mrchen229.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    <category term="权限修饰符" scheme="https://mrchen229.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
    <category term="成员内部类" scheme="https://mrchen229.github.io/tags/%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    <category term="匿名内部类" scheme="https://mrchen229.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    <category term="引用类型用法(class interface)" scheme="https://mrchen229.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95-class-interface/"/>
    
  </entry>
  
  <entry>
    <title>接口成员_接口多实现方法细节_多态前提与上下转型_instanceof</title>
    <link href="https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98_%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82_%E5%A4%9A%E6%80%81%E5%89%8D%E6%8F%90%E4%B8%8E%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B_instanceof/"/>
    <id>https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98_%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82_%E5%A4%9A%E6%80%81%E5%89%8D%E6%8F%90%E4%B8%8E%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B_instanceof/</id>
    <published>2020-08-27T02:32:08.000Z</published>
    <updated>2020-08-27T02:32:52.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>接口成员的定义</li><li>接口多实现的细节(多个方法的实现)</li><li>接口的限制</li><li>多态的前提</li><li>多态的向上向下转型</li><li>多态的转型异常(instanceof)</li></ul><h1 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>​        接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么<strong>接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）</strong>。<br>​        接口的定义，它与定义类方式相似，但是使用 <strong>interface</strong> 关键字。它<strong>也会被编译成.class文件</strong>，但一定要明确它并不是类，而是另外<strong>一种引用数据类型</strong>。</p><ul><li><strong>引用数据类型：数组，类，接口。</strong></li></ul><p>​        接口的使用，它<strong>不能创建对象，但是可以被实现</strong>（ implements ，类似于被继承）。<strong>一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法</strong>，创建该类对象，就可以调用方法了，<strong>否则它必须是一个抽象类</strong>。</p><h2 id="1-2-接口定义格式"><a href="#1-2-接口定义格式" class="headerlink" title="1.2 接口定义格式"></a>1.2 接口定义格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有抽象方法"><a href="#含有抽象方法" class="headerlink" title="含有抽象方法"></a>含有抽象方法</h3><ul><li><p>抽象方法：使用 <code>abstract</code> 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="含有默认方法和静态方法"><a href="#含有默认方法和静态方法" class="headerlink" title="含有默认方法和静态方法"></a>含有默认方法和静态方法</h3><ul><li>默认方法：使用 <code>default</code> 修饰，不可省略，供<strong>子类调用或者子类重写</strong>。</li><li>静态方法：使用 <code>static</code> 修饰，供<strong>接口</strong>直接调用。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有私有方法和私有静态方法"><a href="#含有私有方法和私有静态方法" class="headerlink" title="含有私有方法和私有静态方法"></a>含有私有方法和私有静态方法</h3><p>私有方法：使用 <code>private</code> 修饰，供接口中的默认方法或者静态方法调用。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-基本的实现"><a href="#1-3-基本的实现" class="headerlink" title="1.3 基本的实现"></a>1.3 基本的实现</h2><h3 id="实现的概述"><a href="#实现的概述" class="headerlink" title="实现的概述"></a>实现的概述</h3><p>​        类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code> 关键字。</p><p>非抽象子类实现接口：</p><ol><li>必须重写接口中所有<strong>抽象方法</strong>。</li><li>继承了接口的<strong>默认方法</strong>，即可以直接调用，也可以重写。</li></ol><p>实现格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>抽象方法的使用</strong></p><blockquote><p>必须全部实现</p></blockquote></li><li><p><strong>默认方法的使用</strong><br>可以继承，可以重写，二选一，但是<strong>只能通过实现类的对象来调用</strong>。</p><blockquote><p>1.继承默认方法</p><p>2.重写默认方法  </p></blockquote></li><li><p><strong>静态方法的使用</strong><br>静态与.class 文件相关，<strong>只能使用接口名调用</strong>，<strong>不可以通过实现类的类名或者实现类的对象调用</strong>  </p></li><li><p><strong>私有方法的使用</strong></p><ul><li>私有方法：只有<strong>默认方法可以调用</strong>。</li><li>私有静态方法：<strong>默认方法和静态方法可以调用</strong>。</li></ul><blockquote><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，<strong>私有的方法是对默认方法和静态方法的辅助</strong>。  </p></blockquote></li></ul><h2 id="1-4-接口的多实现"><a href="#1-4-接口的多实现" class="headerlink" title="1.4 接口的多实现"></a>1.4 接口的多实现</h2><p>​        之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，<strong>一个类是可以实现多个接口的</strong>，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中默认方法【不重名时可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[ ]： 表示可选操作。  </p></blockquote><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>​        接口中，有多个抽象方法时，实现类必须重写所有抽象方法。<strong>如果抽象方法有重名的，只需要重写一次。</strong>  </p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>​        接口中，有多个默认方法时，实现类都可继承使用。<strong>如果默认方法有重名的，必须重写一次</strong>。  </p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>​        接口中，存在同名的静态方法并不会冲突，原因是<strong>只能通过各自接口名访问静态方法</strong>。</p><h3 id="优先级的问题"><a href="#优先级的问题" class="headerlink" title="优先级的问题"></a>优先级的问题</h3><p>​        当一个类，既继承一个父类，又实现若干个接口时，<strong>父类中的成员方法与接口中的默认方法重名</strong>，<strong>子类就近选择执行父类的成员方法。</strong>  </p><h2 id="1-5-接口的多继承"><a href="#1-5-接口的多继承" class="headerlink" title="1.5 接口的多继承"></a>1.5 接口的多继承</h2><p>​        一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次</strong>。  </p><blockquote><p>子接口重写默认方法时，default关键字可以保留。<br>子类重写默认方法时，default关键字不可以保留。  </p></blockquote><h2 id="1-6-接口其他成员特点（限制）"><a href="#1-6-接口其他成员特点（限制）" class="headerlink" title="1.6 接口其他成员特点（限制）"></a>1.6 接口其他成员特点（限制）</h2><ul><li>接口中，无法定义成员变量，但是<strong>可以定义常量</strong>，其值不可以改变，<strong>默认使用public static final修饰</strong>。</li><li>接口中，没有构造方法，不能创建对象。</li><li><strong>接口中，没有静态代码块。</strong>  </li></ul><h2 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在Java <span class="number">9</span>+版本中，接口的内容可以有：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 成员变量其实是常量，格式：</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 数据类型 常量名称 = 数据值;</span><br><span class="line">    注意：</span><br><span class="line">        常量必须进行赋值，而且一旦赋值不能改变。</span><br><span class="line">        常量名称完全大写，用下划线进行分隔。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 接口中最重要的就是抽象方法，格式：</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值类型 方法名称(参数列表);</span><br><span class="line">    注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 从Java <span class="number">8</span>开始，接口里允许定义默认方法，格式：</span><br><span class="line">    [<span class="keyword">public</span>] <span class="keyword">default</span> 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</span><br><span class="line">    注意：默认方法也可以被覆盖重写</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 从Java <span class="number">8</span>开始，接口里允许定义静态方法，格式：</span><br><span class="line">    [<span class="keyword">public</span>] <span class="keyword">static</span> 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</span><br><span class="line">    注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 从Java <span class="number">9</span>开始，接口里允许定义私有方法，格式：</span><br><span class="line">    普通私有方法：<span class="keyword">private</span> 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</span><br><span class="line">    静态私有方法：<span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</span><br><span class="line">    注意：<span class="keyword">private</span>的方法只有接口自己才能调用，不能被实现类或别人使用。</span><br></pre></td></tr></table></figure><h1 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>多态是继封装、继承之后，面向对象的第三大特性。</p><ul><li>多态： 是指同一行为，具有多个不同表现形式。</li></ul><h3 id="前提（★）"><a href="#前提（★）" class="headerlink" title="前提（★）"></a>前提（★）</h3><ol><li><strong>继承或者实现</strong>【二选一】</li><li>方法的重写【意义体现：不重写，无意义】</li><li><strong>父类引用指向子类对象</strong>【格式体现】  </li></ol><h2 id="2-2-多态的体现"><a href="#2-2-多态的体现" class="headerlink" title="2.2 多态的体现"></a>2.2 多态的体现</h2><p>多态体现的格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类对象；</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。  </p></blockquote><p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong>  </p><h2 id="2-3-多态的好处"><a href="#2-3-多态的好处" class="headerlink" title="2.3 多态的好处"></a>2.3 多态的好处</h2><p>​        实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。  </p><img src="/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98_%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82_%E5%A4%9A%E6%80%81%E5%89%8D%E6%8F%90%E4%B8%8E%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B_instanceof/04-使用多态的好处.png" style="zoom:67%;"><h2 id="2-4-引用类型转换"><a href="#2-4-引用类型转换" class="headerlink" title="2.4 引用类型转换"></a>2.4 引用类型转换</h2><p><img src="/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98_%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82_%E5%A4%9A%E6%80%81%E5%89%8D%E6%8F%90%E4%B8%8E%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B_instanceof/05-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B.png"></p><p>​        多态的转型分为向上转型与向下转型两种：</p><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><ul><li><p>向上转型：多态本身是<strong>子类类型向父类类型向上转换的过程</strong>，这个过程是默认的。</p><p><strong>当父类引用指向一个子类对象时，便是向上转型</strong>。</p></li></ul><p>使用格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><ul><li>向下转型：<strong>父类类型向子类类型向下转换</strong>的过程，这个过程是<strong>强制的</strong>。  </li></ul><p>一个已经向上转型的子类对象，<strong>将父类引用转为子类引用</strong>，可以使用<strong>强制类型转换的格式</strong>，便是向下转型。  </p><p>使用格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如: Cat c =(Cat) a;</span><br></pre></td></tr></table></figure><h3 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h3><p>​        当使用多态方式调用方法时，<strong>首先检查父类中是否有该方法</strong>，如果没有，则编译错误。也就是说，<strong>不能调用子类拥有，而父类没有的方法。</strong>编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，<strong>想要调用子类特有的方法，必须做向下转型。</strong>  </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat(); <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        Cat c = (Cat)a;</span><br><span class="line">        c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转型的异常"><a href="#转型的异常" class="headerlink" title="转型的异常"></a>转型的异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat(); <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        Dog d = (Dog)a;</span><br><span class="line">        d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。  </p></blockquote><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line">    如果变量属于该数据类型，返回<span class="keyword">true</span>。</span><br><span class="line">    如果变量不属于该数据类型，返回<span class="keyword">false</span>。</span><br><span class="line"></span><br><span class="line">eg: a <span class="keyword">instanceof</span> Cat</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;接口成员的定义&lt;/li&gt;
&lt;li&gt;接口多实现的细节(多个方法的实现)&lt;/li&gt;
&lt;li&gt;接口的限制&lt;/li&gt;
&lt;li&gt;多</summary>
      
    
    
    
    <category term="继承与多态" scheme="https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    
    
    <category term="接口成员的定义" scheme="https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    
    <category term="接口多实现方法细节" scheme="https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82/"/>
    
    <category term="接口的限制" scheme="https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%99%90%E5%88%B6/"/>
    
    <category term="多态的前提" scheme="https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90/"/>
    
    <category term="多态的上下转型" scheme="https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    
    <category term="instanceof" scheme="https://mrchen229.github.io/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>继承_super_this_abstract</title>
    <link href="https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/"/>
    <id>https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/</id>
    <published>2020-08-27T01:34:08.000Z</published>
    <updated>2020-08-27T01:35:17.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>三大特性之继承</li><li>super关键字</li><li>this关键字</li><li>abstract方法与abstract类</li></ul><h1 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>​        多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。 </p><p>​        其中，多个类可以称为子类，单独那一个类称为<strong>父类、超类（superclass）或者基类</strong>。<br>​        继承描述的是事物之间的所属关系，这种关系是： <code>is-a</code> 的关系。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。  </p><ul><li>继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</li><li>好处<ol><li>提高代码的复用性。</li><li>类与类之间产生了关系，是多态的前提。  </li></ol></li></ul><p><img src="/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/01-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png"></p><h2 id="1-2-继承的格式"><a href="#1-2-继承的格式" class="headerlink" title="1.2 继承的格式"></a>1.2 继承的格式</h2><p>​        通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-继承后的特点——成员变量"><a href="#1-3-继承后的特点——成员变量" class="headerlink" title="1.3 继承后的特点——成员变量"></a>1.3 继承后的特点——成员变量</h2><p>​        当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？</p><h3 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h3><p>​        如果子类父类中出现<strong>不重名的成员变量</strong>，这时的访问是<strong>没有影响</strong>的。  </p><h3 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h3><p>​        如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响</strong>的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fu中的成员变量。</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Zi中的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问父类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Fu num=&quot;</span> + num);</span><br><span class="line">        <span class="comment">// 访问子类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Zi num=&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        <span class="comment">// 调用子类中的show方法</span></span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">演示结果：</span><br><span class="line">    Fu num = <span class="number">6</span></span><br><span class="line">    Zi num = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>​        子父类中出现了同名的成员变量时，<strong>在子类中需要访问父类中非私有成员变量</strong>时，需要使用 <code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 this 。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.父类成员变量名</span><br></pre></td></tr></table></figure><blockquote><p>Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。</p><p>通常编码时，我们遵循封装的原则，使用private修饰成员变量，那如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。  </p></blockquote><h2 id="1-4-继承后的特点——成员方法"><a href="#1-4-继承后的特点——成员方法" class="headerlink" title="1.4 继承后的特点——成员方法"></a>1.4 继承后的特点——成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p><h3 id="成员方法不重名"><a href="#成员方法不重名" class="headerlink" title="成员方法不重名"></a>成员方法不重名</h3><p>​        如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是没有影响的。对象调用方法时，会先在<strong>子类</strong>中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行<strong>父类</strong>中相应的方法。  </p><h3 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h3><p>​        如果子类父类中出现<strong>重名</strong>的成员方法，这时的访问是一种特殊情况，叫做<strong>方法重写</strong> (Override)。</p><ul><li>方法重写 ：子类中出现与父类<strong>一模一样的方法</strong>时（<strong>返回值类型，方法名和参数列表都相同</strong>），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子类重写了父类的show方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo05</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        <span class="comment">// 子类中有show方法，只执行重写后的show方法</span></span><br><span class="line">        z.show(); <span class="comment">// Zi show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。</p><blockquote><p>用到super.父类成员方法，表示调用父类的成员方法。  </p></blockquote><h3 id="重写的注意事项"><a href="#重写的注意事项" class="headerlink" title="重写的注意事项"></a>重写的注意事项</h3><ol><li>子类方法覆盖父类<strong>方法</strong>，必须要保证<strong>权限大于等于父类权限</strong>。</li><li>子类方法覆盖父类<strong>方法</strong>，<strong>返回值类型、函数名和参数列表都要一模一样</strong>。  </li></ol><h2 id="1-5-继承后的特点——构造方法"><a href="#1-5-继承后的特点——构造方法" class="headerlink" title="1.5 继承后的特点——构造方法"></a>1.5 继承后的特点——构造方法</h2><p>当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？</p><p>首先我们要回忆两个事情，构造方法的定义格式和作用。</p><ol><li>构造方法的名字是与类名一致的。所以<strong>子类是无法继承父类构造方法</strong>的。</li><li>构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子<strong>类的构造方法中默认有一个 super() ，表示调用父类的构造方法</strong>，父类成员变量初始化后，才可以给子类使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    Fu()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">        <span class="comment">// super（），调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi（）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo07</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">输出结果：</span><br><span class="line">    Fu（）</span><br><span class="line">    Zi（）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-6-super和this"><a href="#1-6-super和this" class="headerlink" title="1.6 super和this"></a>1.6 super和this</h2><p><img src="/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/03-super%E4%B8%8Ethis%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h3 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h3><p>​        在每次<strong>创建子类对象</strong>时，<strong>先初始化父类空间，再创建其子类对象本身</strong>。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。</p><p>​        代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p><img src="/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/image-20200827090502331.png" alt="image-20200827090502331" style="zoom:50%;"><h3 id="super和this的含义"><a href="#super和this的含义" class="headerlink" title="super和this的含义"></a>super和this的含义</h3><ul><li><p>super ：代表父类的存储空间标识(可以理解为父亲的引用)。</p></li><li><p>this ：代表当前对象的引用(谁调用就代表谁)。</p></li></ul><h3 id="super和this的用法"><a href="#super和this的用法" class="headerlink" title="super和this的用法"></a>super和this的用法</h3><ol><li><p>访问成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量 ‐‐ 本类的</span><br><span class="line"><span class="keyword">super</span>.成员变量 ‐‐ 父类的</span><br><span class="line"><span class="keyword">this</span>.成员方法名() ‐‐ 本类的</span><br><span class="line"><span class="keyword">super</span>.成员方法名() ‐‐ 父类的</span><br></pre></td></tr></table></figure></li><li><p>访问构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>(...) ‐‐ 本类的构造方法</span><br><span class="line"><span class="keyword">super</span>(...) ‐‐ 父类的构造方法</span><br></pre></td></tr></table></figure><blockquote><p>子类的每个构造方法中均有<strong>默认的super()**，调用</strong>父类的空参构造<strong>。手动调用父类构造会覆盖默认的super()。<br>**super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现</strong>。  </p></blockquote></li></ol><h2 id="1-7-继承的特点"><a href="#1-7-继承的特点" class="headerlink" title="1.7 继承的特点"></a>1.7 继承的特点</h2><img src="/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/04-Java继承的三个特点.png" style="zoom:67%;"><ol><li><p>Java只支持单继承，不支持多继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个类只能有一个父类，不可以有多个父类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125; <span class="comment">//ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>，<span class="title">B</span>... //<span class="title">error</span></span></span><br></pre></td></tr></table></figure></li><li><p>Java支持多层继承(继承体系)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顶层父类是Object类。所有的类默认继承Object，作为父类。  </p></blockquote></li><li><p>子类和父类是一种相对的概念。  </p></li></ol><h1 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>​        父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们<strong>把没有方法主体的方法称为抽象方法</strong>。Java语法规定，<strong>包含抽象方法的类就是抽象类</strong>。</p><ul><li>定义<ul><li><strong>抽象方法</strong> ： 没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul></li></ul><h2 id="2-2-abstract使用格式"><a href="#2-2-abstract使用格式" class="headerlink" title="2.2 abstract使用格式"></a>2.2 abstract使用格式</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>​        使用 <code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，<strong>抽象方法只包含一个方法名，而没有方法体</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表)；</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>​        如果一个类<strong>包含抽象方法</strong>，那么该类必须是<strong>抽象类</strong>。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名字 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象的使用"><a href="#抽象的使用" class="headerlink" title="抽象的使用"></a>抽象的使用</h3><p>​        <strong>继承抽象类的子类必须重写父类所有的抽象方法</strong>。<strong>否则，该子类也必须声明为抽象类。</strong>最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。  </p><blockquote><p>子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。  </p></blockquote><h2 id="2-3-注意事项"><a href="#2-3-注意事项" class="headerlink" title="2.3 注意事项"></a>2.3 注意事项</h2><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p><strong>抽象类中，可以有构造方法</strong>，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p><strong>抽象类中，不一定包含抽象方法</strong>，但是有抽象方法的类必定是抽象类。  </p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。  </p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象<br>类。</p><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。  </p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;三大特性之继承&lt;/li&gt;
&lt;li&gt;super关键字&lt;/li&gt;
&lt;li&gt;this关键字&lt;/li&gt;
&lt;li&gt;abstract</summary>
      
    
    
    
    <category term="继承与多态" scheme="https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    
    
    <category term="三大特性之继承" scheme="https://mrchen229.github.io/tags/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    
    <category term="super关键字" scheme="https://mrchen229.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    <category term="this关键字" scheme="https://mrchen229.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    <category term="abstract方法与abstract类" scheme="https://mrchen229.github.io/tags/abstract%E6%96%B9%E6%B3%95%E4%B8%8Eabstract%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Scanner_Random_ArrayList_String常见方法_Arrays_Math_static关键字</title>
    <link href="https://mrchen229.github.io/2020/08/26/03.%E5%B8%B8%E7%94%A8API/Scanner_Random_ArrayList_String%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95_Arrays_Math_static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://mrchen229.github.io/2020/08/26/03.%E5%B8%B8%E7%94%A8API/Scanner_Random_ArrayList_String%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95_Arrays_Math_static%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-26T14:58:08.000Z</published>
    <updated>2020-08-26T14:59:55.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>Scanner类</li><li>Random类</li><li>ArrayList类</li><li>String类的常用方法</li><li>Arrays类的方法</li><li>Math类</li><li>static关键字（static变量、static方法、static代码块）</li></ul><h1 id="1-API"><a href="#1-API" class="headerlink" title="1. API"></a>1. API</h1><p>​        API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。  </p><h2 id="1-1-API使用步骤"><a href="#1-1-API使用步骤" class="headerlink" title="1.1 API使用步骤"></a>1.1 API使用步骤</h2><ol><li>打开帮助文档。</li><li>点击显示，找到索引，看到输入框。</li><li>在输入框里输入内容，然后回车。</li><li>看包。java.lang下的类不需要导包，其他需要。</li><li>看类的解释和说明。</li><li>学习构造方法  </li><li>使用成员方法</li></ol><h1 id="2-Scanner类"><a href="#2-Scanner类" class="headerlink" title="2. Scanner类"></a>2. Scanner类</h1><h2 id="2-1-什么是Scanner类"><a href="#2-1-什么是Scanner类" class="headerlink" title="2.1 什么是Scanner类"></a>2.1 什么是Scanner类</h2><p>​        一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 System.in 中读取一个数：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br></pre></td></tr></table></figure><blockquote><p>备注：System.in 系统输入指的是通过键盘录入数据。  </p></blockquote><h2 id="2-2-引用类型使用步骤"><a href="#2-2-引用类型使用步骤" class="headerlink" title="2.2 引用类型使用步骤"></a>2.2 引用类型使用步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>​        使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名;</span><br><span class="line">eg: <span class="keyword">import</span> java.util.Scanner</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>​        使用该类的构造方法，创建一个该类的对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = <span class="keyword">new</span> 数据类型(参数列表);</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>​        调用该类的成员方法，完成指定功能。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure><h2 id="2-3-Scanner使用步骤"><a href="#2-3-Scanner使用步骤" class="headerlink" title="2.3 Scanner使用步骤"></a>2.3 Scanner使用步骤</h2><p>查看类</p><ul><li>java.util.Scanner ：该类需要import导入后使用。</li></ul><p>查看构造方法</p><ul><li>public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。</li></ul><p>查看成员方法</p><ul><li>public int nextInt() ：将输入信息的下一个标记扫描为一个 int 值。</li></ul><p>使用Scanner类，完成接收键盘录入数据的操作，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Scanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 创建键盘录入数据的对象</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//3. 接收数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请录入一个整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = sc.nextInt();</span><br><span class="line">        <span class="comment">//4. 输出数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-匿名对象"><a href="#2-4-匿名对象" class="headerlink" title="2.4 匿名对象"></a>2.4 匿名对象</h2><p>​        创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。</p><ul><li>匿名对象 ：没有变量名的对象。</li></ul><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名(参数列表)；</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p>创建匿名对象直接调用方法，没有变量名。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Scanner(System.in).nextInt();</span><br></pre></td></tr></table></figure></li><li><p>一旦调用两次方法，就是创建了两个对象，造成浪费</p></li><li><p>匿名对象可以作为方法的参数和返回值</p><ol><li><p>作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 普通方式</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        input(sc);</span><br><span class="line">        <span class="comment">//匿名对象作为方法接收的参数</span></span><br><span class="line">        input(<span class="keyword">new</span> Scanner(System.in));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Scanner sc)</span></span>&#123;</span><br><span class="line">        System.out.println(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 普通方式</span></span><br><span class="line">        Scanner sc = getScanner();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">getScanner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//普通方式</span></span><br><span class="line">        <span class="comment">//Scanner sc = new Scanner(System.in);</span></span><br><span class="line">        <span class="comment">//return sc;</span></span><br><span class="line">        <span class="comment">//匿名对象作为方法返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="3-Random类"><a href="#3-Random类" class="headerlink" title="3. Random类"></a>3. Random类</h1><h2 id="3-1-什么是Random类"><a href="#3-1-什么是Random类" class="headerlink" title="3.1 什么是Random类"></a>3.1 什么是Random类</h2><p>此类的实例用于生成伪随机数。<br>例如，以下代码使用户能够得到一个随机数：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt();</span><br></pre></td></tr></table></figure><h2 id="3-2-Random使用步骤"><a href="#3-2-Random使用步骤" class="headerlink" title="3.2 Random使用步骤"></a>3.2 Random使用步骤</h2><ul><li>查看类<br>java.util.Random ：该类需要 import导入使后使用。</li><li>查看构造方法<br>public Random() ：创建一个新的随机数生成器。</li><li>查看成员方法<br>public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的<br>int 值。</li></ul><p>使用Random类，完成生成3个10以内的随机整数的操作，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Random</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 创建键盘录入数据的对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//3. 随机生成一个数据</span></span><br><span class="line">            <span class="keyword">int</span> number = r.nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//4. 输出数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;number:&quot;</span>+ number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。  </p></blockquote><h3 id="获取随机数"><a href="#获取随机数" class="headerlink" title="获取随机数"></a>获取随机数</h3><p>获取1-n之间的随机数，包含n，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Random</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">50</span>;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// 获取随机数</span></span><br><span class="line">        <span class="keyword">int</span> number = r.nextInt(n) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 输出随机数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;number:&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-ArrayList类"><a href="#4-ArrayList类" class="headerlink" title="4. ArrayList类"></a>4. ArrayList类</h1><blockquote><p>想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需求。</p><p>为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据  </p></blockquote><h2 id="4-1-什么是ArrayList类"><a href="#4-1-什么是ArrayList类" class="headerlink" title="4.1 什么是ArrayList类"></a>4.1 什么是ArrayList类</h2><p><code>java.util.ArrayList</code> 是<strong>大小可变的数组</strong>的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。  </p><h2 id="4-2-ArrayList使用步骤"><a href="#4-2-ArrayList使用步骤" class="headerlink" title="4.2 ArrayList使用步骤"></a>4.2 ArrayList使用步骤</h2><ul><li><p>查看类</p><p><code>java.util.ArrayList &lt;E&gt;</code> ：该类需要 import导入使后使用。</p></li></ul><p><code>&lt;E&gt; </code>，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;，ArrayList&lt;Student&gt;</span><br></pre></td></tr></table></figure><ul><li><p>查看构造方法</p><p><code>public ArrayList()</code> ：构造一个内容为空的集合。<br>基本格式:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>查看成员方法<br><code>public boolean add(E e)</code> ： 将指定的元素添加到此集合的尾部。<br>参数 <code>E e</code> ，在构造ArrayList对象时， <code>&lt;E&gt;</code> 指定了什么数据类型，那么 <code>add(E e)</code> 方法中，只能添加什么数据类型的对象。</p></li></ul><p>使用ArrayList类，存储三个字符串元素，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02StudentArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建学生数组</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;曹操&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;刘备&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;孙权&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印学生ArrayList集合</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//把学生对象作为元素添加到集合</span></span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">        <span class="comment">//打印学生ArrayList集合</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-常用方法和遍历"><a href="#4-3-常用方法和遍历" class="headerlink" title="4.3 常用方法和遍历"></a>4.3 常用方法和遍历</h2><p>对于元素的操作,基本体现在——增、删、查。常用的方法有：</p><ul><li>public boolean add(E e) ：将指定的元素<strong>添加到此集合的尾部</strong>。</li><li>public E remove(int index) ：<strong>移除此集合中指定位置上的元素</strong>。<strong>返回被删除的元素</strong>。</li><li>public E get(int index) ：返回此集合中<strong>指定位置上的元素</strong>。返回获取的元素。</li><li>public int size() ：返回此<strong>集合中的元素数</strong>。遍历集合时，可以控制索引范围，防止越界。</li></ul><p>这些都是最基本的方法，操作非常简单，代码如下:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ArrayListMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//public E get(int index):返回指定索引处的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get:&quot;</span>+list.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;get:&quot;</span>+list.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;get:&quot;</span>+list.get(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//public int size():返回集合中的元素的个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;size:&quot;</span>+list.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//public E remove(int index):删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;remove:&quot;</span>+list.remove(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-如何存储基本数据类型"><a href="#4-4-如何存储基本数据类型" class="headerlink" title="4.4 如何存储基本数据类型"></a>4.4 如何存储基本数据类型</h2><p>​        ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 <code>&lt;int&gt;</code> 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下：  </p><table><thead><tr><th>基本类型</th><th>基本类型包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h1 id="5-String类"><a href="#5-String类" class="headerlink" title="5. String类"></a>5. String类</h1><h2 id="5-1-String类概述"><a href="#5-1-String类概述" class="headerlink" title="5.1 String类概述"></a>5.1 String类概述</h2><p><code>java.lang.String</code> 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。</p><p>类 <code>String</code> 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。</p><h2 id="5-2-特点"><a href="#5-2-特点" class="headerlink" title="5.2 特点"></a>5.2 特点</h2><ol><li><p>字符串不变：字符串的值在创建后不能被更改。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s1 += <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(s1); <span class="comment">// &quot;abcd&quot;</span></span><br><span class="line"><span class="comment">// 内存中有&quot;abc&quot;，&quot;abcd&quot;两个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。</span></span><br></pre></td></tr></table></figure></li><li><p>因为String对象是不可变的，所以它们可以被共享。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。</span></span><br></pre></td></tr></table></figure></li><li><p><code>&quot;abc&quot;</code> 等效于 <code>char[] data=&#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125; </code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">相当于：</span><br><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line"><span class="comment">// String底层是靠字符数组实现的。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串的常量池"><a href="#字符串的常量池" class="headerlink" title="字符串的常量池"></a>字符串的常量池</h3><p><img src="/2020/08/26/03.%E5%B8%B8%E7%94%A8API/Scanner_Random_ArrayList_String%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95_Arrays_Math_static%E5%85%B3%E9%94%AE%E5%AD%97/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0.png"></p><h2 id="5-3-使用步骤"><a href="#5-3-使用步骤" class="headerlink" title="5.3 使用步骤"></a>5.3 使用步骤</h2><ul><li>查看类<ul><li>java.lang.String ：此类不需要导入。</li></ul></li><li>查看构造方法<ul><li><code>public String()</code> ：初始化新创建的 String对象，以使其表示空字符序列。</li><li><code>public String(char[] value)</code> ：通过当前参数中的字符数组来构造新的String。</li><li><code>public String(byte[] bytes)</code> ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。</li></ul></li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line">String str = <span class="keyword">new</span> String（）；</span><br><span class="line"><span class="comment">// 通过字符数组构造</span></span><br><span class="line"><span class="keyword">char</span> chars[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line"><span class="comment">// 通过字节数组构造</span></span><br><span class="line"><span class="keyword">byte</span> bytes[] = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure><h2 id="5-4-常用方法"><a href="#5-4-常用方法" class="headerlink" title="5.4 常用方法"></a>5.4 常用方法</h2><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean equals (Object anObject)</code> ：将此字符串与指定对象进行比较。</li><li><code>public boolean equalsIgnoreCase (String anotherString)</code> ：将此字符串与指定对象进行比较，忽略大小写。<br>方法演示，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">        <span class="comment">// boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        <span class="comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。  </p></blockquote><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><code>public int length ()</code> ：返回此字符串的长度。</li><li><code>public String concat (String str)</code> ：将指定的字符串连接到该字符串的<strong>末尾</strong>。</li><li><code>public char charAt (int index)</code> ：返回指定索引处的 char值。</li><li><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</li><li><code>public String substring (int beginIndex)</code> ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</li><li><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</li></ul><p>方法演示，代码如下  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        <span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span></span><br><span class="line">        String s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        String s2 = s.concat(<span class="string">&quot;**hello itheima&quot;</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">// helloworld**hello itheima</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">&quot;l&quot;</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">&quot;owo&quot;</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">&quot;ak&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String substring(int start):从start开始截取字符串到字符串结尾</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end。</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>, s.length()));</span><br><span class="line">        System.out.println(s.substring(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h3><ul><li><p><code>public char[] toCharArray ()</code> ：将此字符串转换为新的字符数组。</p></li><li><p><code>public byte[] getBytes ()</code> ：使用平台的默认字符集将该 String编码转换为新的字节数组。</p></li><li><p><code>public String replace (CharSequence target, CharSequence replacement)</code> ：将与target匹配的字符串使用replacement字符串替换。</p></li></ul><p>方法演示，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">        <span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) &#123;</span><br><span class="line">            System.out.println(chs[x]);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        <span class="comment">// byte[] getBytes ():把字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bytes.length; x++) &#123;</span><br><span class="line">            System.out.println(bytes[x]);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        <span class="comment">// 替换字母it为大写IT</span></span><br><span class="line">        String str = <span class="string">&quot;itcast itheima&quot;</span>;</span><br><span class="line">        String replace = str.replace(<span class="string">&quot;it&quot;</span>, <span class="string">&quot;IT&quot;</span>);</span><br><span class="line">        System.out.println(replace); <span class="comment">// ITcast ITheima</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中  </p></blockquote><h3 id="分割功能的方法"><a href="#分割功能的方法" class="headerlink" title="分割功能的方法"></a>分割功能的方法</h3><ul><li><code>public String[] split(String regex)</code> ：将此字符串按照给定的regex（规则）拆分为字符串数组。</li></ul><p>方法演示，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">&quot;aa|bb|cc&quot;</span>;</span><br><span class="line">        String[] strArray = s.split(<span class="string">&quot;|&quot;</span>); <span class="comment">// [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; strArray.length; x++) &#123;</span><br><span class="line">            System.out.println(strArray[x]); <span class="comment">// aa bb cc</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-Arrays类"><a href="#6-Arrays类" class="headerlink" title="6. Arrays类"></a>6. Arrays类</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ul><li><code>java.util.Arrays</code> 此类包含用来<strong>操作数组的各种方法</strong>，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</li></ul><h2 id="6-2-操作数组的方法"><a href="#6-2-操作数组的方法" class="headerlink" title="6.2 操作数组的方法"></a>6.2 操作数组的方法</h2><ul><li><code>public static String toString(int[] a)</code> ：返回指定数组内容的字符串表示形式。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义int 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">4</span>,<span class="number">657</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印数组,输出地址值</span></span><br><span class="line">    System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line">    <span class="comment">// 数组内容转为字符串</span></span><br><span class="line">    String s = Arrays.toString(arr);</span><br><span class="line">    <span class="comment">// 打印字符串,输出内容</span></span><br><span class="line">    System.out.println(s); <span class="comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>public static void sort(int[] a)</code> ：对指定的 <code>int</code> 型数组按数字升序进行排序。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义int 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">24</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">48</span>, <span class="number">4</span>, <span class="number">46</span>, <span class="number">35</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;排序前:&quot;</span>+ Arrays.toString(arr)); <span class="comment">// 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6, 2]</span></span><br><span class="line">    <span class="comment">// 升序排序</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序后:&quot;</span>+ Arrays.toString(arr));<span class="comment">// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-Math类"><a href="#7-Math类" class="headerlink" title="7. Math类"></a>7. Math类</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>​        <code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p><h2 id="7-2-基本运算的方法"><a href="#7-2-基本运算的方法" class="headerlink" title="7.2 基本运算的方法"></a>7.2 基本运算的方法</h2><ul><li><p><code>public static double abs(double a) </code>：返回 double 值的绝对值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.abs(‐<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure></li><li><p><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.ceil(‐<span class="number">3.3</span>); <span class="comment">//d2的值为 ‐3.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>public static double floor(double a)</code> ：返回小于等于参数最大的整数。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.floor(‐<span class="number">3.3</span>); <span class="comment">//d2的值为‐4.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> d1 = Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6.0</span></span><br><span class="line"><span class="keyword">long</span> d2 = Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="8-static关键字"><a href="#8-static关键字" class="headerlink" title="8. static关键字"></a>8. static关键字</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p>​        关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p><h2 id="8-2-定义和使用格式"><a href="#8-2-定义和使用格式" class="headerlink" title="8.2 定义和使用格式"></a>8.2 定义和使用格式</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>​        当 <code>static</code> 修饰<strong>成员变量</strong>时，该变量称为<strong>类变量</strong>。该类的<strong>每个对象都共享同一个类变量的值</strong>。<strong>任何对象都可以更改该类变量的值</strong>，但也可以在不创建该类的对象的情况下对类变量进行操作。</p><ul><li>类变量：使用 static关键字修饰的成员变量。</li></ul><p>定义格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>​        当 static 修饰成员方法时，该方法称为类方法 。<strong>静态方法在声明中有 static ，建议使用类名来调用</strong>，而不需要创建类的对象。调用方式非常简单。</p><ul><li>类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。</li></ul><p>定义格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名 (参数列表)&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>静态方法调用的注意事项</strong>：<ul><li>静态方法可以直接访问<strong>类变量和静态方法</strong>。</li><li>静态方法<strong>不能直接访问</strong>普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。</li><li>静态方法中，不能使用<strong>this</strong>关键字。</li></ul></li></ul><blockquote><p>小贴士：静态方法只能访问静态成员。</p></blockquote><h3 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h3><p>​        被static修饰的成员可以并且建议通过类名直接访问。</p><p>​        虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。</p><p>格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问类变量</span></span><br><span class="line">类名.类变量名；</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">类名.静态方法名(参数)；</span><br></pre></td></tr></table></figure><h2 id="8-3-静态原理图解"><a href="#8-3-静态原理图解" class="headerlink" title="8.3 静态原理图解"></a>8.3 静态原理图解</h2><ul><li>static 修饰的内容：<ul><li>是随着<strong>类的加载而加载</strong>的，且只加载一次。</li><li>存储于一块固定的内存区域（<strong>静态区</strong>），所以，可以直接被类名调用。</li><li>它优先于对象存在，所以，可以被所有对象共享。  </li></ul></li></ul><img src="/2020/08/26/03.%E5%B8%B8%E7%94%A8API/Scanner_Random_ArrayList_String%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95_Arrays_Math_static%E5%85%B3%E9%94%AE%E5%AD%97/image-20200826224326792.png" alt="image-20200826224326792" style="zoom:57%;"><p><img src="/2020/08/26/03.%E5%B8%B8%E7%94%A8API/Scanner_Random_ArrayList_String%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95_Arrays_Math_static%E5%85%B3%E9%94%AE%E5%AD%97/03-%E9%9D%99%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h2 id="8-4-静态代码块"><a href="#8-4-静态代码块" class="headerlink" title="8.4 静态代码块"></a>8.4 静态代码块</h2><ul><li>静态代码块：定义在成员位置，使用static修饰的代码块{ }。<ul><li>位置：类中方法外。</li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li></ul></li></ul><p>格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用：给类变量进行初始化赋值。  </p><p>static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Scanner类&lt;/li&gt;
&lt;li&gt;Random类&lt;/li&gt;
&lt;li&gt;ArrayList类&lt;/li&gt;
&lt;li&gt;Strin</summary>
      
    
    
    
    <category term="常用API" scheme="https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"/>
    
    
    <category term="Scanner类" scheme="https://mrchen229.github.io/tags/Scanner%E7%B1%BB/"/>
    
    <category term="Random类" scheme="https://mrchen229.github.io/tags/Random%E7%B1%BB/"/>
    
    <category term="ArrayList类" scheme="https://mrchen229.github.io/tags/ArrayList%E7%B1%BB/"/>
    
    <category term="String类的常用方法" scheme="https://mrchen229.github.io/tags/String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
    <category term="Arrays类的方法" scheme="https://mrchen229.github.io/tags/Arrays%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
    <category term="Math类" scheme="https://mrchen229.github.io/tags/Math%E7%B1%BB/"/>
    
    <category term="static变量_static方法_static代码块" scheme="https://mrchen229.github.io/tags/static%E5%8F%98%E9%87%8F-static%E6%96%B9%E6%B3%95-static%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>类与对象_对象内存图_封装_this_构造_JavaBean</title>
    <link href="https://mrchen229.github.io/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/"/>
    <id>https://mrchen229.github.io/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/</id>
    <published>2020-08-26T07:52:08.000Z</published>
    <updated>2020-08-26T07:53:14.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>面向对象</li><li>类与对象</li><li>对象内存图</li><li>封装</li><li>private、this关键字</li><li>构造方法</li><li>JavaBean</li></ul><h1 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h1><h2 id="1-1-面向对象思想概述"><a href="#1-1-面向对象思想概述" class="headerlink" title="1.1 面向对象思想概述"></a>1.1 面向对象思想概述</h2><p>​        Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。  </p><blockquote><p>区别:</p><ul><li>面向过程：强调步骤。</li><li>面向对象：强调对象。</li></ul><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特征，即封装、继承和多态。  </p></blockquote><h2 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h2><ul><li>1.类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</li></ul><blockquote><p>现实中，描述一类事物：</p><ul><li>属性：就是该事物的状态信息。</li><li>行为：就是该事物能够做什么。</li></ul><p>举例：小猫。</p><p>​        属性：名字、体重、年龄、颜色。 行为：走、跑、叫。</p></blockquote><ul><li>2.对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。</li></ul><blockquote><p>举例：一只小猫。</p><p>​        属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。</p></blockquote><ul><li>3.类与对象的关系<ul><li>类是对一类事物的描述，是<strong>抽象</strong>的。</li><li>对象是一类事物的实例，是<strong>具体</strong>的。</li><li><strong>类是对象的模板，对象是类的实体。</strong>  </li></ul></li></ul><h2 id="1-3-类的定义"><a href="#1-3-类的定义" class="headerlink" title="1.3 类的定义"></a>1.3 类的定义</h2><blockquote><p>事物与类的对比 :<br>现实世界的一类事物：<br>        属性：事物的状态信息。 行为：事物能够做什么。</p></blockquote><p>Java中用class描述事物也是如此：<br>        <strong>成员变量</strong>：对应事物的属性 <strong>成员方法</strong>：对应事物的行为  </p><h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>定义类</strong>：就是定义类的成员，包括成员变量和成员方法。</li><li><strong>成员变量</strong>：和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外</strong>。</li><li><strong>成员方法</strong>：和以前定义方法几乎是一样的。只不过把static去掉，static的作用在面向对象后面课程中再详细讲解。  </li></ul><h2 id="1-4-对象的使用"><a href="#1-4-对象的使用" class="headerlink" title="1.4 对象的使用"></a>1.4 对象的使用</h2><h3 id="对象的使用格式"><a href="#对象的使用格式" class="headerlink" title="对象的使用格式"></a>对象的使用格式</h3><p>创建对象：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><p>使用对象访问类中的成员:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员变量；</span><br><span class="line">对象名.成员方法()；</span><br></pre></td></tr></table></figure><h3 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h3><table><thead><tr><th></th><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>基本类型</td><td>整数（byte，short，int，long）</td><td>0</td></tr><tr><td></td><td>浮点数（float，double）</td><td>0.0</td></tr><tr><td></td><td>字符（char）</td><td>‘\u0000’</td></tr><tr><td></td><td>布尔（boolean）</td><td>false</td></tr><tr><td>引用类型</td><td>数组，类，接口</td><td>null</td></tr></tbody></table><h2 id="1-5-对象内存图"><a href="#1-5-对象内存图" class="headerlink" title="1.5 对象内存图"></a>1.5 对象内存图</h2><h3 id="一个对象，调用一个方法内存图"><a href="#一个对象，调用一个方法内存图" class="headerlink" title="一个对象，调用一个方法内存图"></a>一个对象，调用一个方法内存图</h3><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/image-20200826144312020.png" alt="image-20200826144312020" style="zoom: 60%;"><p><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/01-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><blockquote><p>通过上图，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。</p><p>但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。  </p><p>补充：图中的X是指方法调用完出栈。</p></blockquote><h3 id="两个对象，调用同一方法内存图"><a href="#两个对象，调用同一方法内存图" class="headerlink" title="两个对象，调用同一方法内存图"></a>两个对象，调用同一方法内存图</h3><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/image-20200826144913139.png" alt="image-20200826144913139" style="zoom:60%;"><p><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/02-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><blockquote><p>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。  </p><p>补充：图中的X是指方法调用完出栈。</p></blockquote><h3 id="两个引用指向同一对象的内存图"><a href="#两个引用指向同一对象的内存图" class="headerlink" title="两个引用指向同一对象的内存图"></a>两个引用指向同一对象的内存图</h3><p><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/03-%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h3 id="一个引用，作为参数传递到方法中内存图"><a href="#一个引用，作为参数传递到方法中内存图" class="headerlink" title="一个引用，作为参数传递到方法中内存图"></a>一个引用，作为参数传递到方法中内存图</h3><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/image-20200826151305815.png" alt="image-20200826151305815" style="zoom:50%;"><blockquote><p>引用类型作为参数，传递的是地址值。  </p></blockquote><h3 id="使用对象类型作为方法的参数"><a href="#使用对象类型作为方法的参数" class="headerlink" title="使用对象类型作为方法的参数"></a>使用对象类型作为方法的参数</h3><p><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/04-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0.png"></p><h3 id="使用对象类型作为方法的返回值"><a href="#使用对象类型作为方法的返回值" class="headerlink" title="使用对象类型作为方法的返回值"></a>使用对象类型作为方法的返回值</h3><p><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/05-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC.png"></p><h2 id="1-6-成员变量和局部变量区别"><a href="#1-6-成员变量和局部变量区别" class="headerlink" title="1.6 成员变量和局部变量区别"></a>1.6 成员变量和局部变量区别</h2><p>​        变量根据定义位置的不同，我们给变量起了不同的名字。如下图所示：  </p><img src="/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/image-20200826152645429.png" alt="image-20200826152645429" style="zoom:30%;"><ul><li>在类中的位置不同 <code>重点</code><ul><li>成员变量：类中，方法外</li><li>局部变量：方法中或者方法声明上(形式参数)</li></ul></li><li>作用范围不一样 <code>重点</code><ul><li>成员变量：类中</li><li>局部变量：方法中</li></ul></li><li>初始化值的不同 <code>重点</code><ul><li>成员变量：有默认值</li><li>局部变量：没有默认值。必须先定义，赋值，最后使用</li></ul></li><li>在内存中的位置不同 <ul><li>成员变量：堆内存</li><li>局部变量：栈内存</li></ul></li><li>生命周期不同<ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失  </li></ul></li></ul><h1 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h1><h2 id="2-1-封装概述"><a href="#2-1-封装概述" class="headerlink" title="2.1 封装概述"></a>2.1 封装概述</h2><p>​        面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><blockquote><p>原则<br>将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。  </p></blockquote><h2 id="2-2-封装的步骤"><a href="#2-2-封装的步骤" class="headerlink" title="2.2 封装的步骤"></a>2.2 封装的步骤</h2><ol><li>使用 <code>private</code> 关键字来修饰成员变量。</li><li>对需要访问的成员变量，提供对应的一对 <code>getXxx</code> 方法 、 <code>setXxx</code> 方法。  </li></ol><h2 id="2-3-封装的操作——private关键字"><a href="#2-3-封装的操作——private关键字" class="headerlink" title="2.3 封装的操作——private关键字"></a>2.3 封装的操作——private关键字</h2><h3 id="private的含义"><a href="#private的含义" class="headerlink" title="private的含义"></a>private的含义</h3><ol><li>private是一个权限修饰符，代表最小权限。</li><li>可以修饰成员变量和成员方法。</li><li>被private修饰后的成员变量和成员方法，只在本类中才能访问。</li></ol><h3 id="private的使用格式"><a href="#private的使用格式" class="headerlink" title="private的使用格式"></a>private的使用格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 数据类型 变量名 ；</span><br></pre></td></tr></table></figure><h2 id="2-4-封装优化1——this关键字"><a href="#2-4-封装优化1——this关键字" class="headerlink" title="2.4 封装优化1——this关键字"></a>2.4 封装优化1——this关键字</h2><blockquote><p>我们发现 setXxx 方法中的形参名字并不符合见名知意的规定，那么如果修改与成员变量名一致，是否就见名知意了呢？  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经过修改和测试，我们发现新的问题，成员变量赋值失败了。也就是说，在修改了 setXxx() 的形参变量名后，方法并没有给成员变量赋值！这是由于<strong>形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败</strong>。所以，我们只能使用this关键字，来解决这个重名问题。  </p></blockquote><h3 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a>this的含义</h3><p>​        this代表所在类的当前对象的引用（地址值），即对象自己的引用。</p><blockquote><p>记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p></blockquote><h3 id="this使用格式"><a href="#this使用格式" class="headerlink" title="this使用格式"></a>this使用格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名</span><br></pre></td></tr></table></figure><blockquote><p><strong>方法</strong>中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。  </p></blockquote><h2 id="2-5-封装优化2——构造方法"><a href="#2-5-封装优化2——构造方法" class="headerlink" title="2.5 封装优化2——构造方法"></a>2.5 封装优化2——构造方法</h2><p>​        当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p><blockquote><p>小贴士：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，<br>一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。</p></blockquote><h3 id="构造方法的定义格式"><a href="#构造方法的定义格式" class="headerlink" title="构造方法的定义格式"></a>构造方法的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 构造方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型。  </p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>如果你不提供构造方法，系统会给出无参数构造方法。</li><li>如果你提供了构造方法，系统将不再提供无参数构造方法。</li><li>构造方法是可以重载的，既可以定义参数，也可以不定义参数。  </li></ol><h2 id="2-6-标准代码——JavaBean"><a href="#2-6-标准代码——JavaBean" class="headerlink" title="2.6 标准代码——JavaBean"></a>2.6 标准代码——JavaBean</h2><p>​        JavaBean 是 Java语言编写类的一种标准规范。</p><p>​        符合 JavaBean 的类，<strong>要求类必须是具体的和公共的，并且具有无参数的构造方法</strong>，<strong>提供用来操作成员变量的 set 和 get 方法</strong>。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="comment">//无参构造方法【必须】</span></span><br><span class="line">    <span class="comment">//有参构造方法【建议】</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="comment">//getXxx()</span></span><br><span class="line">    <span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;类与对象&lt;/li&gt;
&lt;li&gt;对象内存图&lt;/li&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;priva</summary>
      
    
    
    
    <category term="面向对象和封装" scheme="https://mrchen229.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/"/>
    
    
    <category term="类与对象" scheme="https://mrchen229.github.io/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="对象内存图" scheme="https://mrchen229.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE/"/>
    
    <category term="封装private" scheme="https://mrchen229.github.io/tags/%E5%B0%81%E8%A3%85private/"/>
    
    <category term="this" scheme="https://mrchen229.github.io/tags/this/"/>
    
    <category term="构造" scheme="https://mrchen229.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="JavaBean" scheme="https://mrchen229.github.io/tags/JavaBean/"/>
    
  </entry>
  
  <entry>
    <title>一维数组定义_内存图_作为方法参数与返回值</title>
    <link href="https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <id>https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/</id>
    <published>2020-08-26T05:07:08.000Z</published>
    <updated>2020-08-26T05:13:02.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>一维数组定义与索引</li><li>一维数组内存图</li><li>一维数组常见操作</li><li>数组作为方法参数与返回值</li></ul><h1 id="1-数组定义和访问"><a href="#1-数组定义和访问" class="headerlink" title="1. 数组定义和访问"></a>1. 数组定义和访问</h1><p>​        数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。  </p><h2 id="1-1-数组的定义"><a href="#1-1-数组的定义" class="headerlink" title="1.1 数组的定义"></a>1.1 数组的定义</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组存储的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br><span class="line">eg:  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li>数组定义格式详解：<ul><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</li><li>[] : 表示数组。</li><li>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</li><li>new：关键字，创建数组使用的关键字。</li><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</li><li>[长度]：数组的长度，表示数组容器中可以存储多少个元素。</li><li>注意：数组有定长特性，长度一旦指定，不可更改。<ul><li>和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。  </li></ul></li></ul></li></ul><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br><span class="line">eg:  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br><span class="line">eg:  <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-数组的访问"><a href="#1-2-数组的访问" class="headerlink" title="1.2 数组的访问"></a>1.2 数组的访问</h2><ul><li><p><strong>索引</strong>： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为<strong>数组索引</strong>(index)，可以通过数组的索引访问到数组中的元素。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure></li><li><p><strong>数组的长度属性</strong>： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度</p><p>语句为： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.length ，属性length的执行结果是数组的长度，<span class="keyword">int</span>类型结果。由此可以推断出，数组的最大索引值为 数组名.length-<span class="number">1</span> 。 </span><br></pre></td></tr></table></figure></li><li><p><strong>索引访问数组中的元素</strong>：</p><ul><li>数组名[索引]=数值，为数组中的元素赋值</li><li>变量=数组名[索引]，取出数组中的元素</li></ul></li></ul><h1 id="2-数组原理内存图"><a href="#2-数组原理内存图" class="headerlink" title="2. 数组原理内存图"></a>2. 数组原理内存图</h1><h2 id="2-1-内存概述"><a href="#2-1-内存概述" class="headerlink" title="2.1 内存概述"></a>2.1 内存概述</h2><p>​        内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。<br>​        Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。  </p><h2 id="2-2-Java虚拟机的内存划分"><a href="#2-2-Java虚拟机的内存划分" class="headerlink" title="2.2 Java虚拟机的内存划分"></a>2.2 Java虚拟机的内存划分</h2><p>​        为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。  </p><ul><li><p>JVM的内存划分：</p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和我们开发无关。</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关。</td></tr><tr><td>方法区</td><td>存储可以运行的class文件。</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存。</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行</td></tr></tbody></table></li></ul><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/01-Java中的内存划分.png" style="zoom: 80%;"><h2 id="2-3-数组在内存中的存储"><a href="#2-3-数组在内存中的存储" class="headerlink" title="2.3 数组在内存中的存储"></a>2.3 数组在内存中的存储</h2><h3 id="一个数组内存图"><a href="#一个数组内存图" class="headerlink" title="一个数组内存图"></a>一个数组内存图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr);<span class="comment">//[I@5f150435</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。<br>​        输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素  </p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/image-20200826123327456.png" alt="image-20200826123327456" style="zoom: 50%;"><p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/02-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h3 id="两个数组内存图"><a href="#两个数组内存图" class="headerlink" title="两个数组内存图"></a>两个数组内存图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">    System.out.println(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/image-20200826124028353.png" alt="image-20200826124028353" style="zoom:50%;"><p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/03-%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%8B%AC%E7%AB%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h3 id="两个引用指向一个数组"><a href="#两个引用指向一个数组" class="headerlink" title="两个引用指向一个数组"></a>两个引用指向一个数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//数组索引进行赋值</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//输出3个索引上的元素值</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2</span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = arr;</span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/image-20200826124254364.png" alt="image-20200826124254364" style="zoom:50%;"><p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/04-%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h1 id="3-数组的常见操作"><a href="#3-数组的常见操作" class="headerlink" title="3. 数组的常见操作"></a>3. 数组的常见操作</h1><h2 id="3-1-数组越界异常"><a href="#3-1-数组越界异常" class="headerlink" title="3.1 数组越界异常"></a>3.1 数组越界异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 <code>ArrayIndexOutOfBoundsException</code> 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。  </p><h2 id="3-2-数组空指针异常"><a href="#3-2-数组空指针异常" class="headerlink" title="3.2 数组空指针异常"></a>3.2 数组空指针异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>​        <code>arr = null</code> 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。  </p><p><strong>空指针异常在内存图中的表现</strong></p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/image-20200826125141433.png" alt="image-20200826125141433" style="zoom:50%;"><h2 id="3-3-数组长度运行期间不可改变"><a href="#3-3-数组长度运行期间不可改变" class="headerlink" title="3.3 数组长度运行期间不可改变"></a>3.3 数组长度运行期间不可改变</h2><p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/05-%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98.png"></p><h2 id="3-4-数组遍历"><a href="#3-4-数组遍历" class="headerlink" title="3.4 数组遍历"></a>3.4 数组遍历</h2><p>数组遍历： 就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-数组获取最大值元素"><a href="#3-5-数组获取最大值元素" class="headerlink" title="3.5 数组获取最大值元素"></a>3.5 数组获取最大值元素</h2><ul><li><p>最大值获取：从数组的所有元素中找出最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;;</span><br><span class="line">    <span class="comment">//定义变量，保存数组中0索引的元素</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//遍历数组，取出每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历到的元素和变量max比较</span></span><br><span class="line">        <span class="comment">//如果数组元素大于max</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            <span class="comment">//max记录住大值</span></span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(<span class="string">&quot;数组最大值是： &quot;</span> + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-6-数组反转"><a href="#3-6-数组反转" class="headerlink" title="3.6 数组反转"></a>3.6 数组反转</h2><ul><li>数组的反转： 数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1  </li></ul><p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/07-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC%E7%9A%84%E6%80%9D%E8%B7%AF.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        循环中定义变量min=0最小索引</span></span><br><span class="line"><span class="comment">        max=arr.length‐1最大索引</span></span><br><span class="line"><span class="comment">        min++,max‐‐</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐) &#123;</span><br><span class="line">        <span class="comment">//利用第三方变量完成数组中的元素交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">        arr[min] = arr[max];</span><br><span class="line">        arr[max] = temp;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 反转后，遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-数组作为方法参数和返回值"><a href="#4-数组作为方法参数和返回值" class="headerlink" title="4. 数组作为方法参数和返回值"></a>4. 数组作为方法参数和返回值</h1><h2 id="4-1-数组作为方法参数"><a href="#4-1-数组作为方法参数" class="headerlink" title="4.1 数组作为方法参数"></a>4.1 数组作为方法参数</h2><ul><li><p>**数组作为方法参数传递，传递的参数是数组内存的地址。  **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">       <span class="comment">//调用方法，传递数组</span></span><br><span class="line">       printArray(arr);</span><br><span class="line">   &#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       创建方法，方法接收数组类型的参数</span></span><br><span class="line"><span class="comment">       进行数组的遍历</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           System.out.println(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/image-20200826125943906.png" alt="image-20200826125943906" style="zoom: 50%;"></li></ul><h2 id="4-2-数组作为方法返回值"><a href="#4-2-数组作为方法返回值" class="headerlink" title="4.2 数组作为方法返回值"></a>4.2 数组作为方法返回值</h2><ul><li><p>数组作为方法的返回值，返回的是<strong>数组的内存地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用方法，接收数组的返回值</span></span><br><span class="line">    <span class="comment">//接收到的是数组的内存地址</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = getArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建方法，返回值是数组类型</span></span><br><span class="line"><span class="comment">    return返回数组的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/image-20200826130219904.png" alt="image-20200826130219904" style="zoom: 67%;"></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote><p>方法的参数为基本类型时,传递的是数据值。 </p><p>方法的参数为引用类型时,传递的是地址值.  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一维数组定义与索引&lt;/li&gt;
&lt;li&gt;一维数组内存图&lt;/li&gt;
&lt;li&gt;一维数组常见操作&lt;/li&gt;
&lt;li&gt;数组作为方法</summary>
      
    
    
    
    <category term="Java基础" scheme="https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="一维数组定义与索引" scheme="https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
    
    <category term="一维数组内存图" scheme="https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE/"/>
    
    <category term="数组作为方法参数与返回值" scheme="https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    
    <category term="数组常见操作" scheme="https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>IDEA使用_方法重载与执行</title>
    <link href="https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    <id>https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/</id>
    <published>2020-08-26T02:50:08.000Z</published>
    <updated>2020-08-26T02:51:49.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>IDEA使用</li><li>定义方法与方法重载</li></ul><h1 id="1-IDEA"><a href="#1-IDEA" class="headerlink" title="1. IDEA"></a>1. IDEA</h1><blockquote><p> 回顾一下开发Java程序的步骤：</p><ol><li>编写代码</li><li>启动cmd</li><li>调用javac编译</li><li>调用java运行</li></ol><p>集成开发环境，是一种专门用来提高Java开发效率的软件。</p><p>​    免费的IDE当中：Eclipse<br>​    收费的IDE当中：IntelliJ IDEA<br>免费+收费所有的IDE当中：全世界用得最多的就是IntelliJ IDEA</p></blockquote><p>IDEA是一个专门针对Java的集成开发工具(IDE)，由Java语言编写。所以，需要有JRE运行环境并配置好环境变量。它可以极大地提升我们的开发效率。可以自动编译，检查错误。  </p><blockquote><p>File-&gt;new-&gt;Project 创建Project选择java，并选择jdk的位置。</p><p>首次新建项目时，默认的Project Location路径有问题，如 c:\\xxx ，正确写法为 c:\xxx 。更改后不会再出现此类问题。  </p></blockquote><h2 id="1-1-创建包和类"><a href="#1-1-创建包和类" class="headerlink" title="1.1 创建包和类"></a>1.1 创建包和类</h2><p>展开创建的工程，在源代码目录 src 上，鼠标右键，选择 new-&gt;package ，键入包名。</p><blockquote><p>所谓包，就是文件夹，用来对类文件进行管理。  </p></blockquote><p>在创建好的包上，鼠标右键，选择 new-&gt;class 创建类，键入类名。  </p><h2 id="1-2-字体设置"><a href="#1-2-字体设置" class="headerlink" title="1.2 字体设置"></a>1.2 字体设置</h2><p>File-&gt;Settings-&gt;Editor-&gt;Font 修改字体  </p><h2 id="1-3-IDEA的项目目录"><a href="#1-3-IDEA的项目目录" class="headerlink" title="1.3 IDEA的项目目录"></a>1.3 IDEA的项目目录</h2><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/02-IDEA的项目结构.png" style="zoom:50%;"><ul><li>我们创建的项目，在project目录的文件夹下<ul><li>.idea 目录和 demo.iml 和我们开发无关，是IDEA工具自己使用的</li><li>out 目录是存储编译后的.class文件</li><li>src 目录是存储我们编写的.java源文件  </li></ul></li></ul><h2 id="1-4-IDEA常用快捷键"><a href="#1-4-IDEA常用快捷键" class="headerlink" title="1.4 IDEA常用快捷键"></a>1.4 IDEA常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Alt+Enter</td><td>导入包，自动修正代码</td></tr><tr><td>Ctrl+Y</td><td>删除光标所在行</td></tr><tr><td>Ctrl+D</td><td>复制光标所在行的内容，插入光标位置下面</td></tr><tr><td>Ctrl+Alt+L</td><td>格式化代码</td></tr><tr><td>Ctrl+/</td><td>单行注释</td></tr><tr><td>Ctrl+Shift+/</td><td>选中代码注释，多行注释，再按取消注释</td></tr><tr><td>Alt+i</td><td>自动生成代码，toString，get，set等方法</td></tr><tr><td>Alt+Shift+上下箭头</td><td>移动当前代码行</td></tr></tbody></table><h2 id="1-5-IDEA修改快捷键"><a href="#1-5-IDEA修改快捷键" class="headerlink" title="1.5 IDEA修改快捷键"></a>1.5 IDEA修改快捷键</h2><p>​        在IDEA工具中， Ctrl+空格 的快捷键，可以帮助我们补全代码，但是这个快捷键和Windows中的输入法切换快捷键冲突，需要修改IDEA中的快捷键。<br>1.<code>File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic  </code></p><p>2.双击 <code>Basic-&gt;选择remove Ctrl+空格 </code> </p><p>3.再次双击 <code>Basic-&gt;Add Keyboard-&gt;键入 Alt+/-&gt;点击OK</code></p><h2 id="1-6-IDEA导入和关闭项目"><a href="#1-6-IDEA导入和关闭项目" class="headerlink" title="1.6 IDEA导入和关闭项目"></a>1.6 IDEA导入和关闭项目</h2><p>​        关闭IDEA中已经存在的项目， <code>File-&gt;Close Project  </code></p><blockquote><p>File-&gt;Close Project 这时IDEA回到了刚启动界面，点击项目上的 X ，IDEA中就没有这个项目了  </p><p>若要打开，在IDEA的启动界面上，点击 OPEN ，选择项目目录即可  </p></blockquote><h1 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h1><h2 id="2-1-定义方法的格式"><a href="#2-1-定义方法的格式" class="headerlink" title="2.1 定义方法的格式"></a>2.1 定义方法的格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">//代码省略...</span></span><br><span class="line">    <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰符： public static 固定写法<ul><li>返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者</li><li>参数列表：方法在运算过程中的未知数据，调用者调用方法时传递</li><li>return：将方法执行后的结果带给调用者，方法执行到 return ，整体方法运行结束</li></ul></li></ul><blockquote><p>return 结果; 正确的叫法为方法的返回值  </p></blockquote><h2 id="2-2-定义方法的两个明确"><a href="#2-2-定义方法的两个明确" class="headerlink" title="2.2 定义方法的两个明确"></a>2.2 定义方法的两个明确</h2><ul><li>需求：定义方法实现两个整数的求和计算。<ul><li><strong>明确返回值类型</strong>：方法计算的是整数的求和，结果也必然是个整数，返回值类型定义为int类型。</li><li><strong>明确参数列表</strong>：计算哪两个整数的和，并不清楚，但可以确定是整数，参数列表可以定义两个int类型的<br>变量，由调用者调用方法时传递  </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method_Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用方法getSum，传递两个整数，这里传递的实际数据又称为实际参数</span></span><br><span class="line">            <span class="comment">// 并接收方法计算后的结果，返回值</span></span><br><span class="line">            <span class="keyword">int</span> sum = getSum(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义</span></span><br><span class="line"><span class="comment">        计算两个整数和的方法</span></span><br><span class="line"><span class="comment">        返回值类型，计算结果是int</span></span><br><span class="line"><span class="comment">        参数：不确定数据求和，定义int参数.参数又称为形式参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序执行，主方法 main 调用 getSum 方法，传递了实际数据 5和6 ，两个变量 a和b 接收到的就是实际参数，并将计算后的结果返回，主方法 main 中的变量 sum 接收的就是方法的返回值。  </p></blockquote><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20200826103253441.png" alt="image-20200826103253441" style="zoom:50%;"><p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/03-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3.png"></p><h2 id="2-3-定义方法的注意事项"><a href="#2-3-定义方法的注意事项" class="headerlink" title="2.3 定义方法的注意事项"></a>2.3 定义方法的注意事项</h2><blockquote><p>定义位置，类中方法外面。<br>返回值类型，必须要和 return 语句返回的类型相同，否则编译失败 。  </p><p>不能在 return 后面写代码， return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。</p><p>不能用输出语句调用 void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。    </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型要求是int</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;<span class="comment">// 正确，int类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.2</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/04-方法返回值的有无.png" style="zoom: 67%;"><h2 id="2-4-方法重载"><a href="#2-4-方法重载" class="headerlink" title="2.4 方法重载"></a>2.4 方法重载</h2><ul><li><strong>方法重载</strong>：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。<ul><li>参数列表：<strong>个数不同，数据类型不同，顺序不同</strong>。</li><li>重载方法调用：JVM通过方法的参数列表，调用不同的方法。  </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;IDEA使用&lt;/li&gt;
&lt;li&gt;定义方法与方法重载&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-IDEA&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java基础" scheme="https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="IDEA使用" scheme="https://mrchen229.github.io/tags/IDEA%E4%BD%BF%E7%94%A8/"/>
    
    <category term="方法重载与执行" scheme="https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>判断_选择_循环</title>
    <link href="https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%88%A4%E6%96%AD_%E9%80%89%E6%8B%A9_%E5%BE%AA%E7%8E%AF/"/>
    <id>https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%88%A4%E6%96%AD_%E9%80%89%E6%8B%A9_%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-08-26T01:56:08.000Z</published>
    <updated>2020-08-26T01:56:54.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>判断语句</li><li>选择语句</li><li>循环语句</li></ul><h1 id="1-判断语句"><a href="#1-判断语句" class="headerlink" title="1. 判断语句"></a>1. 判断语句</h1><h2 id="1-1-if"><a href="#1-1-if" class="headerlink" title="1.1 if"></a>1.1 if</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)｛</span><br><span class="line">    语句体;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h2 id="1-2-if…else"><a href="#1-2-if…else" class="headerlink" title="1.2 if…else"></a>1.2 if…else</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-if-else-if…else"><a href="#1-3-if-else-if…else" class="headerlink" title="1.3 if..else if…else"></a>1.3 if..else if…else</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">    执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>) &#123;</span><br><span class="line">    执行语句<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">    执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-选择语句"><a href="#2-选择语句" class="headerlink" title="2. 选择语句"></a>2. 选择语句</h1><h2 id="2-1-switch"><a href="#2-1-switch" class="headerlink" title="2.1 switch"></a>2.1 switch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行流程<ul><li>首先计算出表达式的值</li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结<br>束。</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。  </li></ul></li></ul><blockquote><p>注意： switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。  </p></blockquote><h2 id="2-2-case的穿透性"><a href="#2-2-case的穿透性" class="headerlink" title="2.2 case的穿透性"></a>2.2 case的穿透性</h2><p>​        在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会再判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。  </p><h1 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h1><h2 id="3-1-for"><a href="#3-1-for" class="headerlink" title="3.1 for"></a>3.1 for</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;</span><br><span class="line">    循环体③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行流程</p><ul><li><p>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。</p><p>①负责完成循环变量初始化</p><p>②负责判断是否满足循环条件，不满足则跳出循环</p><p>③具体执行的语句</p><p>④循环后，循环条件所涉及变量的变化情况  </p></li></ul></li></ul><h2 id="3-2-while"><a href="#3-2-while" class="headerlink" title="3.2 while"></a>3.2 while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行流程</p><ul><li><p>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。</p><p>①负责完成循环变量初始化。</p><p>②负责判断是否满足循环条件，不满足则跳出循环。</p><p>③具体执行的语句。</p><p>④循环后，循环变量的变化情况。</p></li></ul></li></ul><h2 id="3-3-do…while"><a href="#3-3-do…while" class="headerlink" title="3.3 do…while"></a>3.3 do…while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure><ul><li>执行流程<ul><li>执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。<br>①负责完成循环变量初始化。<br>②负责判断是否满足循环条件，不满足则跳出循环。<br>③具体执行的语句<br>④循环后，循环变量的变化情况  </li></ul></li></ul><blockquote><p>do…while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。  </p></blockquote><h2 id="3-4-for-和-while-的小区别"><a href="#3-4-for-和-while-的小区别" class="headerlink" title="3.4 for 和 while 的小区别"></a>3.4 for 和 while 的小区别</h2><ul><li>for所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。</li><li>在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</li></ul><h2 id="3-5-跳出语句"><a href="#3-5-跳出语句" class="headerlink" title="3.5 跳出语句"></a>3.5 跳出语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><ul><li>使用场景：终止switch或者循环<ul><li>在选择结构switch语句中</li><li>在循环语句中</li><li>离开使用场景的存在是没有意义的   </li></ul></li></ul><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><ul><li>使用场景：结束本次循环，继续下一次的循环  </li></ul><h1 id="4-扩展知识点"><a href="#4-扩展知识点" class="headerlink" title="4. 扩展知识点"></a>4. 扩展知识点</h1><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><p>​        死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。例如：while(true){}。  </p><h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①; 循环条件②; 步进表达式⑦) &#123;</span><br><span class="line">    <span class="keyword">for</span>(初始化表达式③; 循环条件④; 步进表达式⑥) &#123;</span><br><span class="line">        执行语句⑤;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套循环执行流程：<ul><li>执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥<br>外循环一次，内循环多次。<br>比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。  </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;判断语句&lt;/li&gt;
&lt;li&gt;选择语句&lt;/li&gt;
&lt;li&gt;循环语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-判断语句&quot;&gt;</summary>
      
    
    
    
    <category term="Java基础" scheme="https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="判断语句" scheme="https://mrchen229.github.io/tags/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"/>
    
    <category term="选择语句" scheme="https://mrchen229.github.io/tags/%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"/>
    
    <category term="循环语句" scheme="https://mrchen229.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>数据类型转换_运算符_方法定义</title>
    <link href="https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2_%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"/>
    <id>https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2_%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/</id>
    <published>2020-08-26T01:17:08.000Z</published>
    <updated>2020-08-26T01:17:27.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>数据类型间的自动转换与强制转换</li><li>算数、比较、逻辑、三元运算符( 注意+= )</li><li>方法定义</li></ul><h1 id="1-数据类型之间的转换"><a href="#1-数据类型之间的转换" class="headerlink" title="1.数据类型之间的转换"></a>1.数据类型之间的转换</h1><p>​        Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p><h2 id="1-1-自动转换"><a href="#1-1-自动转换" class="headerlink" title="1.1 自动转换"></a>1.1 自动转换</h2><p>一个 int 类型变量和一个 byte 类型变量进行加法运算， 结果是什么数据类型？<br>        运算结果，变量的类型将是 int 类型，这就是出现了数据类型的自动类型转换现象。</p><p><strong>自动转换</strong>：将取值范围小的类型自动提升为取值范围大的类型 。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>; <span class="comment">// 一个byte是8位，范围-128-127</span></span><br><span class="line"><span class="comment">// byte x = b + i; // 报错</span></span><br><span class="line"><span class="comment">// int类型和byte类型运算，结果是int类型</span></span><br><span class="line"><span class="keyword">int</span> j = b + i;</span><br></pre></td></tr></table></figure><h3 id="转换原理图解"><a href="#转换原理图解" class="headerlink" title="转换原理图解"></a>转换原理图解</h3><p>​        byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。  </p><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2_%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/image-20200825154656288.png" alt="image-20200825154656288" style="zoom: 50%;"><p>同样道理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.5</span>;</span><br><span class="line"><span class="comment">//int类型和double类型运算，结果是double类型</span></span><br><span class="line"><span class="comment">//int类型会提升为double类型</span></span><br><span class="line"><span class="keyword">double</span> e = d+i;</span><br></pre></td></tr></table></figure><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>​        范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">char</span>‐‐&gt;<span class="keyword">int</span>‐‐&gt;<span class="keyword">long</span>‐‐&gt;<span class="keyword">float</span>‐‐&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure><h2 id="1-2-强制转换"><a href="#1-2-强制转换" class="headerlink" title="1.2 强制转换"></a>1.2 强制转换</h2><p>​        将 1.5 赋值到 int 类型变量会发生什么？产生编译失败，肯定无法赋值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1.5</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>​        double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。可以理解为 double 是8升的水壶， int 是4升的水壶，不能把大水壶中的水直接放进小水壶去。</p><p>​        想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。</p><ul><li>强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。</li></ul><p>比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。</p><p>​        转换格式：  <code> 数据类型 变量名 = （数据类型）被转数据值; </code></p><p>​        </p><p>将 1.5 赋值到 int 类型，代码修改为：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double类型数据强制转成int类型，直接去掉小数点。</span></span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="number">1.5</span>;</span><br></pre></td></tr></table></figure><p>​        同样道理，当一个 short 类型与 1 相加，若想将结果赋值给short类型变量，就需要强制转换。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//short类型变量，内存中2个字节</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    出现编译失败</span></span><br><span class="line"><span class="comment">    s和1做运算的时候，1是int类型，s会被提升为int类型</span></span><br><span class="line"><span class="comment">    s+1后的结果是int类型，将结果在赋值会short类型时发生错误</span></span><br><span class="line"><span class="comment">    short内存2个字节，int类型4个字节</span></span><br><span class="line"><span class="comment">    必须将int强制转成short才能完成赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s = s + <span class="number">1</span>；<span class="comment">//编译失败</span></span><br><span class="line">s = (<span class="keyword">short</span>)(s+<span class="number">1</span>);<span class="comment">//编译成功</span></span><br></pre></td></tr></table></figure><h3 id="转换原理图解-1"><a href="#转换原理图解-1" class="headerlink" title="转换原理图解"></a>转换原理图解</h3><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2_%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/image-20200825155512475.png" alt="image-20200825155512475" style="zoom: 50%;"><img src="/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2_%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/01-强制类型转换的数据溢出问题.png" style="zoom:50%;"><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>浮点转成整数，直接取消小数点，可能造成数据损失精度。</li><li>int 强制转成 short 砍掉2个字节，可能造成数据丢失  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义s为short范围内最大值</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">32767</span>;</span><br><span class="line"><span class="comment">// 运算后，强制转换，砍掉2个字节后会出现不确定的结果</span></span><br><span class="line">s = (<span class="keyword">short</span>)(s + <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="1-3-ASCII编码表"><a href="#1-3-ASCII编码表" class="headerlink" title="1.3 ASCII编码表"></a>1.3 ASCII编码表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符类型变量</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//字符类型和int类型计算</span></span><br><span class="line">    System.out.println(c+i);<span class="comment">//输出结果是98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。<br>        编码表 ：就是将人类的文字和一个十进制数进行对应起来组成一张表格。  见ASCII表</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>0</td><td>48</td></tr><tr><td>9</td><td>57</td></tr><tr><td>A</td><td>65</td></tr><tr><td>Z</td><td>90</td></tr><tr><td>a</td><td>97</td></tr><tr><td>z</td><td>122</td></tr></tbody></table><blockquote><p>在char类型和int类型计算的过程中，char类型的字符先查询编码表，得到97，再和1求和，结果为98。char类型提升为int类型。char类型内存2个字节，int类型内存4个字节。  </p></blockquote><h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h1><h2 id="2-1-算数运算符"><a href="#2-1-算数运算符" class="headerlink" title="2.1 算数运算符"></a>2.1 算数运算符</h2><table><thead><tr><th>算数运算符包括：</th><th></th></tr></thead><tbody><tr><td>+</td><td>加法运算，字符串连接运算</td></tr><tr><td>-</td><td>减法运算</td></tr><tr><td>*</td><td>乘法运算</td></tr><tr><td>/</td><td>除法运算</td></tr><tr><td>%</td><td>取模运算，两个数字相除取余数</td></tr><tr><td>++ 、 –</td><td>自增自减运算</td></tr></tbody></table><p>Java中，整数使用以上运算符，无论怎么计算，也不会得到小数。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1234</span>;</span><br><span class="line">System.out.println(i/<span class="number">1000</span>*<span class="number">1000</span>);<span class="comment">//计算结果是1000</span></span><br></pre></td></tr></table></figure><ul><li><p><code>++</code> 运算，变量自己增长1。反之， <code>--</code> 运算，变量自己减少1，用法与 <code>++</code> 一致。</p><ul><li><p>独立运算：</p><ul><li>变量在独立运算时， 前++ 和 后++ 没有区别 。</li></ul></li><li><p>混合运算：</p><ul><li><p>和其他变量放在一起， 前++ 和 后++ 就产生了不同。</p></li><li><p>变量++ ：</p><p>即 <code>a=1;  b=a++; </code> 得到a为 2，b为1。</p></li><li><p>++变量 : </p><p>即 <code>a=1;  b=++a; </code> 得到a为 2，b为2。</p></li></ul></li></ul></li><li><p>+ 符号在字符串中的操作：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 符号在遇到字符串的时候，表示连接、拼接的含义。</span><br><span class="line">    <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>的结果是“ab”，连接含义</span><br><span class="line">    System.out.println(<span class="string">&quot;5+5=&quot;</span>+<span class="number">5</span>+<span class="number">5</span>);<span class="comment">//输出5+5=55</span></span><br></pre></td></tr></table></figure><h2 id="2-2-赋值运算符"><a href="#2-2-赋值运算符" class="headerlink" title="2.2 赋值运算符"></a>2.2 赋值运算符</h2><table><thead><tr><th>赋值运算符包括：</th><th></th></tr></thead><tbody><tr><td>=</td><td>等于号</td></tr><tr><td>+=</td><td>加等于</td></tr><tr><td>-=</td><td>减等于</td></tr><tr><td>*=</td><td>乘等于</td></tr><tr><td>/=</td><td>除等于</td></tr><tr><td>%=</td><td>取模等</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg : </span><br><span class="line">    i+=<span class="number">5</span>;<span class="comment">//计算方式 i=i+5 变量i先加5，再赋值变量i</span></span><br></pre></td></tr></table></figure><h2 id="2-3-比较运算符"><a href="#2-3-比较运算符" class="headerlink" title="2.3 比较运算符"></a>2.3 比较运算符</h2><table><thead><tr><th>比较运算符包括：</th><th></th></tr></thead><tbody><tr><td>==</td><td>比较符号两边数据是否相等，相等结果是true。</td></tr><tr><td>&lt;</td><td>比较符号左边的数据是否小于右边的数据，如果小于结果是true。</td></tr><tr><td>&gt;</td><td>比较符号左边的数据是否大于右边的数据，如果大于结果是true。</td></tr><tr><td>&lt;=</td><td>比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。</td></tr><tr><td>&gt;=</td><td>比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。</td></tr><tr><td>！=</td><td>不等于符号 ，如果符号两边的数据不相等，结果是true。</td></tr></tbody></table><blockquote><p>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。  </p></blockquote><h2 id="2-4-逻辑运算符"><a href="#2-4-逻辑运算符" class="headerlink" title="2.4 逻辑运算符"></a>2.4 逻辑运算符</h2><table><thead><tr><th>逻辑运算符包括：</th><th></th></tr></thead><tbody><tr><td>&amp;&amp; 短路与</td><td>1. 两边都是true，结果是true<br>2. 一边是false，结果是false <br><strong>短路特点</strong>：符号左边是false，右边不再运算</td></tr><tr><td>|| 短路或</td><td>1. 两边都是false，结果是false <br>2. 一边是true，结果是true <br><strong>短路特点</strong>： 符号左边是true，右边不再运算</td></tr><tr><td>！ 取反</td><td>1. ! true 结果是false <br>2. ! false结果是true</td></tr></tbody></table><blockquote><p>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false  </p></blockquote><h2 id="2-5-三元运算符"><a href="#2-5-三元运算符" class="headerlink" title="2.5 三元运算符"></a>2.5 三元运算符</h2><ul><li><p>三元运算符格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 布尔类型表达式？结果<span class="number">1</span>：结果<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>三元运算符计算方式：<br>布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。<br>布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。  </p></li></ul><h1 id="3-方法入门"><a href="#3-方法入门" class="headerlink" title="3. 方法入门"></a>3. 方法入门</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul><li>方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。<br>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</li></ul><h2 id="3-2-方法的定义"><a href="#3-2-方法的定义" class="headerlink" title="3.2 方法的定义"></a>3.2 方法的定义</h2><p>定义格式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）｛</span><br><span class="line">    代码...</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><ul><li>定义格式解释：<ul><li>修饰符： 目前固定写法 public static 。  </li><li>返回值类型： 目前固定写法 void ，其他返回值类型在后面的课程讲解。</li><li>方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。</li><li>参数列表： 目前无参数， 带有参数的方法在后面的课程讲解。</li><li>return：方法结束。因为返回值类型是void，方法大括号内的return可以不写。 </li></ul></li></ul><h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><ul><li>方法定义注意事项：<ul><li>方法必须定义在一类中方法外</li><li>方法不能定义在另一个方法的里面  </li></ul></li></ul><h1 id="4-扩展知识点"><a href="#4-扩展知识点" class="headerlink" title="4. 扩展知识点"></a>4. 扩展知识点</h1><h2 id="符号"><a href="#符号" class="headerlink" title="+=符号"></a>+=符号</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line">    s+=<span class="number">1</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        分析： s += 1 逻辑上看作是 s = s + 1 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， s=s+1进行两次运算 ， += 是一个运算符，只运算一次，<strong>并带有强制转换的特点</strong>。</p><p>​        也就是说<strong>s += 1 就是 s = (short)(s + 1)</strong> ，因此程序没有问题编译通过，运行结果是2  </p><h2 id="常量和变量的运算"><a href="#常量和变量的运算" class="headerlink" title="常量和变量的运算"></a>常量和变量的运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">byte</span> b2=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">byte</span> b3=<span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">byte</span> b4=b1 + b2;</span><br><span class="line">    System.out.println(b3);</span><br><span class="line">    System.out.println(b4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 分析： b3 = 1 + 2 ， 1 和 2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 ，因此<strong>b3=1 + 2 是正确的</strong>。</p><p>​        反之， b4 = b2 + b3 ， b2 和 b3 是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b2+b3的结果是什<br>么，因此会将结果以int类型进行处理，所以int类型不能赋值给byte类型，因此编译失败。  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数据类型间的自动转换与强制转换&lt;/li&gt;
&lt;li&gt;算数、比较、逻辑、三元运算符( 注意+= )&lt;/li&gt;
&lt;li&gt;方法定</summary>
      
    
    
    
    <category term="Java基础" scheme="https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据类型转换" scheme="https://mrchen229.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="运算符细节" scheme="https://mrchen229.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%86%E8%8A%82/"/>
    
    <category term="方法定义" scheme="https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>进制_Java执行顺序_常量_数据类型</title>
    <link href="https://mrchen229.github.io/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://mrchen229.github.io/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-08-25T07:27:08.000Z</published>
    <updated>2020-08-26T01:14:41.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>进制转换</li><li>JVM JRE JDK关系</li><li>Java程序执行过程<ul><li>标识符的写法</li></ul></li><li>常量</li><li>变量的定义</li><li>基本数据类型的分类</li></ul><h1 id="1-计算机基础知识"><a href="#1-计算机基础知识" class="headerlink" title="1. 计算机基础知识"></a>1. 计算机基础知识</h1><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>​        计算机中全部采用二进制数表示数据，它只包含0、1，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特）。</p><p><strong>十进制数据转成二进制数据</strong></p><p>​        使用除以2获取余数的方式  </p><p><strong>二进制数据转成十进制数据</strong></p><p>​        使用8421编码的方式  </p><img src="/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/03-二进制与十进制的转换运算.png" style="zoom:67%;"><blockquote><p>二进制数系统中，每个0或1就是一个位，叫做bit（比特）。  </p></blockquote><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性可以查看文件的字节大小。</span><br><span class="line"></span><br><span class="line">8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。</span><br><span class="line">位（bit）：一个数字0或者一个数字1，代表一位。</span><br><span class="line">   字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。</span><br><span class="line"></span><br><span class="line">   1 Byte &#x3D; 8 bit</span><br><span class="line"></span><br><span class="line">   1 KB &#x3D; 1024 Byte</span><br><span class="line">   1 MB &#x3D; 1024 KB</span><br><span class="line">   1 GB &#x3D; 1024 MB</span><br><span class="line">   1 TB &#x3D; 1024 GB</span><br><span class="line">   1 PB &#x3D; 1024 TB</span><br><span class="line">   1 EB &#x3D; 1024 PB</span><br><span class="line">   1 ZB &#x3D; 1024 EB</span><br></pre></td></tr></table></figure><h3 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h3><table><thead><tr><th>命令</th><th>操作符号</th></tr></thead><tbody><tr><td>盘符切换命令</td><td>盘符名:</td></tr><tr><td>查看当前文件夹</td><td>dir</td></tr><tr><td>进入文件夹命令</td><td>cd 文件夹名  or  cd 文件夹1\文件夹2\文件夹3</td></tr><tr><td>返回上一级</td><td>cd ..</td></tr><tr><td>退出到磁盘根目录</td><td>cd \</td></tr><tr><td>清屏</td><td>cls</td></tr><tr><td>退出</td><td>exit</td></tr></tbody></table><h1 id="2-JVM-JRE-JDK"><a href="#2-JVM-JRE-JDK" class="headerlink" title="2. JVM JRE JDK"></a>2. JVM JRE JDK</h1><img src="/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/07-JDK&JRE&JVM关系示意图.png" style="zoom: 67%;"><h2 id="Java虚拟机——JVM"><a href="#Java虚拟机——JVM" class="headerlink" title="Java虚拟机——JVM"></a>Java虚拟机——JVM</h2><p>​        JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。<br>​        跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。  </p><img src="/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200825144101570.png" alt="image-20200825144101570" style="zoom: 33%;"><p>​        如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。  </p><h2 id="JRE-和-JDK"><a href="#JRE-和-JDK" class="headerlink" title="JRE 和 JDK"></a>JRE 和 JDK</h2><p>​        JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的核心类库 。<br>​        JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。</p><p>运行一个已有的Java程序，只需安装 JRE 即可。开发一个全新的Java程序，则必须安装 JDK 。  </p><p><img src="/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5Cjre%E4%B8%8Ejdk.jpg"></p><h1 id="3-Java程序执行过程"><a href="#3-Java程序执行过程" class="headerlink" title="3. Java程序执行过程"></a>3. Java程序执行过程</h1><p>Java程序开发三步骤：编写、编译、运行 。</p><img src="/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200825144813013.png" alt="image-20200825144813013" style="zoom:50%;"><h2 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h2><ol><li>新建文件，文件名修改为 xxx.java。</li><li>在文件中键入文本并保存：  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文件名必须是 xxx ，<strong>保证文件名和类的名字是一致的</strong>，注意大小写。</p></blockquote><p>​    此时需要将编写好的 Java源文件，编译成JVM可以看懂的字节码文件 。  </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。</p><p>​        命令：<code>javac Java源文件名.java </code></p><p>​        编译成功后，命令行没有任何提示。打开 Java源文件名对应的目录，发现产生了一个新的文件 xxx.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。</p><blockquote><p>Java源文件的编译工具 javac.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。  </p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。<br>        命令: <code>java 类名字  </code></p><blockquote><p>​        Java程序 .class文件 的运行工具 java.exe ，在JDK安装目录的bin目录下。由于配置了环境变量，可以再任意目录下使用。</p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>​        编译：是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。<br>​        运行：是指将 class文件交给JVM去运行，此时JVM就会去执行我们编写的程序了。</p><h3 id="关于main方法"><a href="#关于main方法" class="headerlink" title="关于main方法"></a>关于main方法</h3><p>​        main方法：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。  </p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>​        Java中有单行注释和多行注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单行注释以 &#x2F;&#x2F;开头 换行结束</span><br><span class="line">多行注释以 &#x2F;*开头 以*&#x2F;结束  </span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>​        标识符：是指在程序中自己定义的内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p><ul><li>命名规则： 硬性要求<ul><li>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。</li><li>标识符不能以数字开头。</li><li>标识符不能是关键字。</li></ul></li><li>命名规范： 软性建议<ul><li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</li><li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</li><li>变量名规范：全部小写。  </li></ul></li></ul><h1 id="4-常量"><a href="#4-常量" class="headerlink" title="4. 常量"></a>4. 常量</h1><p>​        常量：是指在Java程序中固定不变的数据。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table><thead><tr><th>类型</th><th>含义</th><th>数据举例</th></tr></thead><tbody><tr><td>整数常量</td><td>所有的整数</td><td>0，1， 567， -9</td></tr><tr><td>小数常量</td><td>所有的小数</td><td>0.0， -0.1， 2.55</td></tr><tr><td>字符常量</td><td>单引号引起来,只能写一个字符,必须有内容</td><td>‘a’ ， ‘ ‘， ‘好’</td></tr><tr><td>字符串常量</td><td>双引号引起来,可以写多个字符,也可以不写</td><td>“A” ，”Hello” ，”你好” ，””</td></tr><tr><td>布尔常量</td><td>只有两个值（流程控制中讲解）</td><td>true ， false</td></tr><tr><td>空常量</td><td>只有一个值（引用数据类型中讲解）</td><td>null</td></tr></tbody></table><h1 id="5-变量和数据类型"><a href="#5-变量和数据类型" class="headerlink" title="5. 变量和数据类型"></a>5. 变量和数据类型</h1><h2 id="变量概述"><a href="#变量概述" class="headerlink" title="变量概述"></a>变量概述</h2><p>​        变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。<br>Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。  </p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><p>Java的数据类型分为两大类：</p><ul><li>基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。<ul><li>引用数据类型：包括 类 、 数组 、 接口、字符串、lambda 。</li></ul></li></ul><blockquote><p>注意事项：</p><ol><li>字符串不是基本类型，而是引用类型。</li><li>浮点型可能只是一个近似值，并非精确的值。</li><li>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</li><li>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。<br>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。</li></ol></blockquote><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>​        四类八种基本数据类型：  </p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1个字节</td><td>-128~127</td></tr><tr><td>短整型</td><td>short</td><td>2个字节</td><td>-32768~32767</td></tr><tr><td>整型</td><td>int（默认）</td><td>4个字节</td><td>-231次方~2的31次方-1</td></tr><tr><td>长整型</td><td>long</td><td>8个字节</td><td>-2的63次方~2的63次方-1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4个字节</td><td>1.4013E-45~3.4028E+38</td></tr><tr><td>双精度浮点数</td><td>double（默认）</td><td>8个字节</td><td>4.9E-324~1.7977E+308</td></tr><tr><td>字符型</td><td>char</td><td>2个字节</td><td>0-65535</td></tr><tr><td>布尔类型</td><td>boolean</td><td>1个字节</td><td>true，false</td></tr></tbody></table><blockquote><p>Java中的默认类型：整数类型是 int 、浮点类型是 double 。  </p></blockquote><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值 。<br>        格式:  <code>数据类型 变量名 = 数据值;  </code></p><blockquote><p>​    long类型：建议数据后加L表示。<br>​    float类型：建议数据后加F表示  </p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>​        变量名称：在同一个大括号范围内，变量的名字不可以相同。<br>​        变量赋值：定义的变量，不赋值不能使用。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进制转换&lt;/li&gt;
&lt;li&gt;JVM JRE JDK关系&lt;/li&gt;
&lt;li&gt;Java程序执行过程&lt;ul&gt;
&lt;li&gt;标识符的</summary>
      
    
    
    
    <category term="Java基础" scheme="https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="进制转换" scheme="https://mrchen229.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="Java开发过程" scheme="https://mrchen229.github.io/tags/Java%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    
    <category term="常量与数据类型" scheme="https://mrchen229.github.io/tags/%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>springboot和thymeleaf</title>
    <link href="https://mrchen229.github.io/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/"/>
    <id>https://mrchen229.github.io/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/</id>
    <published>2020-08-14T08:58:31.000Z</published>
    <updated>2020-08-14T09:31:19.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>SpringBoot的作用</p></li><li><p>掌握java配置的方式</p></li><li><p>了解SpringBoot自动配置原理</p></li><li><p>掌握SpringBoot的基本使用</p></li><li><p>了解Thymeleaf的基本使用</p></li><li><p>牵涉到这些注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="meta">@RestController</span></span><br><span class="line"><span class="number">2.</span><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="number">3.</span><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="number">4.</span><span class="meta">@SpringBootApplication</span> *</span><br><span class="line"><span class="number">5.</span><span class="meta">@propertySource</span></span><br><span class="line"><span class="number">6.</span><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="number">7.</span><span class="meta">@Configuration</span> *</span><br><span class="line"><span class="number">8.</span><span class="meta">@Bean</span> *</span><br><span class="line"><span class="number">9.</span><span class="meta">@Value</span></span><br><span class="line"><span class="number">10.</span>ConfigurationProperties *  这个注解在这个笔记的属性注入中有解释</span><br><span class="line"><span class="number">11.</span>EnableConfigurationProperties *  这个注解在这个笔记的属性注入中有解释</span><br></pre></td></tr></table></figure></li></ul><h1 id="1-了解SpringBoot"><a href="#1-了解SpringBoot" class="headerlink" title="1. 了解SpringBoot"></a>1. 了解SpringBoot</h1><h2 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1.什么是SpringBoot"></a>1.1.什么是SpringBoot</h2><p>SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:</p><p>官网参考：<a href="https://docs.spring.io/spring-boot/docs/2.3.2.RELEASE/reference/htmlsingle/1">https://docs.spring.io/spring-boot/docs/2.3.2.RELEASE/reference/htmlsingle/1</a></p><p>​                   <a href="https://spring.io/projects/spring-boot/#learn">https://spring.io/projects/spring-boot/#learn</a></p><p>官方介绍：</p><blockquote><p>Spring Boot helps you to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.</p></blockquote><p>翻译：</p><blockquote><p>Spring Boot只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。我们为spring平台和第三方依赖库提供了一种固定化的使用方式，能非常轻松的开发应用程序并且只需要很少的配置。</p></blockquote><p>Spring Boot常称为搭建程序的<code>脚手架</code>。其主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，关注于业务而非配置。</p><p>我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。</p><h2 id="1-2-为什么要学习SpringBoot"><a href="#1-2-为什么要学习SpringBoot" class="headerlink" title="1.2.为什么要学习SpringBoot"></a>1.2.为什么要学习SpringBoot</h2><p>传统java项目构建的缺点：</p><ul><li><p>复杂的配置</p><p>项目各种配置是开发时的损耗， 需要在思考 Spring 特性配置和解决业务问题之间进行思维切换。</p></li><li><p>混乱的依赖管理</p><p>项目的依赖管理需要知道这些库的哪个版本和其他库不会有冲突，也是一种损耗，添加依赖不是写应用程序代码。</p></li></ul><p>而SpringBoot让这一切成为过去！</p><h2 id="1-3-SpringBoot的特点"><a href="#1-3-SpringBoot的特点" class="headerlink" title="1.3.SpringBoot的特点"></a>1.3.SpringBoot的特点</h2><blockquote><ul><li>Provide a radically faster and widely accessible getting-started experience for all Spring development.</li><li>Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.</li><li>Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).</li><li>Absolutely no code generation and no requirement for XML configuration.</li></ul></blockquote><ul><li>创建独立的spring应用程序</li><li>直接内嵌<strong>tomcat</strong>、jetty和undertow（不需要打包成war包部署）</li><li>提供了固定化的“starter”配置，以简化构建配置</li><li>尽可能的<strong>自动配置</strong>spring和第三方库</li><li>提供产品级的功能，如：安全、指标、运行状况监测和外部化配置等</li><li>绝对不会生成代码，并且不需要XML配置</li></ul><p>总之，Spring Boot为所有 Spring 的开发者提供一个开箱即用的、非常快速的、广泛接受的体验。</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><p>环境要求：</p><p>​    spring5.x基本要求jdk8，不同版本要求不同，可以查看相应的reference doc.</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527695636167.png" alt="1527695636167"></p><h2 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1.创建工程"></a>2.1.创建工程</h2><p>​    1.new project  (Empty project)</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527690475282.png" alt="1527690475282"></p><p>​    2.new module (maven)</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527690810779.png" alt="1527690810779"></p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527694194289.png" alt="1527694194289"></p><p>填写坐标信息：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527694371964.png" alt="1527694371964"></p><p>目录结构：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527694504570.png" alt="1527694504570"></p><p>创建完成后的目录结构：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527694634778.png" alt="1527694634778"></p><h2 id="2-2-引入依赖"><a href="#2-2-引入依赖" class="headerlink" title="2.2.引入依赖"></a>2.2.引入依赖</h2><p>​    现在我们的项目与SpringBoot还没有什么关联。</p><p>​    SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，以这个项目为父工程，可以不用操心依赖的版本问题了，需要什么依赖就直接引入坐标！</p><p> module的pom.xml: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 所有的springboot的工程都以spring父工程为父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启动器：每个启动器背后都是一堆依赖。web启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-编写HelloController"><a href="#2-3-编写HelloController" class="headerlink" title="2.3.编写HelloController"></a>2.3.编写HelloController</h2><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540894662227.png" alt="1540894662227"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>   <span class="comment">//启动自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;show&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloController.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-启动测试"><a href="#2-4-启动测试" class="headerlink" title="2.4.启动测试"></a>2.4.启动测试</h2><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527755521637.png" alt="1527755521637"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console信息中</span><br><span class="line">    Servlet dispatcherServlet mapped to [&#x2F;]，这是springMVC的入口： &#x2F;</span><br><span class="line">    Tomcat started on port(s): 8080， 这是tomcat监听8080端口</span><br><span class="line"></span><br><span class="line">通过localhost:8080&#x2F;show 访问</span><br><span class="line">    页面打印出 hello Spring Boot!</span><br></pre></td></tr></table></figure><h2 id="2-5-涉及知识点"><a href="#2-5-涉及知识点" class="headerlink" title="2.5.涉及知识点"></a>2.5.涉及知识点</h2><p>1.pom.xml里引入了启动器的概念</p><p>2.在启动类使用<code>@EnableAutoConfiguration</code>注解。</p><p>3.在启动类使用<code>@RestController</code>注解。</p><h3 id="2-5-1-启动器"><a href="#2-5-1-启动器" class="headerlink" title="2.5.1.启动器"></a>2.5.1.启动器</h3><p>为了让SpringBoot帮助完成各种自动配置，必须引入SpringBoot提供的自动配置依赖，称为<code>启动器</code>。</p><p>​    <code>spring-boot-starter-parent</code>工程将依赖关系声明为一个或者多个<code>启动器</code>，我们可以根据项目需求引入相应的启动器，如web项目需要引入web启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这里并没有指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。</p><p>在Project的External Libraries中已经存在了大量依赖。</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540894098029.png" alt="1540894098029"></p><p>​    这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。</p><h3 id="2-5-2-EnableAutoConfiguration"><a href="#2-5-2-EnableAutoConfiguration" class="headerlink" title="2.5.2.@EnableAutoConfiguration"></a>2.5.2.@EnableAutoConfiguration</h3><p>官网说明：</p><blockquote><p>Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined.</p></blockquote><p>简单翻译以下：</p><blockquote><p>开启spring应用程序的自动配置，SpringBoot基于你所添加的依赖和你自己定义的bean，试图去猜测并配置你想要的配置。比如引入<code>spring-boot-starter-web</code>，这个启动器中添加了<code>tomcat</code>、<code>SpringMVC</code>的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！</p></blockquote><p>总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p><p>所以，使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了。</p><h3 id="2-5-3-RestController注解"><a href="#2-5-3-RestController注解" class="headerlink" title="2.5.3@RestController注解"></a>2.5.3@RestController注解</h3><p>一、在Spring中@RestController的作用等同于@Controller + @ResponseBody。</p><p>　　所以想要理解@RestController注解就要先了解@Controller和@ResponseBody注解。</p><h4 id="2-5-3-1-Controller注解"><a href="#2-5-3-1-Controller注解" class="headerlink" title="2.5.3.1@Controller注解"></a>2.5.3.1@Controller注解</h4><p>　　在一个类上添加@Controller注解，表明了这个类是一个控制器类。但想要让这个类成为一个处理请求的处理器光有@Controller注解是不够的，他还需要进一步修炼才能成为一个处理器。</p><p>　　1.在spring容器中创建该类的实例。创建实例的方式有两种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;test.controller.MyController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>　　上述这种方式是在spring容器中注入单个bean，当项目比较大，控制器类比较多时，用这种方式向Spring容器中注入bean非常的让人苦恼，索性有第二种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-scan</span>=<span class="string">&quot;test.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>　　这种方式会扫描指定包中的所有类，并生成相应的bean注入到spring容器中。使用这种方式当然能够极大提高我们的开发效率，但是有时候我们不想某一类型的类注入到spring容器中。</p><p>　　这个时候第二种方式也可以解决。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;test&quot;</span>&gt;</span>　　</span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　上述代码表示扫描test包中除有@Service注解之外的类。</p><p>　　2.将@Controller注解的类注入Spring容器中，只是该类成为处理器的第一步，想要修炼大成，还需要在该类中添加注解</p><h4 id="2-5-3-2-RequestMapping"><a href="#2-5-3-2-RequestMapping" class="headerlink" title="2.5.3.2@RequestMapping"></a>2.5.3.2@RequestMapping</h4><p>　　　@RequestMapping注解是用来映射请求的，即指明处理器可以处理哪些URL请求，该注解既可以用在类上，也可以用在方法上。</p><p>　　　当使用@RequestMapping标记控制器类时，方法的请求地址是<strong>相对类的请求地址而言的</strong>；当没有使用@RequestMapping标记类时，方法的请求地址是绝对路径。</p><p>　　　@RequestMapping的地址可以是uri变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址。具体的使用方法不是本次的重点，有兴趣的可以看</p><p>　　　　[<a href="https://www.cnblogs.com/xiepeixing/p/4243288.html]">https://www.cnblogs.com/xiepeixing/p/4243288.html]</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　 <span class="meta">@Controller</span></span><br><span class="line"> 　　<span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"> 　　<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">     　　<span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line">     　　<span class="function"><span class="keyword">public</span> String <span class="title">users</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        　　<span class="keyword">return</span> <span class="string">&quot;users&quot;</span>;</span><br><span class="line">    　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>　　此时请求users方法的url路径就是：…/user/users。</p><p>　　可以看到上面users方法的返回值是字符串类型的，这个就是处理器在处理完任务后将要跳转的页面。如果<strong>想要方法直接返回结果，而不是跳转页面</strong>，这就要用到@ResponseBody注解了。</p><h4 id="2-5-3-3-ResponseBody注解"><a href="#2-5-3-3-ResponseBody注解" class="headerlink" title="2.5.3.3@ResponseBody注解"></a>2.5.3.3@ResponseBody注解</h4><p>　　@ResponseBody表示方法的返回值直接<strong>以指定的格式写入Http response body中</strong>，而<strong>不是解析为跳转路径</strong>。</p><p>　　格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。</p><p>如果要求方法返回的是<strong>json格式数据，而不是跳转页</strong>面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。</p><h3 id="2-5-4-GetMapping-与-PostMapping"><a href="#2-5-4-GetMapping-与-PostMapping" class="headerlink" title="2.5.4*@GetMapping*与@PostMapping"></a>2.5.4*@GetMapping*与@<em>PostMapping</em></h3><p><em>@GetMapping</em>用于处理请求方法的<em>GET</em>类型，*@ PostMapping<em>用于处理请求方法的</em>POST*类型等</p><p>如果我们想使用传统的*@RequestMapping*注释实现URL处理程序，那么它应该是这样的：</p><p><code>@RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</code></p><p>新方法可以简化为：</p><p><code>@GetMapping(&quot;/get/&#123;id&#125;&quot;</code></p><h2 id="2-6-多个Controller"><a href="#2-6-多个Controller" class="headerlink" title="2.6.多个Controller"></a>2.6.多个Controller</h2><p>多个Controller的情形如何处理？</p><p>添加Hello2Controller：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527949030771.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello2Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;show2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Spring Boot2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动，访问show2测试，失败。</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528087951866.png" alt="1528087951866"></p><p>​    难道要在每一个Controller中都添加一个main方法和@EnableAutoConfiguration注解，这样启动一个springboot程序也太麻烦了。也无法同时启动多个Controller，因为每个main方法都监听8080端口。所以，一个springboot程序应该只有一个springboot的main方法。</p><p>​    所以，springboot程序引入了一个全局的引导类。</p><h3 id="2-5-1-添加引导类"><a href="#2-5-1-添加引导类" class="headerlink" title="2.5.1.添加引导类"></a>2.5.1.添加引导类</h3><p>​    通常情况下，我们在一个springboot工程中都会在<strong>基包下创建一个引导类</strong>，一些springboot的全局注解（@EnableAutoConfiguration注解）以及springboot程序的入口main方法都放在该类中。</p><p>​    在springboot的程序的基包下（<strong>引导类和Controller包在同级目录下</strong>），创建TestApplication.class：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527760765673.png"></p><p>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>  <span class="comment">//类似于&lt;context:component-scan base-package=&quot;&quot;&gt; 扫描该类所在的包以及它的子孙包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并修改HelloController，<strong>去掉main方法及@EnableAutoConfiguration</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;show&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动引导类，访问show测试仍然<strong>失败</strong>。</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528088990216.png" alt="1528088990216"></p><p>​    发现所有的Controller都不能访问，为什么？</p><p>回想以前程序，我们在配置文件中添加了注解扫描，它能扫描指定包下的所有Controller，而现在并没有。怎么解决——**@ComponentScan注解**</p><h3 id="2-5-2-ComponentScan"><a href="#2-5-2-ComponentScan" class="headerlink" title="2.5.2.@ComponentScan"></a>2.5.2.@ComponentScan</h3><p>spring框架除了提供配置方式的注解扫描<code>&lt;context:component-scan /&gt;</code>，还提供了注解方式的注解扫描<code>@ComponentScan</code>。</p><p>在TestApplication.class中，使用@ComponentScan注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">//类似于&lt;context:component-scan base-package=&quot;&quot;&gt; 扫描该类所在的包以及它的子孙包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动，访问show或者show2成功！(localhost:8080/show与localhost:8080/show2)</p><p>跟进该注解的源码查看注释：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1527818066552.png" alt="1527818066552"></p><p>大概的意思：</p><blockquote><p>配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签的作用</p><p>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p></blockquote><p>而我们的@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。<strong>一般启动类会放在一个比较浅的包目录中。</strong></p><h3 id="2-5-3-SpringBootApplication"><a href="#2-5-3-SpringBootApplication" class="headerlink" title="2.5.3.@SpringBootApplication"></a>2.5.3.@SpringBootApplication</h3><p>​    我们现在的引导类中使用了@EnableAutoConfiguration和@ComponentScan注解，有点麻烦。springboot提供了一种简便的玩法：@SpringBootApplication注解</p><p>使用@SpringBootApplication改造TestApplication：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>   <span class="comment">//使用组合注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入，查看源码：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528093556068.png" alt="1528093556068"></p><p>发现@SpringBootApplication其实是一个组合注解，这里重点的注解有3个：</p><ul><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code>：开启自动配置</li><li><code>@ComponentScan</code>：开启注解扫描</li></ul><h3 id="2-5-4-SpringBootConfiguration"><a href="#2-5-4-SpringBootConfiguration" class="headerlink" title="2.5.4.@SpringBootConfiguration"></a>2.5.4.@SpringBootConfiguration</h3><p>@SpringBootConfiguration注解的源码：</p><p>我们继续点击查看源码：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528095223949.png" alt="1528095223949"></p><p>​    通过这段我们可以看出，在这个注解上面，又有一个<code>@Configuration</code>注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了<code>@Configuration</code>的类，并且读取其中的配置信息。而<code>@SpringBootConfiguration</code>是来声明当前类是<code>SpringBoot应用的配置类</code>，项目中只能有一个。所以一般我们无需自己添加。</p><h1 id="3-默认配置原理"><a href="#3-默认配置原理" class="headerlink" title="3.默认配置原理"></a>3.默认配置原理</h1><p>springboot的默认配置方式和我们之前玩的配置方式不太一样，没有任何的xml。那么如果自己要新增配置该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在该怎么做呢?</p><h2 id="3-1-回顾历史"><a href="#3-1-回顾历史" class="headerlink" title="3.1.回顾历史"></a>3.1.回顾历史</h2><p>事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：</p><ul><li><p>Spring1.0时代</p><p>在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒</p></li><li><p>Spring2.0时代</p><p>Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。</p></li><li><p>Spring3.0及以后</p><p>3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。</p></li></ul><p>有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。</p><h2 id="3-2-尝试java配置"><a href="#3-2-尝试java配置" class="headerlink" title="3.2.尝试java配置"></a>3.2.尝试java配置</h2><p>java配置主要靠java类和一些注解来达到和xml配置一样的效果，比较常用的注解有：</p><ul><li><code>@Configuration</code>：声明一个类作为配置类，代替xml文件</li><li><code>@Bean</code>：声明在方法上，将方法的返回值加入Bean容器，代替<code>&lt;bean&gt;</code>标签</li><li><code>@Value</code>：属性注入 </li><li><code>@PropertySource</code>：指定外部属性文件。</li></ul><p>我们接下来用java配置来尝试实现连接池配置</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540895699735.png" alt="1540895699735"></p><h3 id="3-2-1-引入依赖"><a href="#3-2-1-引入依赖" class="headerlink" title="3.2.1.引入依赖"></a>3.2.1.引入依赖</h3><p>首先在pom.xml中，引入Druid连接池依赖，即Druid启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.drtrang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot2-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-2-添加jdbc-properties"><a href="#3-2-2-添加jdbc-properties" class="headerlink" title="3.2.2.添加jdbc.properties"></a>3.2.2.添加jdbc.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leyou</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-配置数据源"><a href="#3-2-3-配置数据源" class="headerlink" title="3.2.3.配置数据源"></a>3.2.3.配置数据源</h3><p>创建JdbcConfiguration类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 声明一个类是一个java配置类，相当于一个xml配置文件</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span>  <span class="comment">//读取资源文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将方法的返回值注入到spring容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>@Configuration</code>：声明<code>JdbcConfiguration</code>是一个配置类。</li><li><code>@PropertySource</code>：指定属性文件的路径是:<code>classpath:jdbc.properties</code></li><li>通过<code>@Value</code>为属性注入值。</li><li>通过@Bean将 <code>dataSource()</code>方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签</li></ul><p>然后就可以在任意位置通过<code>@Autowired</code>注入DataSource了！</p><h4 id="补充-PropertySource"><a href="#补充-PropertySource" class="headerlink" title="补充@PropertySource"></a>补充@PropertySource</h4><p>作用：</p><p>​        用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。<br>属性：<br>​        value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath:  </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h5><p><a href="https://docs.spring.io/spring-boot/docs/2.3.2.RELEASE/reference/htmlsingle/#boot-features-external-config">springboot官网的解释</a> ：</p><p>​    Spring Boot使您可以外部化配置，以便可以在不同环境中使用相同的application代码。您可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。属性值 可以使用 <code>@Value</code> 注解直接注入beans中，也可以通过Spring的Environment抽象访问，也可以通过@ConfigurationProperties<a href="https://docs.spring.io/spring-boot/docs/2.3.2.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties">绑定到结构化对象</a>。</p><p>​    Spring Boot使用一个非常特殊的PropertySource顺序，该顺序旨在允许合理地覆盖值。按以下顺序考虑属性：</p><ol><li><p>devtools处于活动状态时 <code>$HOME/.config/spring-boot</code>目录中的Devtools全局设置属性。</p></li><li><p>测试上的@TestPropertySource注解。</p></li><li><p>测试中的properties属性。在@SpringBootTest和测试注解上可用，用于测试应用的特定部分。</p></li><li><p>命令行参数。</p></li><li><p>来自SPRING_APPLICATION_JSON的属性（嵌入在环境变量或系统属性中的嵌入式JSON）。</p></li><li><p>ServletConfig的初始化参数。</p></li><li><p>ServletContext的初始化参数。</p></li><li><p>来自 <code>java:comp/env</code>的JNDI属性。</p></li><li><p>Java系统属性（System.getProperties()）。</p></li><li><p>OS系统环境变量。</p></li><li><p>一个RandomValuePropertySource，仅具有random.*属性。</p></li><li><p>打包的jar之外的特定于配置文件的应用属性（application-{profile}.properties和YAML变体）。</p></li><li><p>打包在jar中的特定于配置文件的应用程序属性（application-{profile}.properties和YAML变体）。</p></li><li><p>打包的jar之外的应用属性（application.properties和YAML变体）。</p></li><li><p>打包在jar中的应用属性（application.properties和YAML变体）。</p></li><li><p>@Configuration类上的<code>@PropertySource</code> 注解。请注意，在刷新应用上下文之前，不会将此类属性源添加到环境中。现在配置某些属性（如<code>logging.*</code>和<code>spring.main.*</code>）为时已晚，这些属性在刷新开始之前就已读取。</p></li><li><p>默认属性（通过设置SpringApplication.setDefaultProperties指定）。</p></li></ol><p>​    To provide a concrete example, suppose you develop a <code>@Component</code> that uses a <code>name</code> property, as shown in the following example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然在@SpringBootApplication上使用@PropertySource似乎是在Environment中加载自定义资源的便捷方法，但我们不建议这样做。 在刷新应用上下文之前，不会将此类属性sources添加到Environment中。 现在配置某些属性（如logging.*和spring.main.*）为时已晚，这些属性在刷新开始之前就已读取。</span><br></pre></td></tr></table></figure><h3 id="3-2-4-测试"><a href="#3-2-4-测试" class="headerlink" title="3.2.4.测试"></a>3.2.4.测试</h3><p>我们在<code>HelloController</code>中测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;show&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在test方法中打一个断点，然后Debug运行并查看：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528098961065.png" alt="1528098961065"></p><p>属性注入成功了！</p><h2 id="3-3-更强大的SpringBoot的属性注入四种方式"><a href="#3-3-更强大的SpringBoot的属性注入四种方式" class="headerlink" title="3.3.更强大的SpringBoot的属性注入四种方式"></a>3.3.更强大的SpringBoot的属性注入四种方式</h2><p>1.@Autowired注入</p><p>2.构造方法注入</p><p>3.@Bean方法形参注入</p><p>4.直接在@Bean方法上使用@ConfigurationProperties(prefix=”jdbc”)</p><p>​    在上面的案例中，我们实验了java配置方式。</p><p><strong>不过属性注入使用的是<code>@Value注解</code>。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。</strong></p><p>​    在SpringBoot中，提供了一种新的属性注入方式，支持<code>**各种java基本数据类型及复杂类型的注入**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意这里说的是属性注入，也就是dataSource类中的属性，url...</span><br></pre></td></tr></table></figure><p>使用步骤：</p><p>1）新建<code>JdbcProperties</code>，用来进行属性注入：</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540895952978.png"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// getters 和 setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="前提-ConfigurationProperties"><a href="#前提-ConfigurationProperties" class="headerlink" title="前提(@ConfigurationProperties)"></a>前提(@ConfigurationProperties)</h3><ul><li><p>1）在类上通过@ConfigurationProperties注解声明<strong>当前类为属性读取类</strong></p></li><li><p>2）<code>prefix=&quot;jdbc&quot;</code>读取属性文件中，<strong>前缀为jdbc的值</strong>。</p></li><li><p>3）在类上定义各个属性，名称必须与属性文件中<code>jdbc.</code>后面部分一致，并且必须具有getter和setter方法</p></li><li><p>4）需要注意的是，这里我们并没有指定属性文件的地址，SpringBoot默认会读取文件名为application.properties的资源文件，所以我们<strong>把jdbc.properties名称改为application.properties</strong></p></li></ul><p>2）在JdbcConfiguration中使用这个属性：</p><p>​    1）通过<code>@EnableConfigurationProperties(JdbcProperties.class)</code>来声明要使用<code>JdbcProperties</code>这个类的对象</p><p>​    2）然后你可以通过以下方式在JdbcConfiguration类中注入JdbcProperties：</p><h3 id="Autowired注入"><a href="#Autowired注入" class="headerlink" title="@Autowired注入"></a>@Autowired注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcProperties jdbcProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(jdbcProperties.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbcProperties.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbcProperties.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbcProperties.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcProperties jdbcProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcConfiguration</span><span class="params">(JdbcProperties jdbcProperties)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcProperties = jdbcProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean方法的参数注入"><a href="#Bean方法的参数注入" class="headerlink" title="@Bean方法的参数注入"></a>@Bean方法的参数注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(JdbcProperties jdbcProperties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中，我们采用第三种方式。</p><p>3）测试结果：</p><p><img src="/assets/1527783292437.png" alt="1527783292437"></p><p>大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528103259908.png" alt="1528103259908"></p><p>优势：</p><ul><li><p>Relaxed binding：松散绑定</p><ul><li>不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：<code>代表的是user对象中的friend属性中的name属性，显然friend也是对象</code>。@value注解就难以完成这样的注入方式。</li><li>meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。</li></ul></li></ul><h2 id="3-4-注入到方法"><a href="#3-4-注入到方法" class="headerlink" title="3.4.注入到方法"></a>3.4.注入到方法</h2><p>​    事实上，如果<strong>一段属性只有一个Bean需要使用</strong>，我们<strong>无需将其注入到一个类（JdbcProperties）中</strong>。而是直接在需要的地方声明即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//把方法的返回值注入容器</span></span><br><span class="line">    <span class="comment">// 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接把<code>@ConfigurationProperties(prefix = &quot;jdbc&quot;)</code>声明在需要使用的<code>@Bean</code>的方法上，然后SpringBoot就会<strong>自动调用这个Bean（此处是DataSource）的set方法，然后完成注入</strong>。使用的前提是：</p><p>​    <strong>该类必须有对应属性的set方法！</strong>，也就是说这里的返回值<strong>dataSource对象的bean对象需要有对应属性的set方法</strong>，且必须名称一致</p><p>我们将jdbc的url改成：/heima，再次测试：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528103369170.png" alt="1528103369170"></p><h2 id="3-5-SpringBoot中的默认配置"><a href="#3-5-SpringBoot中的默认配置" class="headerlink" title="3.5.SpringBoot中的默认配置"></a>3.5.SpringBoot中的默认配置</h2><p><strong>@EnableAutoConfiguration会开启SpringBoot的自动配置</strong>，并根据引入的依赖来生效对应的默认配置。那么问题来了：</p><ul><li>这些默认配置是怎么配置的，在哪里配置的呢？</li><li>为何依赖引入就会触发配置呢？</li><li>这些默认配置的属性来自哪里呢？</li></ul><p>其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：</p><p> <img src="/assets/1527931944702.png" alt="1527931944702"></p><p>还有：</p><p> <img src="/assets/1527931968031.png" alt="1527931968031"></p><p>非常多，几乎涵盖了现在主流的开源框架，例如：</p><ul><li>redis</li><li>jms</li><li>amqp</li><li>jdbc</li><li>jackson</li><li>mongodb</li><li>jpa</li><li>solr</li><li>elasticsearch</li></ul><p>… 等等</p><p>我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：</p><p>  <img src="/assets/1527933162533.png" alt="1527933162533"></p><p>打开WebMvcAutoConfiguration：</p><p><img src="/assets/1527933633048.png" alt="1527933633048"></p><p>我们看到这个类上的4个注解：</p><ul><li><p>1）<code>@Configuration</code>：声明这个类是一个配置类</p></li><li><p>2）<code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></p><p>​       ConditionalOn，就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程。</p></li><li><p>3）<code>@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</code></p><p>​      这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只 要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，<strong>引入依赖后该条件成立，当前类的配置才会生效！</strong></p></li><li><p>4）<code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p><p>​      这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是<strong>自定义配置的入口</strong>，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！</p></li></ul><p>接着，我们查看该类中定义了什么：</p><p>视图解析器：</p><p><img src="/assets/1527933646831.png" alt="1527933646831"></p><p>处理器适配器（HandlerAdapter）：</p><p><img src="/assets/1527933659948.png" alt="1527933659948"></p><p>还有很多，这里就不一一截图了。</p><p>另外，这些默认配置的属性来自哪里呢？</p><p><img src="/assets/1528096733440.png" alt="1528096733440"></p><p>我们看到，这里通过@EnableConfigurationProperties注解引入了两个属性：WebMvcProperties和ResourceProperties。</p><p>我们查看这两个属性类：</p><p><img src="/assets/1528096851318.png" alt="1528096851318"></p><p>找到了内部资源视图解析器的prefix和suffix属性。</p><p>ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：</p><p><img src="/assets/1528096892588.png" alt="1528096892588"></p><p>如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。</p><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6.总结"></a>3.6.总结</h2><p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p><ul><li>你引入了相关依赖</li><li>你自己没有配置</li></ul><p>下面这些都可以在spring的官方文档中查得到</p><p>1）启动器</p><p>​    之所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p><p>​    因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">1.    Spring Boot application starters</span><br><span class="line">spring-boot-starter-thymeleaf</span><br><span class="line">使用Thymeleaf视图构建MVC Web应用程序</span><br><span class="line"></span><br><span class="line">spring-boot-starter-ws</span><br><span class="line">使用Spring Web服务。1.4不推荐使用，推荐使用spring-boot-starter-web-services</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-couchbase</span><br><span class="line">Starter for using Couchbase document-oriented database and Spring Data Couchbase</span><br><span class="line"></span><br><span class="line">spring-boot-starter-artemis</span><br><span class="line">使用Apache Artemis启动JMS消息传递</span><br><span class="line"></span><br><span class="line">spring-boot-starter-web-services</span><br><span class="line">使用Spring Web服务</span><br><span class="line"></span><br><span class="line">spring-boot-starter-mail</span><br><span class="line">支持使用Java Mail和Spring Framework发送电子邮件</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-redis</span><br><span class="line">使用Redis键值数据存储与Spring Data Redis和Jedis客户端</span><br><span class="line"></span><br><span class="line">spring-boot-starter-web</span><br><span class="line">启动器构建web，包括RESTful，使用Spring MVC的应用程序。使用Tomcat作为默认嵌入式容器</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-gemfire</span><br><span class="line">Starter for using GemFire distributed data store and Spring Data GemFire</span><br><span class="line"></span><br><span class="line">spring-boot-starter-activemq</span><br><span class="line">使用Apache ActiveMQ启动JMS消息传递</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-elasticsearch</span><br><span class="line">使用Elasticsearch搜索和分析引擎和Spring Data Elasticsearch</span><br><span class="line"></span><br><span class="line">spring-boot-starter-integration</span><br><span class="line">Starter for using Spring Integration</span><br><span class="line"></span><br><span class="line">spring-boot-starter-test</span><br><span class="line">Spring Boot应用程序用于测试包括JUnit，Hamcrest和Mockito</span><br><span class="line"></span><br><span class="line">spring-boot-starter-hornetq</span><br><span class="line">使用HornetQ启动JMS消息传递。1.4已弃用，推荐使用spring-boot-starter-artemis</span><br><span class="line"></span><br><span class="line">spring-boot-starter-jdbc</span><br><span class="line">使用HikariCP连接池</span><br><span class="line"></span><br><span class="line">spring-boot-starter-mobile</span><br><span class="line">使用Spring Mobile构建Web应用程序的入门</span><br><span class="line"></span><br><span class="line">spring-boot-starter-validation</span><br><span class="line">使用Java Bean校验与Hibernate校验器</span><br><span class="line"></span><br><span class="line">spring-boot-starter-hateoas</span><br><span class="line">使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序的入门</span><br><span class="line"></span><br><span class="line">spring-boot-starter-jersey</span><br><span class="line">使用JAX-RS和Jersey构建RESTful Web应用程序的入门。 spring-boot-starter-web的替代品</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-neo4j</span><br><span class="line">使用Neo4j图数据库和Spring Data Neo4j</span><br><span class="line"></span><br><span class="line">spring-boot-starter-websocket</span><br><span class="line">使用Spring Framework的WebSocket支持构建WebSocket应用程序</span><br><span class="line"></span><br><span class="line">spring-boot-starter-aop</span><br><span class="line">使用Spring AOP和AspectJ进行面向方面编程</span><br><span class="line"></span><br><span class="line">spring-boot-starter-amqp</span><br><span class="line">使用Spring AMQP和Rabbit MQ的入门</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-cassandra</span><br><span class="line">使用Cassandra分布式数据库和Spring Data Cassandra</span><br><span class="line"></span><br><span class="line">spring-boot-starter-social-facebook</span><br><span class="line">使用Spring Social Facebook</span><br><span class="line"></span><br><span class="line">spring-boot-starter-jta-atomikos</span><br><span class="line">使用Atomikos进行JTA事务</span><br><span class="line"></span><br><span class="line">spring-boot-starter-security</span><br><span class="line">使用Spring Security</span><br><span class="line"></span><br><span class="line">spring-boot-starter-mustache</span><br><span class="line">使用Mustache视图构建MVC Web应用程序</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-jpa</span><br><span class="line">使用Spring Data JPA与Hibernate</span><br><span class="line"></span><br><span class="line">spring-boot-starter</span><br><span class="line">核心启动器，包括自动配置支持，日志记录和YAML</span><br><span class="line"></span><br><span class="line">spring-boot-starter-velocity</span><br><span class="line">使用Velocity视图构建MVC Web应用程序。1.4已弃用</span><br><span class="line"></span><br><span class="line">spring-boot-starter-groovy-templates</span><br><span class="line">使用Groovy模板视图构建MVC Web应用程序</span><br><span class="line"></span><br><span class="line">spring-boot-starter-freemarker</span><br><span class="line">使用FreeMarker视图构建MVC Web应用程序</span><br><span class="line"></span><br><span class="line">spring-boot-starter-batch</span><br><span class="line">使用Spring Batch</span><br><span class="line"></span><br><span class="line">spring-boot-starter-redis</span><br><span class="line">使用Redis键值数据存储与Spring Data Redis和Jedis客户端的入门。1.4已弃用，建议使用spring-boot-starter-data-redis</span><br><span class="line"></span><br><span class="line">spring-boot-starter-social-linkedin</span><br><span class="line">Stater for using Spring Social LinkedIn</span><br><span class="line"></span><br><span class="line">spring-boot-starter-cache</span><br><span class="line">支持使用Spring Framework的缓存</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-solr</span><br><span class="line">使用带有Spring Data Solr的Apache Solr搜索平台</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-mongodb</span><br><span class="line">使用MongoDB和Spring Data MongoDB</span><br><span class="line"></span><br><span class="line">spring-boot-starter-jooq</span><br><span class="line">使用jOOQ访问SQL数据库。 spring-boot-starter-data-jpa或spring-boot-starter-jdbc的替代方法</span><br><span class="line"></span><br><span class="line">spring-boot-starter-jta-narayana</span><br><span class="line">Spring Boot启动Narayana JTA</span><br><span class="line"></span><br><span class="line">spring-boot-starter-cloud-connectors</span><br><span class="line">启动者使用Spring Cloud连接器，简化了连接到云平台中的服务，如Cloud Foundry和Heroku</span><br><span class="line"></span><br><span class="line">spring-boot-starter-jta-bitronix</span><br><span class="line">使用Bitronix进行JTA事务</span><br><span class="line"></span><br><span class="line">spring-boot-starter-social-twitter</span><br><span class="line">使用Spring Social Twitter</span><br><span class="line"></span><br><span class="line">spring-boot-starter-data-rest</span><br><span class="line">使用Spring Data REST通过REST暴露Spring数据存储库</span><br><span class="line"></span><br><span class="line">2.    Spring Boot production starters</span><br><span class="line">spring-boot-starter-actuator</span><br><span class="line">使用Spring Boot的Actuator，提供生产就绪的功能，以帮助您监视和管理您的应用程序</span><br><span class="line"></span><br><span class="line">spring-boot-starter-remote-shell</span><br><span class="line">使用CRaSH远程shell通过SSH监视和管理您的应用程序</span><br><span class="line"></span><br><span class="line">3.    Spring Boot technical starters</span><br><span class="line">spring-boot-starter-undertow</span><br><span class="line">使用Undertow作为嵌入式servlet容器。 spring-boot-starter-tomcat的替代方法</span><br><span class="line"></span><br><span class="line">spring-boot-starter-jetty</span><br><span class="line">使用Jetty作为嵌入式servlet容器的。 spring-boot-starter-tomcat的替代方法</span><br><span class="line"></span><br><span class="line">spring-boot-starter-logging</span><br><span class="line">使用Logback进行日志记录。 默认日志启动器</span><br><span class="line"></span><br><span class="line">spring-boot-starter-tomcat</span><br><span class="line">使用Tomcat作为嵌入式servlet容器。 spring-boot-starter-web使用的默认servlet容器</span><br><span class="line"></span><br><span class="line">spring-boot-starter-log4j2</span><br><span class="line">使用Log4j2进行日志记录。 spring-boot-starter-logging的替代方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）全局配置</p><p>​    另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p><p>（tips：springboot默认配置文件：application.properties  application.yml，都是配置文件但只能存在一个）</p><p>​    因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考《资料》提供的：《SpringBoot全局属性.md》</p><h1 id="4-SpringBoot实战"><a href="#4-SpringBoot实战" class="headerlink" title="4.SpringBoot实战"></a>4.SpringBoot实战</h1><p>接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User</p><h2 id="4-1-创建工程"><a href="#4-1-创建工程" class="headerlink" title="4.1.创建工程"></a>4.1.创建工程</h2><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540896476056.png" alt="1540896476056"></p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540896950344.png" alt="1540896950344"></p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540896657008.png" alt="1540896657008"></p><h2 id="4-2-编写基本代码"><a href="#4-2-编写基本代码" class="headerlink" title="4.2.编写基本代码"></a>4.2.编写基本代码</h2><p>1.pom.xml中引入启动器</p><p>2.添加覆盖默认配置(application.properties/yml)</p><p>3.添加引导类</p><p>4.编写controller代码</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540898508682.png" alt="1540898508682"></p><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.user<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以下均为需引入的依赖，可在官方参考文档中查询 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参照上边的项目，编写引导类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello ssm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-整合SpringMVC"><a href="#4-3-整合SpringMVC" class="headerlink" title="4.3.整合SpringMVC"></a>4.3.整合SpringMVC</h2><p>虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。</p><h3 id="4-3-1-修改端口"><a href="#4-3-1-修改端口" class="headerlink" title="4.3.1.修改端口"></a>4.3.1.修改端口</h3><p>添加全局配置文件：application.properties</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540898582724.png" alt="1540898582724"></p><p>端口通过以下方式配置</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540898053088.png" alt="1540898053088"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 映射端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure><p>重启服务后测试：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528116232569.png" alt="1528116232569"></p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528116322747.png" alt="1528116322747"></p><h3 id="4-3-2-访问静态资源"><a href="#4-3-2-访问静态资源" class="headerlink" title="4.3.2.访问静态资源"></a>4.3.2.访问静态资源</h3><p>现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p><p>回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： <img src="/assets/1528096892588.png" alt="1528096892588"></p><p>默认的静态资源路径为：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li></ul><p><strong>只要静态资源放在这些目录中任何一个</strong>，SpringMVC都会帮我们处理，且访问时不需要带前缀static，resources等。</p><p>我们习惯会把静态资源放在<code>classpath:/static/</code>目录下。我们创建目录，并且添加一些静态资源：</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540898730442.png" alt="1540898730442"></p><p>重启项目后测试：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540898831238.png" alt="1540898831238"></p><h3 id="4-3-3-添加拦截器"><a href="#4-3-3-添加拦截器" class="headerlink" title="4.3.3.添加拦截器"></a>4.3.3.添加拦截器</h3><p>配置拦截器：</p><p>1）声明该类是一个java配置类,@Configuration</p><p>2）实现WebMvcConfigurer接口</p><p>​    拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？</p><p>拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明：</p><blockquote><p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#mvc">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p></blockquote><p>翻译：</p><blockquote><p>如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让<strong>一个类实现<code>WebMvcConfigurer</code>**，并且</strong>添加<code>@Configuration</code>注解<strong>，但是</strong>千万不要**加<code>@EnableWebMvc</code>注解。如果你想要自定义<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ExceptionResolver</code>等组件，你可以创建一个<code>WebMvcRegistrationsAdapter</code>实例 来提供以上组件。</p><p>如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加<code>@Configuration</code>注解和<code>@EnableWebMvc</code>注解</p></blockquote><p><strong>总结：</strong></p><p>​    通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置。</p><p>实现如下：</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540899012303.png" alt="1540899012303"></p><p>1）首先我们<strong>定义一个拦截器implements HandlerInterceptor</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle method is running!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle method is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion method is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）然后<strong>定义配置类</strong>，注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span></span><br><span class="line"><span class="comment">     * /**拦截多级，也就是任意级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来运行并查看日志：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">preHandle method is running!</span><br><span class="line">postHandle method is running!</span><br><span class="line">afterCompletion method is running!</span><br></pre></td></tr></table></figure><p>​    你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。</p><p>3）SpringBoot通过<code>logging.level.*=debug</code>来配置日志级别，*填写包名（在application.properties中添加即可）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置org.springframework包的日志级别为debug</span></span><br><span class="line"><span class="meta">logging.level.org.springframework</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure><p>再次运行查看：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540899090277.png" alt="1540899090277"></p><h2 id="4-4-整合连接池"><a href="#4-4-整合连接池" class="headerlink" title="4.4.整合连接池"></a>4.4.整合连接池</h2><p>jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？</p><p>答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528126755717.png" alt="1528126755717"></p><p>1）在pom.xml中引入jdbc的启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot已经自动帮我们引入了一个连接池：</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528126862203.png" alt="1528126862203"></p><p>HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1525516441005.png" alt="1525516441005"></p><p>因此，我们只需要指定连接池参数即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接四大参数</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/heima</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"># 可省略，SpringBoot自动推断</span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.hikari.idle-timeout</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><p>当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器，同样也需要指定驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同（也就是不改变四大参数的配置，只改动特有属性）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化连接数</span></span><br><span class="line"><span class="meta">spring.datasource.druid.initial-size</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#最小空闲连接</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-idle</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#最大活动连接</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#获取连接时测试是否可用</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-borrow</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#监控页面启动</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.allow</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="4-5-整合mybatis"><a href="#4-5-整合mybatis" class="headerlink" title="4.5.整合mybatis"></a>4.5.整合mybatis</h2><h3 id="4-5-1-mybatis"><a href="#4-5-1-mybatis" class="headerlink" title="4.5.1.mybatis"></a>4.5.1.mybatis</h3><p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis<a href="https://github.com/mybatis/spring-boot-starter">官方</a>自己实现了：</p><p><a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置，基本没有需要配置的（同样也和上节相同需要四大参数）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mybatis 别名扫描</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">cn.itcast.pojo</span></span><br><span class="line"><span class="comment"># mapper.xml文件位置,如果没有映射文件，请注释掉</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mappers/**/*.xml</span></span><br></pre></td></tr></table></figure><p>需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加<code>@Mapper</code>注解，才能被识别。</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528128785010.png" alt="1528128785010"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user对象参照课前资料，需要通用mapper的注解：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540899330478.png" alt="1540899330478"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line">    <span class="keyword">private</span> Date updated;</span><br><span class="line"></span><br><span class="line">    ...get set方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，就去集成通用mapper。</p><h4 id="4-5-1-1-Mapper"><a href="#4-5-1-1-Mapper" class="headerlink" title="4.5.1.1 @Mapper"></a>4.5.1.1 @Mapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加了<span class="doctag">@Mapper</span>注解之后这个接口在编译时会生成相应的实现类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 需要注意的是：这个接口中不可以定义同名的方法，因为会生成相同的id</span></span><br><span class="line"><span class="comment"> * 也就是说这个接口是不支持重载的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String name)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where name = #&#123;name&#125; and pwd = #&#123;pwd&#125;&quot;)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 对于多个参数来说，每个参数之前都要加上<span class="doctag">@Param</span>注解，</span></span><br><span class="line"><span class="comment">      * 要不然会找不到对应的参数进而报错</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span>String name, <span class="meta">@Param(&quot;pwd&quot;)</span>String pwd)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-2-通用mapper"><a href="#4-5-2-通用mapper" class="headerlink" title="4.5.2.通用mapper"></a>4.5.2.通用mapper</h3><p>API：<a href="https://apidoc.gitee.com/free/Mapper/">https://apidoc.gitee.com/free/Mapper/</a></p><p>文档：<a href="https://github.com/abel533/Mapper">https://github.com/abel533/Mapper</a></p><p>通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要做任何配置就可以使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">tk</span>.<span class="title">mybatis</span>.<span class="title">mapper</span>.<span class="title">common</span>.<span class="title">Mapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-3-service部分"><a href="#4-5-3-service部分" class="headerlink" title="4.5.3 service部分"></a>4.5.3 service部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-整合事务"><a href="#4-6-整合事务" class="headerlink" title="4.6.整合事务"></a>4.6.整合事务</h2><p>其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528128711716.png" alt="1528128711716"></p><p>至于事务，SpringBoot中通过注解来控制。就是我们熟知的<code>@Transactional</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-1-controller部分"><a href="#4-6-1-controller部分" class="headerlink" title="4.6.1 controller部分"></a>4.6.1 controller部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserSerivice userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;$&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-启动测试"><a href="#4-7-启动测试" class="headerlink" title="4.7.启动测试"></a>4.7.启动测试</h2><p>在UserController中添加测试方法，内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello ssm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动项目，查看：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540900351215.png" alt="1540900351215"></p><h2 id="4-8-完整项目结构"><a href="#4-8-完整项目结构" class="headerlink" title="4.8.完整项目结构"></a>4.8.完整项目结构</h2><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1540900302611.png" alt="1540900302611"></p><p>完整的pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.user<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 通用mapper --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整的application.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">logging.level.org.springframework</span>=<span class="string">debug</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/heima</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis 别名扫描</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">cn.itcast.pojo</span></span><br><span class="line"><span class="comment"># mapper.xml文件位置,如果没有映射文件，请注释掉</span></span><br><span class="line"><span class="comment"># mybatis.mapper-locations=classpath:mappers/*.xml</span></span><br></pre></td></tr></table></figure><h2 id="4-9-小结"><a href="#4-9-小结" class="headerlink" title="4.9 小结"></a>4.9 小结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">整合springMVC</span><br><span class="line">    <span class="number">1.</span>修改端口(server.port=<span class="number">8888</span>)</span><br><span class="line">    <span class="number">2.</span>访问静态资源(classpath:...)</span><br><span class="line">    <span class="number">3.</span>拦截器：</span><br><span class="line">        <span class="number">1</span>)自定义拦截器：实现HandlerInterceptor接口</span><br><span class="line">        <span class="number">2</span>)配置拦截器：自定义一个java配置类(<span class="meta">@Configuration</span>)，实现WebMvcConfigurer接口</span><br><span class="line">整合数据源</span><br><span class="line">    <span class="number">1.</span>引入jdbc启动器与mysql驱动</span><br><span class="line">    <span class="number">2.</span>添加配置：spring.dataSource.url/password/username</span><br><span class="line">整合mybatis</span><br><span class="line">    <span class="number">1.</span>引入启动器</span><br><span class="line">    <span class="number">2.</span>覆盖默认配置：mybatis.type-aliases-<span class="keyword">package</span>=cn.cxh.pojo.user  </span><br><span class="line">                  mybatis.mapper-locations=classpath:mybatis/mappers<span class="comment">/**/*.xml</span></span><br><span class="line"><span class="comment">    3.代码：定义一个接口，在接口上添加<span class="doctag">@Mapper</span>注解</span></span><br><span class="line"><span class="comment">整合通用mapper</span></span><br><span class="line"><span class="comment">    1.引入启动器</span></span><br><span class="line"><span class="comment">    2.代码：接口继承Mapper&lt;User&gt;</span></span><br><span class="line"><span class="comment">整合事务：</span></span><br><span class="line"><span class="comment">    添加<span class="doctag">@Transactional</span></span></span><br></pre></td></tr></table></figure><h1 id="5-Thymeleaf快速入门"><a href="#5-Thymeleaf快速入门" class="headerlink" title="5.Thymeleaf快速入门"></a>5.Thymeleaf快速入门</h1><p>SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1525517263421.png" alt="1525517263421"></p><p>以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！</p><h2 id="5-1-为什么是Thymeleaf？"><a href="#5-1-为什么是Thymeleaf？" class="headerlink" title="5.1.为什么是Thymeleaf？"></a>5.1.为什么是Thymeleaf？</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><p>接下来，我们就通过入门案例来体会Thymeleaf的魅力：</p><h2 id="5-2-提供数据的Controller"><a href="#5-2-提供数据的Controller" class="headerlink" title="5.2.提供数据的Controller"></a>5.2.提供数据的Controller</h2><p>编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/all&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">all</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户</span></span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">this</span>.userService.queryAll();</span><br><span class="line">    <span class="comment">// 放入模型</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, users);</span><br><span class="line">    <span class="comment">// 返回模板名称（就是classpath:/templates/目录下的html文件名）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUserAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-引入启动器"><a href="#5-3-引入启动器" class="headerlink" title="5.3.引入启动器"></a>5.3.引入启动器</h2><p>直接引入启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot会自动为Thymeleaf注册一个视图解析器：</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528133744136.png" alt="1528133744136"></p><p>与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528133816179.png" alt="1528133816179"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>一般我们无需进行修改，默认即可。</p><h2 id="5-4-静态页面"><a href="#5-4-静态页面" class="headerlink" title="5.4.静态页面"></a>5.4.静态页面</h2><p>根据上面的文档介绍，<strong>模板默认放在classpath下的templates文件夹</strong>，我们新建一个html文件放入其中：</p><p> <img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528134057401.png" alt="1528134057401"></p><p>编写html模板，渲染模型中的数据：</p><p>​            注意，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">table</span> &#123;<span class="attribute">border-collapse</span>: collapse; <span class="attribute">font-size</span>: <span class="number">14px</span>; <span class="attribute">width</span>: <span class="number">80%</span>; <span class="attribute">margin</span>: auto&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> solid darkslategray;<span class="attribute">padding</span>: <span class="number">10px</span>&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: darkslategray; font-size: 30px&quot;</span>&gt;</span>欢迎光临！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span>··</span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>生日<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.userName&#125;&quot;</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.sex&#125;&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.birthday&#125;&quot;</span>&gt;</span>1980-02-30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到这里使用了以下语法：</p><ul><li><code>$&#123;&#125;</code> ：这个类似el表达式，但其实是ognl的语法，比el表达式更加强大</li><li><code>th-</code>指令：<code>th-</code>是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用<code>data-th-</code>来代替<ul><li><code>th:each</code>：类似于<code>c:foreach</code>  遍历集合，但是语法更加简洁</li><li><code>th:text</code>：声明标签中的文本<ul><li>例如<code>&lt;td th-text=&#39;$&#123;user.id&#125;&#39;&gt;1&lt;/td&gt;</code>，如果user.id有值，会覆盖默认的1</li><li>如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！</li></ul></li></ul></li></ul><h2 id="5-5-测试"><a href="#5-5-测试" class="headerlink" title="5.5.测试"></a>5.5.测试</h2><p>接下来，我们打开页面测试一下：</p><p><img src="/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/1528134027726.png" alt="1528134027726"></p><h2 id="5-6-模板缓存"><a href="#5-6-模板缓存" class="headerlink" title="5.6.模板缓存"></a>5.6.模板缓存</h2><p>Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们<strong>开发阶段可以关掉缓存使</strong>用，在application.properties中修改：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发阶段关闭thymeleaf的模板缓存</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><pre><code>在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。eclipse中没有测试过。注意引入启动器后，需要import changes，并在右侧的maven处再次import</code></pre><p>我们可以修改页面，测试一下。</p><h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>什么是springboot</span><br><span class="line">    搭建spring应用的脚手架，内置tomcat。打包成jar，自动配置（根据引入的依赖）</span><br><span class="line">    简化的依赖管理  简化配置</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>java配置</span><br><span class="line">    原生的java配置</span><br><span class="line">        <span class="number">1.</span><span class="meta">@Configuration</span>``</span><br><span class="line">        <span class="number">2.</span><span class="meta">@Bean</span>:把方法的返回值注入到spring容器中</span><br><span class="line">        <span class="number">3.</span><span class="meta">@Value</span></span><br><span class="line">        <span class="number">4.</span><span class="meta">@PropertySource</span></span><br><span class="line">    springboot提供的java配置</span><br><span class="line">        <span class="number">1.</span><span class="meta">@ConfigurationProperties(prefix=&quot;jdbc&quot;)</span>:声明一个类是一个属性读取类，读取application.properties</span><br><span class="line">        <span class="number">2.</span><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line">             <span class="number">1</span> <span class="meta">@Autowired</span>注入</span><br><span class="line">            <span class="number">2</span> 构造方法注入</span><br><span class="line">            <span class="number">3</span> 通过<span class="meta">@Bean</span>方法参数注入</span><br><span class="line">            <span class="number">4</span> 直接在<span class="meta">@Bean</span>方法上使用<span class="meta">@ConfigurationProperties(prefix=&quot;jdbc&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>springboot的基本使用</span><br><span class="line">    搭建springboot基本应用</span><br><span class="line">        <span class="number">1.</span>引入统一的父工程以及需要的启动器</span><br><span class="line">        <span class="number">2.</span>覆盖默认配置</span><br><span class="line">        <span class="number">3.</span>添加引导类：<span class="meta">@SpringBootApplication(@EnableAutoConfiguration  @ComponentScan  @SpringBootConfiguration)</span></span><br><span class="line">            </span><br><span class="line">    整合springMVC</span><br><span class="line">        <span class="number">1.</span>修改端口(server.port=<span class="number">8888</span>)</span><br><span class="line">        <span class="number">2.</span>访问静态资源(classpath:...)</span><br><span class="line">        <span class="number">3.</span>拦截器：</span><br><span class="line">            <span class="number">1</span>)自定义拦截器：实现HandlerInterceptor接口</span><br><span class="line">            <span class="number">2</span>)配置拦截器：自定义一个java配置类(<span class="meta">@Configuration</span>)，实现WebMvcConfigurer接口</span><br><span class="line">            </span><br><span class="line">    整合数据源</span><br><span class="line">        <span class="number">1.</span>引入jdbc启动器与mysql驱动,内置hikariCP</span><br><span class="line">        <span class="number">2.</span>添加配置：spring.dataSource.url/password/username</span><br><span class="line">            </span><br><span class="line">    整合mybatis</span><br><span class="line">        <span class="number">1.</span>引入启动器</span><br><span class="line">        <span class="number">2.</span>覆盖默认配置：mybatis.type-aliases-<span class="keyword">package</span>=cn.cxh.pojo.user  mybatis.mapper-locations=classpath:mybatis/mappers<span class="comment">/**/*.xml</span></span><br><span class="line"><span class="comment">        3.代码：定义一个接口，在接口上添加<span class="doctag">@Mapper</span>注解</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">    整合通用mapper</span></span><br><span class="line"><span class="comment">        1.引入启动器</span></span><br><span class="line"><span class="comment">        2.代码：接口机型Mapper&lt;User&gt;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">    整合事务：</span></span><br><span class="line"><span class="comment">        添加<span class="doctag">@Transactional</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SpringBoot的作用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;掌握java配置的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;了</summary>
      
    
    
    
    <category term="乐优商城" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"/>
    
    <category term="springboot与thymeleaf" scheme="https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/springboot%E4%B8%8Ethymeleaf/"/>
    
    
    <category term="springboot" scheme="https://mrchen229.github.io/tags/springboot/"/>
    
    <category term="thymeleaf" scheme="https://mrchen229.github.io/tags/thymeleaf/"/>
    
  </entry>
  
</feed>
