{"meta":{"title":"pigDong","subtitle":"","description":"","author":"pigDong","url":"https://mrchen229.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-08-12T05:59:27.754Z","updated":"2020-08-11T06:04:17.638Z","comments":false,"path":"/404.html","permalink":"https://mrchen229.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-11T06:04:17.644Z","updated":"2020-08-11T06:04:17.644Z","comments":false,"path":"about/index.html","permalink":"https://mrchen229.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2020-08-11T06:04:17.651Z","updated":"2020-08-11T06:04:17.651Z","comments":false,"path":"repository/index.html","permalink":"https://mrchen229.github.io/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-08-11T06:04:17.645Z","updated":"2020-08-11T06:04:17.645Z","comments":false,"path":"books/index.html","permalink":"https://mrchen229.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-11T06:04:17.649Z","updated":"2020-08-11T06:04:17.649Z","comments":true,"path":"links/index.html","permalink":"https://mrchen229.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-12T05:58:42.160Z","updated":"2020-08-12T05:58:42.160Z","comments":false,"path":"categories/index.html","permalink":"https://mrchen229.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-12T05:59:15.606Z","updated":"2020-08-12T05:59:15.606Z","comments":false,"path":"tags/index.html","permalink":"https://mrchen229.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"栈_队列_数组_链表_红黑树_ArrayList_LinkedList_HashSet_LinkedHashSet_可变参数_Collections工具_Comparable_Comparator","slug":"05.集合/栈_队列_数组_链表_红黑树_ArrayList_LinkedList_HashSet_LinkedHashSet_可变参数_Collections工具_Comparable_Comparator","date":"2020-08-28T11:58:08.000Z","updated":"2020-08-28T12:00:01.721Z","comments":true,"path":"2020/08/28/05.集合/栈_队列_数组_链表_红黑树_ArrayList_LinkedList_HashSet_LinkedHashSet_可变参数_Collections工具_Comparable_Comparator/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/","excerpt":"","text":"知识点 栈、队列、数组、链表、红黑树 List集合 ArrayList LinkedList Set集合 HashSet LinkedHashSet 可变参数 Collections工具类 Comparable与Comparator 1. 数据结构1.1 数据结构有什么用？常见的数据结构：堆栈、队列、数组、链表和红黑树，了解它们的特点。 1.2 常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。 栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 对元素的存取有如下的特点: 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。 栈的入口、出口的都是栈的顶端位置。 注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 数组：Array，是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。 对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。 每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： ​ 二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: ​ 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 2. List集合12345java.util.List接口 extends Collection接口List接口的特点: 1.有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123) 2.有索引,包含了一些带索引的方法 3.允许存储重复的元素 12345678910List接口中带索引的方法(特有) - public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 - public E get(int index):返回集合中指定位置的元素。 - public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 - public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。注意: 操作索引的时候,一定要防止索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 2.1 List接口介绍​ java.util.List接口继承自Collection接口，是单列集合的一个重要分支，将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 2.2 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index): 返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element): 用指定元素替换集合中指定位置的元素, 返回值的更新前的元素。 List集合特有的方法都是跟索引相关： 12345678910111213141516171819202122232425262728293031323334353637383940public class ListDemo &#123; public static void main(String[] args) &#123; // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素 list.add(&quot;图图&quot;); list.add(&quot;小美&quot;); list.add(&quot;不高兴&quot;); System.out.println(list); // add(int index,String s) 往指定位置添加 list.add(1,&quot;没头脑&quot;); System.out.println(list); // String remove(int index) 删除指定位置元素 返回被删除元素 // 删除索引位置为2的元素 System.out.println(&quot;删除索引位置为2的元素&quot;); System.out.println(list.remove(2)); System.out.println(list); // String set(int index,String s) // 在指定位置 进行 元素替代（改） // 修改指定位置元素 list.set(0, &quot;三毛&quot;); System.out.println(list); // String get(int index) 获取指定位置元素 // 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; //还可以使用增强for for (String string : list) &#123; System.out.println(string); &#125; &#125;&#125; 3. List的子类3.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快。 3.2 LinkedList集合123456789101112131415161718java.util.LinkedList集合 implements List接口LinkedList集合的特点: 1.底层是一个链表结构:查询慢,增删快 2.里边包含了大量操作首尾元素的方法 注意:使用LinkedList集合特有的方法,不能使用多态 - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。 - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。 - public boolean isEmpty()：如果列表不包含元素，则返回true。 java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e): 将指定元素插入此列表的开头。 public void addLast(E e): 将指定元素添加到此列表的结尾。 public E getFirst(): 返回此列表的第一个元素。 public E getLast(): 返回此列表的最后一个元素。 public E removeFirst(): 移除并返回此列表的第一个元素。 public E removeLast(): 移除并返回此列表的最后一个元素。 public E pop(): 从此列表所表示的堆栈处弹出一个元素。 public void push(E e): 将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。 方法演示： 12345678910111213141516171819202122public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); //添加元素 link.addFirst(&quot;abc1&quot;); link.addFirst(&quot;abc2&quot;); link.addFirst(&quot;abc3&quot;); System.out.println(link); // 获取元素 System.out.println(link.getFirst()); System.out.println(link.getLast()); // 删除元素 System.out.println(link.removeFirst()); System.out.println(link.removeLast()); while (!link.isEmpty()) &#123; //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素 &#125; System.out.println(link); &#125;&#125; 4. Set接口 1234java.util.Set接口 extends Collection接口Set接口的特点: 1.不允许存储重复的元素 2.没有索引,没有带索引的方法,也不能使用普通的for循环遍历 123456java.util.HashSet集合 implements Set接口HashSet特点: 1.不允许存储重复的元素 2.没有索引,没有带索引的方法,也不能使用普通的for循环遍历 3.是一个无序的集合,存储元素和取出元素的顺序有可能不一致 4.底层是一个哈希表结构(查询的速度非常的快) ​ java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。 ​ 与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 ​ Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips: Set集合取出元素的方式可以采用：迭代器、增强for。 4.1 HashSet集合介绍 ​ java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持。 ​ HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。 保证元素唯一性的方式依赖于：hashCode与equals方法。 使用Set集合存储: 12345678910111213141516public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String(&quot;cba&quot;)); set.add(&quot;abc&quot;); set.add(&quot;bac&quot;); set.add(&quot;cba&quot;); //遍历 for (String name : set) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果如下，说明集合中不能存储重复元素： 123cbaabcbac tips: 字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。 4.2 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ ​ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 123456哈希值:是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址)在Object类有一个方法,可以获取对象的哈希值int hashCode() 返回该对象的哈希码值。hashCode方法的源码: public native int hashCode(); native:代表该方法调用的是本地操作系统的方法 4.3 HashSet存储自定义类型元素1234HashSet存储自定义类型元素set集合报错元素唯一: 存储的元素(String,Integer,...Student,Person...),必须重写hashCode方法和equals方法 ​ 给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(&quot;于谦&quot;, 43); stuSet.add(stu); stuSet.add(new Student(&quot;郭德纲&quot;, 44)); stuSet.add(new Student(&quot;于谦&quot;, 43)); stuSet.add(new Student(&quot;郭麒麟&quot;, 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] 4.4 LinkedHashSet123java.util.LinkedHashSet集合 extends HashSet集合LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(&quot;bbb&quot;); set.add(&quot;aaa&quot;); set.add(&quot;abc&quot;); set.add(&quot;bbc&quot;); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 4.5 可变参数12345678可变参数:是JDK1.5之后出现的新特性使用前提: 当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数.使用格式:定义方法时使用 修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;可变参数的原理: 可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数 传递的参数个数,可以是0个(不传递),1,2...多个 在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 JDK1.5以后。出现了简化操作。 ​ … 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。 代码演示： 1234567891011121314151617181920212223242526272829303132public class ChangeArgs &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 4, 62, 431, 2 &#125;; int sum = getSum(arr); System.out.println(sum); // 6 7 2 12 2121 // 求 这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); &#125; /* * 完成数组 所有元素的求和 原始写法 public static int getSum(int[] arr)&#123; int sum = 0; for(int a : arr)&#123; sum += a; &#125; return sum; &#125; */ //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 5. Collections工具类123- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： - public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 - public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 5.1 常用方法 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 12345678910111213141516171819public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[5, 222, 1, 2][1, 2, 5, 222] 代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？ 我们发现还有个方法没有讲，public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。 5.2 Comparator比较器123456789- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。注意: sort(List&lt;T&gt; list)使用前提 被排序的集合 里边 存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则Comparable接口的排序规则: 自己(this)-参数:升序 123456789- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator和Comparable的区别 Comparable:自己(this)和别人(参数)比较,自己需要实现Comparable接口,重写比较的规则compareTo方法 Comparator:相当于找一个第三方的裁判,比较两个Comparator的排序规则: o1-o2:升序 我们还是先研究这个方法 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 不过这次存储的是字符串类型。 123456789101112public class CollectionsDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;cba&quot;); list.add(&quot;aba&quot;); list.add(&quot;sba&quot;); list.add(&quot;nba&quot;); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125; 结果： 1[aba, cba, nba, sba] 我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？ ​ 说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 ​ 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; ​ String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 ​ public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一, 该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: 1234567891011121314151617public class CollectionsDemo3 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;cba&quot;); list.add(&quot;aba&quot;); list.add(&quot;sba&quot;); list.add(&quot;nba&quot;); //排序方法 按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0) - o1.charAt(0); &#125; &#125;); System.out.println(list); &#125;&#125; 结果如下： 1[sba, nba, cba, aba] 5.3 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 5.4 练习Comparable创建一个学生类，存储到ArrayList集合中完成指定排序操作。 Student 初始类 123456789101112131415161718192021222324252627282930313233343536public class Student&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526public class Demo &#123; public static void main(String[] args) &#123; // 创建四个学生对象 存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(&quot;rose&quot;,18)); list.add(new Student(&quot;jack&quot;,16)); list.add(new Student(&quot;abc&quot;,16)); list.add(new Student(&quot;ace&quot;,17)); list.add(new Student(&quot;mark&quot;,16)); /* 让学生 按照年龄排序 升序 */// Collections.sort(list);//要求 该list中元素类型 必须实现比较器Comparable接口 for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125; 发现，当我们调用Collections.sort()方法的时候 程序报错了。 原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。 于是我们就完成了Student类的一个实现，如下： 1234567public class Student implements Comparable&lt;Student&gt;&#123; .... @Override public int compareTo(Student o) &#123; return this.age-o.age;//升序 &#125;&#125; 再次测试，代码就OK 了效果如下： 12345Student&#123;name=&#x27;jack&#x27;, age=16&#125;Student&#123;name=&#x27;abc&#x27;, age=16&#125;Student&#123;name=&#x27;mark&#x27;, age=16&#125;Student&#123;name=&#x27;ace&#x27;, age=17&#125;Student&#123;name=&#x27;rose&#x27;, age=18&#125; 5.5 练习Comparator如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor&lt;T&gt; c)方式，自己定义规则： 123456Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o2.getAge()-o1.getAge();//以学生的年龄降序 &#125;&#125;); 效果： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125; 如果想要规则更多一些，可以参考下面代码： 12345678910111213Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 年龄降序 int result = o2.getAge()-o1.getAge();//年龄降序 if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序 result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); 效果如下： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;","categories":[{"name":"集合","slug":"集合","permalink":"https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"栈_队列_数组_链表_红黑树","slug":"栈-队列-数组-链表-红黑树","permalink":"https://mrchen229.github.io/tags/%E6%A0%88-%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://mrchen229.github.io/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://mrchen229.github.io/tags/LinkedList/"},{"name":"HashSet","slug":"HashSet","permalink":"https://mrchen229.github.io/tags/HashSet/"},{"name":"可变参数","slug":"可变参数","permalink":"https://mrchen229.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"},{"name":"Collections工具类","slug":"Collections工具类","permalink":"https://mrchen229.github.io/tags/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Comparable与Comparator","slug":"Comparable与Comparator","permalink":"https://mrchen229.github.io/tags/Comparable%E4%B8%8EComparator/"}]},{"title":"Collection_Iterator(增强for)_泛型(泛型通配符)","slug":"05.集合/Collection_Iterator(增强for)_泛型(泛型通配符)","date":"2020-08-28T06:51:08.000Z","updated":"2020-08-28T07:16:29.956Z","comments":true,"path":"2020/08/28/05.集合/Collection_Iterator(增强for)_泛型(泛型通配符)/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/","excerpt":"","text":"知识点 Collection集合 Iterator迭代器 增强for 泛型 泛型类、方法、接口 泛型通配符(只能使用Object类中的共性方法) 1. Collection集合共性的方法123java.util.Collection接口 所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法 任意的单列集合都可以使用Collection接口中的方法 12345678共性的方法: public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 1.1 集合概述 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别**是java.util.List和java.util.Set**。 其中，List的特点是元素有序、元素可重复。 Set的特点是元素无序，而且不可重复。 List接口的主要实现类有java.util.ArrayList和java.util.LinkedList Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 ​ 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用方法Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() : 清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println(&quot;判断 扫地僧 是否在集合中&quot;+coll.contains(&quot;扫地僧&quot;)); //boolean remove(E e) 删除在集合中的o元素 System.out.println(&quot;删除石破天：&quot;+coll.remove(&quot;石破天&quot;)); System.out.println(&quot;操作之后集合中元素:&quot;+coll); // size() 集合中有几个元素 System.out.println(&quot;集合中有&quot;+coll.size()+&quot;个元素&quot;); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println(&quot;集合中内容为：&quot;+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 2. Iterator迭代器2.1 Iterator接口123456java.util.Iterator接口:迭代器(对集合进行遍历)有两个常用的方法 boolean hasNext() 如果仍有元素可以迭代，则返回 true。 判断集合中还有没有下一个元素,有就返回true,没有就返回false E next() 返回迭代的下一个元素。 取出集合中的下一个元素 123Iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象,获取实现类的方式比较特殊Collection接口中有一个方法,叫iterator(),这个方法返回的就是迭代器的实现类对象 Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。 1234迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 3.使用Iterator接口中的方法next取出集合中的下一个元素 ​ 在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。 ​ Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而**Iterator主要用于迭代访问（即遍历）Collection中的元素**，因此Iterator对象也被称为迭代器。 获取迭代器的方法想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(&quot;串串星人&quot;); coll.add(&quot;吐槽星人&quot;); coll.add(&quot;汪星人&quot;); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理 当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，演示Iterator对象迭代元素的过程： ​ 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for(foreach)123456789101112增强for循环:底层使用的也是迭代器,使用for循环的格式,简化了迭代器的书写是JDK1.5之后出现的新特性Collection &lt;E&gt; extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强forpublic interface Iterable&lt;T&gt; 实现这个接口允许对象成为 &quot;foreach&quot; 语句的目标。增强for循环:用来遍历集合和数组格式: for(集合/数组的数据类型 变量名: 集合名/数组名)&#123; sout(变量名); &#125; 增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1: 遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2: 遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(&quot;小河神&quot;); coll.add(&quot;老河神&quot;); coll.add(&quot;神婆&quot;); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 3. 泛型3.1 泛型概述 创建集合对象,使用泛型 好处: 1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型 2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) 弊端: 泛型是什么类型,只能存储什么类型的数据 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 创建集合对象，不使用泛型 好处： ​ 集合不使用泛型，默认是Object类型，可以存储任意类型的数据 弊端： ​ 不安全，会引发异常 大家观察下面代码： 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add(&quot;abc&quot;); coll.add(&quot;itcast&quot;); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 为什么会发生类型转换异常呢？ ​ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ ​ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;abc&quot;); list.add(&quot;itcast&quot;); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips: 泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(&quot;大胡子登登&quot;); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(&quot;aaa&quot;); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口12345678含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型public interface Iterator&lt;E&gt; &#123; E next();&#125;Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重写的next方法泛型默认就是Stringpublic final class Scanner implements Iterator&lt;String&gt;&#123; public String next() &#123;&#125;&#125; 定义格式： 1修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(&quot;aa&quot;); &#125;&#125; 3.4 泛型通配符泛型的通配符: ?:代表任意的数据类型 使用方式: 不能创建对象使用 只能作为方法的参数使用 当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。 一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的。 通配符高级使用—-受限泛型泛型的上限限定: ? extends E 代表使用的泛型只能是E类型的子类/本身 泛型的下限限定: ? super E 代表使用的泛型只能是E类型的父类/本身 之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;","categories":[{"name":"集合","slug":"集合","permalink":"https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Collection集合","slug":"Collection集合","permalink":"https://mrchen229.github.io/tags/Collection%E9%9B%86%E5%90%88/"},{"name":"Iterator迭代器","slug":"Iterator迭代器","permalink":"https://mrchen229.github.io/tags/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"增强for","slug":"增强for","permalink":"https://mrchen229.github.io/tags/%E5%A2%9E%E5%BC%BAfor/"},{"name":"泛型类_方法_接口","slug":"泛型类-方法-接口","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%96%B9%E6%B3%95-%E6%8E%A5%E5%8F%A3/"},{"name":"泛型通配符","slug":"泛型通配符","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"}]},{"title":"Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_包装类与拆装箱_基本类型与String转换","slug":"03.常用API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_包装类与拆装箱_基本类型与String转换","date":"2020-08-28T05:20:08.000Z","updated":"2020-08-28T07:15:36.446Z","comments":true,"path":"2020/08/28/03.常用API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_包装类与拆装箱_基本类型与String转换/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/03.%E5%B8%B8%E7%94%A8API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E6%8B%86%E8%A3%85%E7%AE%B1_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"知识点 Object类 Object类的toString方法 Object类的equals方法 Objects类 Date类 DateFormat类(Date与String之间的转换) Calendar类（方便获取各个时间属性） System类 currentTimeMillis方法 arraycopy方法 StringBuilder类 包装类与自动拆装箱 基本类型与字符串之间的转换 1. Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它其中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类，那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。 tips: 直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较​ 如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较​ 如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： tips：Object类当中的hashCode等其他方法，今后学习。 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是 null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b): 判断两个对象是否相等。 源码： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 2. 日期时间类2.1 Date类概述 java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 getTime()方法（返回毫秒值）Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类（Date的转换）​ java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换, 也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法​ 由于DateFormat为抽象类，不能直接使用，所以需要**常用的子类java.text.SimpleDateFormat**。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; &#125; 常用方法format parseDateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); String str = &quot;2018年12月11日&quot;; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 Calendar类（方便获取各个时间属性）概念java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 创建方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2015年1月18日; &#125;&#125; getTime方法（返回Date对象）Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 3. System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 4. StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = &quot;Hello&quot;; s += &quot;World&quot;; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 ​ 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(&quot;itcast&quot;); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(&quot;hello&quot;); //对比一下 System.out.println(&quot;builder:&quot;+builder); System.out.println(&quot;builder2:&quot;+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(&quot;hello&quot;); builder.append(&quot;world&quot;); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100); System.out.println(&quot;builder:&quot;+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 5. 包装类5.1 概述 Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.3 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(&quot;100&quot;); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[{"name":"常用API","slug":"常用API","permalink":"https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"}],"tags":[{"name":"Object类(toString_equals)","slug":"Object类-toString-equals","permalink":"https://mrchen229.github.io/tags/Object%E7%B1%BB-toString-equals/"},{"name":"Objects类","slug":"Objects类","permalink":"https://mrchen229.github.io/tags/Objects%E7%B1%BB/"},{"name":"Date类","slug":"Date类","permalink":"https://mrchen229.github.io/tags/Date%E7%B1%BB/"},{"name":"DateFormat类(Date与String之间的转换)","slug":"DateFormat类-Date与String之间的转换","permalink":"https://mrchen229.github.io/tags/DateFormat%E7%B1%BB-Date%E4%B8%8EString%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"name":"Calendar类(方便获取各个时间属性)","slug":"Calendar类-方便获取各个时间属性","permalink":"https://mrchen229.github.io/tags/Calendar%E7%B1%BB-%E6%96%B9%E4%BE%BF%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"},{"name":"System类","slug":"System类","permalink":"https://mrchen229.github.io/tags/System%E7%B1%BB/"},{"name":"StringBuilder类","slug":"StringBuilder类","permalink":"https://mrchen229.github.io/tags/StringBuilder%E7%B1%BB/"},{"name":"包装类与自动拆装箱","slug":"包装类与自动拆装箱","permalink":"https://mrchen229.github.io/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"},{"name":"基本类型与字符串之间的转换","slug":"基本类型与字符串之间的转换","permalink":"https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"}]},{"title":"final_权限修饰符_成员内部类_匿名内部类_引用类型用法(class_interface)","slug":"04.继承与多态/final_权限修饰符_成员内部类_匿名内部类_引用类型用法(class_interface)","date":"2020-08-28T01:40:08.000Z","updated":"2020-08-28T01:40:55.505Z","comments":true,"path":"2020/08/28/04.继承与多态/final_权限修饰符_成员内部类_匿名内部类_引用类型用法(class_interface)/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95(class_interface)/","excerpt":"","text":"知识点 final关键字 权限修饰符 成员内部类 匿名内部类 引用类型用法(class interface) 1. final关键字1.1 概述学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 final 关键字，用于修饰不可改变内容。 final： 不可改变。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 1.2 使用方式修饰类 12final class 类名 &#123;&#125; 查询API发现像 public final class String 、 public final class Math 、 public final class Scanner等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。 修饰方法123修饰符 final 返回值类型 方法名(参数列表)&#123; //方法体&#125; 重写被 final 修饰的方法，编译时就会报错。 修饰变量局部变量——基本类型基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。 123456789101112131415public class FinalDemo1 &#123; public static void main(String[] args) &#123; // 声明变量，使用final修饰 final int a; // 第一次赋值 a = 10; // 第二次赋值 a = 20; // 报错,不可重新赋值 // 声明变量，直接赋值，使用final修饰 final int b = 10; // 第二次赋值 b = 20; // 报错,不可重新赋值 &#125;&#125; 局部变量——引用类型引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下： 12345678910public class FinalDemo2 &#123; public static void main(String[] args) &#123; // 创建 User 对象 final User u = new User(); // 创建 另一个 User对象 u = new User(); // 报错，指向了新的对象，地址值改变。 // 调用setName方法 u.setName(&quot;张三&quot;); // 可以修改 &#125;&#125; 成员变量成员变量涉及到初始化的问题，初始化方式有两种，只能二选一： 显示初始化 1234public class User &#123; final String USERNAME = &quot;张三&quot;; private int age;&#125; 构造方法初始化 12345678public class User &#123; final String USERNAME ; private int age; public User(String username, int age) &#123; this.USERNAME = username; this.age = age; &#125;&#125; 被final修饰的常量名称，一般都有书写规范，所有字母都大写。 2. 权限修饰符public protected default private在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， public：公共的。 protected：受保护的 default：默认的 private：私有的 2.1 不同权限的访问能力 public protected default（空的） private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。 建议： 成员变量使用 private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用 public ，方便调用方法。 小贴士：不加权限修饰符，其访问能力与default修饰符相同 3. 内部类3.1 概述​ 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 3.2 成员内部类成员内部类 ：定义在类中方法外的类。 定义格式： 1234class 外部类 &#123; class 内部类&#123; &#125;&#125; 在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 创建内部类对象格式： 1外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； 示例： 1234567891011121314151617181920public class Person &#123; private boolean live = true; class Heart &#123; public void jump() &#123; // 直接访问外部类成员 if (live) &#123; System.out.println(&quot;心脏在跳动&quot;); &#125; else &#123; System.out.println(&quot;心脏不跳了&quot;); &#125; &#125; &#125; public boolean isLive() &#123; return live; &#125; public void setLive(boolean live) &#123; this.live = live; &#125;&#125; 123456789101112public static void main(String[] args) &#123; // 创建外部类对象 Person p = new Person(); // 创建内部类对象 Heart heart = p.new Heart(); // 调用内部类方法 heart.jump(); // 调用外部类方法 p.setLive(false); // 调用内部类方法 heart.jump();&#125; 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Person$Heart.class 3.3 匿名内部类【重点】匿名内部类 ：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。 前提​ 匿名内部类必须继承一个父类或者实现一个父接口。 格式1234567new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 使用方式以接口为例，匿名内部类的使用示例：定义接口： 123public abstract class FlyAble&#123; public abstract void fly();&#125; 创建匿名内部类，并调用： 123456789101112131415public class InnerDemo &#123; public static void main(String[] args) &#123; /* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 */ FlyAble f = new FlyAble()&#123; //相当于重写接口方法的子类，并且创建对象 public void fly() &#123; System.out.println(&quot;我飞了~~~&quot;); &#125; &#125;; //调用 fly方法,执行重写后的方法 f.fly(); &#125;&#125; 在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。 4. 引用类型用法总结​ 实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。 4.1 class作为成员变量 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。 4.2 interface作为成员变量 接口是对方法的封装接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。 4.3 interface作为方法参数和返回值类型​ 当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 ArrayList 类我们并不陌生，查看API我们发现，实际上，它是 java.util.List 接口的实现类。所以，当我们看见 List 接口作为参数或者返回值类型时，当然可以将 ArrayList 的对象进行传递或返回。 接口作为参数时，传递它的子类对象。接口作为返回值类型时，返回它的子类对象。","categories":[{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"}],"tags":[{"name":"final关键字","slug":"final关键字","permalink":"https://mrchen229.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"权限修饰符","slug":"权限修饰符","permalink":"https://mrchen229.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"成员内部类","slug":"成员内部类","permalink":"https://mrchen229.github.io/tags/%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"https://mrchen229.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"引用类型用法(class interface)","slug":"引用类型用法-class-interface","permalink":"https://mrchen229.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95-class-interface/"}]},{"title":"接口成员_接口多实现方法细节_多态前提与上下转型_instanceof","slug":"04.继承与多态/接口成员_接口多实现方法细节_多态前提与上下转型_instanceof","date":"2020-08-27T02:32:08.000Z","updated":"2020-08-27T02:32:52.496Z","comments":true,"path":"2020/08/27/04.继承与多态/接口成员_接口多实现方法细节_多态前提与上下转型_instanceof/","link":"","permalink":"https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98_%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82_%E5%A4%9A%E6%80%81%E5%89%8D%E6%8F%90%E4%B8%8E%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B_instanceof/","excerpt":"","text":"知识点 接口成员的定义 接口多实现的细节(多个方法的实现) 接口的限制 多态的前提 多态的向上向下转型 多态的转型异常(instanceof) 1. 接口1.1 概述​ 接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。​ 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 ​ 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 1.2 接口定义格式123456public interface 接口名称 &#123; // 抽象方法 // 默认方法 // 静态方法 // 私有方法&#125; 含有抽象方法 抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。 123public interface InterFaceName &#123; public abstract void method();&#125; 含有默认方法和静态方法 默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。 静态方法：使用 static 修饰，供接口直接调用。 12345678public interface InterFaceName &#123; public default void method() &#123; // 执行语句 &#125; public static void method2() &#123; // 执行语句 &#125;&#125; 含有私有方法和私有静态方法私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。 12345public interface InterFaceName &#123; private void method() &#123; // 执行语句 &#125;&#125; 1.3 基本的实现实现的概述​ 类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。 非抽象子类实现接口： 必须重写接口中所有抽象方法。 继承了接口的默认方法，即可以直接调用，也可以重写。 实现格式： 1234class 类名 implements 接口名 &#123; // 重写接口中抽象方法【必须】 // 重写接口中默认方法【可选】&#125; 抽象方法的使用 必须全部实现 默认方法的使用可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 1.继承默认方法 2.重写默认方法 静态方法的使用静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 私有方法的使用 私有方法：只有默认方法可以调用。 私有静态方法：默认方法和静态方法可以调用。 如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。 1.4 接口的多实现​ 之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。 1234class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123; // 重写接口中抽象方法【必须】 // 重写接口中默认方法【不重名时可选】&#125; [ ]： 表示可选操作。 抽象方法​ 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。 默认方法​ 接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。 静态方法​ 接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。 优先级的问题​ 当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。 1.5 接口的多继承​ 一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。 子接口重写默认方法时，default关键字可以保留。子类重写默认方法时，default关键字不可以保留。 1.6 接口其他成员特点（限制） 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 接口中，没有构造方法，不能创建对象。 接口中，没有静态代码块。 1.7 小结123456789101112131415161718192021222324在Java 9+版本中，接口的内容可以有：1. 成员变量其实是常量，格式： [public] [static] [final] 数据类型 常量名称 = 数据值; 注意： 常量必须进行赋值，而且一旦赋值不能改变。 常量名称完全大写，用下划线进行分隔。2. 接口中最重要的就是抽象方法，格式： [public] [abstract] 返回值类型 方法名称(参数列表); 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。3. 从Java 8开始，接口里允许定义默认方法，格式： [public] default 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 注意：默认方法也可以被覆盖重写4. 从Java 8开始，接口里允许定义静态方法，格式： [public] static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法5. 从Java 9开始，接口里允许定义私有方法，格式： 普通私有方法：private 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 静态私有方法：private static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。 2. 多态2.1 概述多态是继封装、继承之后，面向对象的第三大特性。 多态： 是指同一行为，具有多个不同表现形式。 前提（★） 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 2.2 多态的体现多态体现的格式： 12父类类型 变量名 = new 子类对象；变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 2.3 多态的好处​ 实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。 2.4 引用类型转换 ​ 多态的转型分为向上转型与向下转型两种： 向上转型 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 使用格式： 12父类类型 变量名 = new 子类类型();如：Animal a = new Cat(); 向下转型 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 12子类类型 变量名 = (子类类型) 父类变量名;如: Cat c =(Cat) a; 为什么要转型​ 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 示例： 12345678910111213141516171819abstract class Animal &#123; abstract void eat();&#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse() &#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void watchHouse() &#123; System.out.println(&quot;看家&quot;); &#125;&#125; 12345678910public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125;&#125; 转型的异常12345678910public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 &#125;&#125; 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。 为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 12345变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。eg: a instanceof Cat","categories":[{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"}],"tags":[{"name":"接口成员的定义","slug":"接口成员的定义","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"name":"接口多实现方法细节","slug":"接口多实现方法细节","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82/"},{"name":"接口的限制","slug":"接口的限制","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%99%90%E5%88%B6/"},{"name":"多态的前提","slug":"多态的前提","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90/"},{"name":"多态的上下转型","slug":"多态的上下转型","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B/"},{"name":"instanceof","slug":"instanceof","permalink":"https://mrchen229.github.io/tags/instanceof/"}]},{"title":"继承_super_this_abstract","slug":"04.继承与多态/继承_super_this_abstract","date":"2020-08-27T01:34:08.000Z","updated":"2020-08-27T01:35:17.250Z","comments":true,"path":"2020/08/27/04.继承与多态/继承_super_this_abstract/","link":"","permalink":"https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/","excerpt":"","text":"知识点 三大特性之继承 super关键字 this关键字 abstract方法与abstract类 1. 继承1.1 概述​ 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。 ​ 其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。​ 继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 好处 提高代码的复用性。 类与类之间产生了关系，是多态的前提。 1.2 继承的格式​ 通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 123456class 父类 &#123; ...&#125; class 子类 extends 父类 &#123; ...&#125; 1.3 继承后的特点——成员变量​ 当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？ 成员变量不重名​ 如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。 成员变量重名​ 如果子类父类中出现重名的成员变量，这时的访问是有影响的。 123456789101112131415161718192021222324252627class Fu &#123; // Fu中的成员变量。 int num = 5;&#125; class Zi extends Fu &#123; // Zi中的成员变量 int num = 6; public void show() &#123; // 访问父类中的num System.out.println(&quot;Fu num=&quot; + num); // 访问子类中的num System.out.println(&quot;Zi num=&quot; + num); &#125;&#125; class ExtendsDemo03 &#123; public static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125;&#125; 演示结果： Fu num = 6 Zi num = 6 ​ 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this 。 1super.父类成员变量名 Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。 通常编码时，我们遵循封装的原则，使用private修饰成员变量，那如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。 1.4 继承后的特点——成员方法当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？ 成员方法不重名​ 如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 成员方法重名——重写(Override)​ 如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 123456789101112131415161718class Fu &#123; public void show() &#123; System.out.println(&quot;Fu show&quot;); &#125;&#125; class Zi extends Fu &#123; //子类重写了父类的show方法 public void show() &#123; System.out.println(&quot;Zi show&quot;); &#125;&#125; public class ExtendsDemo05&#123; public static void main(String[] args) &#123; Zi z = new Zi(); // 子类中有show方法，只执行重写后的show方法 z.show(); // Zi show &#125;&#125; 子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。 用到super.父类成员方法，表示调用父类的成员方法。 重写的注意事项 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 1.5 继承后的特点——构造方法当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？ 首先我们要回忆两个事情，构造方法的定义格式和作用。 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。 12345678910111213141516171819202122class Fu &#123; private int n; Fu()&#123; System.out.println(&quot;Fu()&quot;); &#125;&#125;class Zi extends Fu &#123; Zi()&#123; // super（），调用父类构造方法 super(); System.out.println(&quot;Zi（）&quot;); &#125;&#125; public class ExtendsDemo07&#123; public static void main (String args[])&#123; Zi zi = new Zi(); &#125;&#125; 输出结果： Fu（） Zi（） 1.6 super和this 父类空间优先于子类对象产生​ 在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。 ​ 代码体现在子类的构造方法调用时，一定先调用父类的构造方法。 super和this的含义 super ：代表父类的存储空间标识(可以理解为父亲的引用)。 this ：代表当前对象的引用(谁调用就代表谁)。 super和this的用法 访问成员 1234this.成员变量 ‐‐ 本类的super.成员变量 ‐‐ 父类的this.成员方法名() ‐‐ 本类的super.成员方法名() ‐‐ 父类的 访问构造方法 12this(...) ‐‐ 本类的构造方法super(...) ‐‐ 父类的构造方法 子类的每个构造方法中均有默认的super()**，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 1.7 继承的特点 Java只支持单继承，不支持多继承。 123//一个类只能有一个父类，不可以有多个父类。class C extends A&#123;&#125; //okclass C extends A，B... //error Java支持多层继承(继承体系)。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; 顶层父类是Object类。所有的类默认继承Object，作为父类。 子类和父类是一种相对的概念。 2. 抽象类2.1 概述​ 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 定义 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 2.2 abstract使用格式抽象方法​ 使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。 1修饰符 abstract 返回值类型 方法名 (参数列表)； 抽象类​ 如果一个类包含抽象方法，那么该类必须是抽象类。 12abstract class 类名字 &#123;&#125; 抽象的使用​ 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。 2.3 注意事项关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。","categories":[{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"}],"tags":[{"name":"三大特性之继承","slug":"三大特性之继承","permalink":"https://mrchen229.github.io/tags/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"},{"name":"super关键字","slug":"super关键字","permalink":"https://mrchen229.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"this关键字","slug":"this关键字","permalink":"https://mrchen229.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"abstract方法与abstract类","slug":"abstract方法与abstract类","permalink":"https://mrchen229.github.io/tags/abstract%E6%96%B9%E6%B3%95%E4%B8%8Eabstract%E7%B1%BB/"}]},{"title":"Scanner_Random_ArrayList_String常见方法_Arrays_Math_static关键字","slug":"03.常用API/Scanner_Random_ArrayList_String常见方法_Arrays_Math_static关键字","date":"2020-08-26T14:58:08.000Z","updated":"2020-08-26T14:59:55.308Z","comments":true,"path":"2020/08/26/03.常用API/Scanner_Random_ArrayList_String常见方法_Arrays_Math_static关键字/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/03.%E5%B8%B8%E7%94%A8API/Scanner_Random_ArrayList_String%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95_Arrays_Math_static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"知识点 Scanner类 Random类 ArrayList类 String类的常用方法 Arrays类的方法 Math类 static关键字（static变量、static方法、static代码块） 1. API​ API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。 1.1 API使用步骤 打开帮助文档。 点击显示，找到索引，看到输入框。 在输入框里输入内容，然后回车。 看包。java.lang下的类不需要导包，其他需要。 看类的解释和说明。 学习构造方法 使用成员方法 2. Scanner类2.1 什么是Scanner类​ 一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 System.in 中读取一个数： 12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); 备注：System.in 系统输入指的是通过键盘录入数据。 2.2 引用类型使用步骤导包​ 使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 12import 包名.类名;eg: import java.util.Scanner 创建对象​ 使用该类的构造方法，创建一个该类的对象。 1数据类型 变量名 = new 数据类型(参数列表); 调用方法​ 调用该类的成员方法，完成指定功能。 1变量名.方法名(); 2.3 Scanner使用步骤查看类 java.util.Scanner ：该类需要import导入后使用。 查看构造方法 public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 查看成员方法 public int nextInt() ：将输入信息的下一个标记扫描为一个 int 值。 使用Scanner类，完成接收键盘录入数据的操作，代码如下： 12345678910111213//1. 导包import java.util.Scanner;public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println(&quot;请录入一个整数：&quot;); int i = sc.nextInt(); //4. 输出数据 System.out.println(&quot;i:&quot;+i); &#125;&#125; 2.4 匿名对象​ 创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。 匿名对象 ：没有变量名的对象。 格式: 1new 类名(参数列表)； 应用场景 创建匿名对象直接调用方法，没有变量名。 1new Scanner(System.in).nextInt(); 一旦调用两次方法，就是创建了两个对象，造成浪费 匿名对象可以作为方法的参数和返回值 作为参数 123456789101112class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125;&#125; 作为返回值 12345678910111213class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125; 3. Random类3.1 什么是Random类此类的实例用于生成伪随机数。例如，以下代码使用户能够得到一个随机数： 12Random r = new Random();int i = r.nextInt(); 3.2 Random使用步骤 查看类java.util.Random ：该类需要 import导入使后使用。 查看构造方法public Random() ：创建一个新的随机数生成器。 查看成员方法public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的int 值。 使用Random类，完成生成3个10以内的随机整数的操作，代码如下： 1234567891011121314//1. 导包import java.util.Random;public class Demo01_Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 int number = r.nextInt(10); //4. 输出数据 System.out.println(&quot;number:&quot;+ number); &#125; &#125;&#125; 创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。 获取随机数获取1-n之间的随机数，包含n，代码如下： 12345678910111213// 导包import java.util.Random;public class Test01Random &#123; public static void main(String[] args) &#123; int n = 50; // 创建对象 Random r = new Random(); // 获取随机数 int number = r.nextInt(n) + 1; // 输出随机数 System.out.println(&quot;number:&quot; + number); &#125;&#125; 4. ArrayList类 想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需求。 为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据 4.1 什么是ArrayList类java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。 4.2 ArrayList使用步骤 查看类 java.util.ArrayList &lt;E&gt; ：该类需要 import导入使后使用。 &lt;E&gt; ，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下： 1ArrayList&lt;String&gt;，ArrayList&lt;Student&gt; 查看构造方法 public ArrayList() ：构造一个内容为空的集合。基本格式: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： 1ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 查看成员方法public boolean add(E e) ： 将指定的元素添加到此集合的尾部。参数 E e ，在构造ArrayList对象时， &lt;E&gt; 指定了什么数据类型，那么 add(E e) 方法中，只能添加什么数据类型的对象。 使用ArrayList类，存储三个字符串元素，代码如下： 12345678910111213141516171819public class Test02StudentArrayList &#123; public static void main(String[] args) &#123; //创建学生数组 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //创建学生对象 String s1 = &quot;曹操&quot;; String s2 = &quot;刘备&quot;; String s3 = &quot;孙权&quot;; //打印学生ArrayList集合 System.out.println(list); //把学生对象作为元素添加到集合 list.add(s1); list.add(s2); list.add(s3); //打印学生ArrayList集合 System.out.println(list); &#125;&#125; 4.3 常用方法和遍历对于元素的操作,基本体现在——增、删、查。常用的方法有： public boolean add(E e) ：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 这些都是最基本的方法，操作非常简单，代码如下: 1234567891011121314151617181920212223242526public class Demo01ArrayListMethod &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //public E get(int index):返回指定索引处的元素 System.out.println(&quot;get:&quot;+list.get(0)); System.out.println(&quot;get:&quot;+list.get(1)); System.out.println(&quot;get:&quot;+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(&quot;size:&quot;+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(&quot;remove:&quot;+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++)&#123; System.out.println(list.get(i)); &#125; &#125;&#125; 4.4 如何存储基本数据类型​ ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 &lt;int&gt; 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下： 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5. String类5.1 String类概述java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。 类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。 5.2 特点 字符串不变：字符串的值在创建后不能被更改。 1234String s1 = &quot;abc&quot;;s1 += &quot;d&quot;;System.out.println(s1); // &quot;abcd&quot;// 内存中有&quot;abc&quot;，&quot;abcd&quot;两个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。 因为String对象是不可变的，所以它们可以被共享。 123String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。 &quot;abc&quot; 等效于 char[] data=&#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125; 。 123456例如：String str = &quot;abc&quot;;相当于：char data[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;String str = new String(data);// String底层是靠字符数组实现的。 字符串的常量池 5.3 使用步骤 查看类 java.lang.String ：此类不需要导入。 查看构造方法 public String() ：初始化新创建的 String对象，以使其表示空字符序列。 public String(char[] value) ：通过当前参数中的字符数组来构造新的String。 public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。 构造举例，代码如下： 12345678// 无参构造String str = new String（）；// 通过字符数组构造char chars[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;;String str3 = new String(bytes); 5.4 常用方法判断功能的方法 public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。 public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写。方法演示，代码如下： 12345678910111213141516public class String_Demo01 &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; String s3 = &quot;HELLO&quot;; // boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s1.equals(s2)); // true System.out.println(s1.equals(s3)); // false System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); //boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); // true System.out.println(s1.equalsIgnoreCase(s3)); // true System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); &#125;&#125; Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。 获取功能的方法 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。 方法演示，代码如下 12345678910111213141516171819202122232425262728293031323334public class String_Demo02 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;helloworld&quot;; // int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length()); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String concat (String str):将将指定的字符串连接到该字符串的末尾. String s = &quot;helloworld&quot;; String s2 = s.concat(&quot;**hello itheima&quot;); System.out.println(s2);// helloworld**hello itheima // char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1 System.out.println(s.indexOf(&quot;l&quot;)); System.out.println(s.indexOf(&quot;owo&quot;)); System.out.println(s.indexOf(&quot;ak&quot;)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String substring(int start):从start开始截取字符串到字符串结尾 System.out.println(s.substring(0)); System.out.println(s.substring(5)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String substring(int start,int end):从start到end截取字符串。含start，不含end。 System.out.println(s.substring(0, s.length())); System.out.println(s.substring(3,8)); &#125;&#125; 转换功能的方法 public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 方法演示，代码如下： 1234567891011121314151617181920212223public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;abcde&quot;; // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); for(int x = 0; x &lt; chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); // byte[] getBytes ():把字符串转换为字节数组 byte[] bytes = s.getBytes(); for(int x = 0; x &lt; bytes.length; x++) &#123; System.out.println(bytes[x]); &#125; System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); // 替换字母it为大写IT String str = &quot;itcast itheima&quot;; String replace = str.replace(&quot;it&quot;, &quot;IT&quot;); System.out.println(replace); // ITcast ITheima System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); &#125;&#125; CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中 分割功能的方法 public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 方法演示，代码如下： 12345678910public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;aa|bb|cc&quot;; String[] strArray = s.split(&quot;|&quot;); // [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;] for(int x = 0; x &lt; strArray.length; x++) &#123; System.out.println(strArray[x]); // aa bb cc &#125; &#125;&#125; 6. Arrays类6.1 概述 java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 6.2 操作数组的方法 public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 12345678910public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;2,34,35,4,657,8,69,9&#125;; // 打印数组,输出地址值 System.out.println(arr); // [I@2ac1fdc4 // 数组内容转为字符串 String s = Arrays.toString(arr); // 打印字符串,输出内容 System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9]&#125; public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 12345678public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;24, 7, 5, 48, 4, 46, 35, 11, 6, 2&#125;; System.out.println(&quot;排序前:&quot;+ Arrays.toString(arr)); // 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6, 2] // 升序排序 Arrays.sort(arr); System.out.println(&quot;排序后:&quot;+ Arrays.toString(arr));// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]&#125; 7. Math类7.1 概述​ java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 7.2 基本运算的方法 public static double abs(double a) ：返回 double 值的绝对值。 12double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.abs(5); //d2的值为5 public static double ceil(double a) ：返回大于等于参数的最小的整数。 12double d1 = Math.ceil(3.3); //d1的值为 4.0double d2 = Math.ceil(‐3.3); //d2的值为 ‐3.0 public static double floor(double a) ：返回小于等于参数最大的整数。 12double d1 = Math.floor(3.3); //d1的值为3.0double d2 = Math.floor(‐3.3); //d2的值为‐4.0 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法) 12long d1 = Math.round(5.5); //d1的值为6.0long d2 = Math.round(5.4); //d2的值为5.0 8. static关键字8.1 概述​ 关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 8.2 定义和使用格式类变量​ 当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 类变量：使用 static关键字修饰的成员变量。 定义格式： 1static 数据类型 变量名； 静态方法​ 当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。 类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。 定义格式： 123修饰符 static 返回值类型 方法名 (参数列表)&#123; // 执行语句&#125; 静态方法调用的注意事项： 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this关键字。 小贴士：静态方法只能访问静态成员。 调用格式​ 被static修饰的成员可以并且建议通过类名直接访问。 ​ 虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。 格式： 1234// 访问类变量类名.类变量名；// 调用静态方法类名.静态方法名(参数)； 8.3 静态原理图解 static 修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。 8.4 静态代码块 静态代码块：定义在成员位置，使用static修饰的代码块{ }。 位置：类中方法外。 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。 格式： 12345public class ClassName&#123; static &#123; // 执行语句 &#125;&#125; 作用：给类变量进行初始化赋值。 static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。","categories":[{"name":"常用API","slug":"常用API","permalink":"https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"}],"tags":[{"name":"Scanner类","slug":"Scanner类","permalink":"https://mrchen229.github.io/tags/Scanner%E7%B1%BB/"},{"name":"Random类","slug":"Random类","permalink":"https://mrchen229.github.io/tags/Random%E7%B1%BB/"},{"name":"ArrayList类","slug":"ArrayList类","permalink":"https://mrchen229.github.io/tags/ArrayList%E7%B1%BB/"},{"name":"String类的常用方法","slug":"String类的常用方法","permalink":"https://mrchen229.github.io/tags/String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"Arrays类的方法","slug":"Arrays类的方法","permalink":"https://mrchen229.github.io/tags/Arrays%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"},{"name":"Math类","slug":"Math类","permalink":"https://mrchen229.github.io/tags/Math%E7%B1%BB/"},{"name":"static变量_static方法_static代码块","slug":"static变量-static方法-static代码块","permalink":"https://mrchen229.github.io/tags/static%E5%8F%98%E9%87%8F-static%E6%96%B9%E6%B3%95-static%E4%BB%A3%E7%A0%81%E5%9D%97/"}]},{"title":"类与对象_对象内存图_封装_this_构造_JavaBean","slug":"02.面向对象和封装/类与对象_对象内存图_封装_this_构造_JavaBean","date":"2020-08-26T07:52:08.000Z","updated":"2020-08-26T07:53:14.470Z","comments":true,"path":"2020/08/26/02.面向对象和封装/类与对象_对象内存图_封装_this_构造_JavaBean/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/","excerpt":"","text":"知识点 面向对象 类与对象 对象内存图 封装 private、this关键字 构造方法 JavaBean 1. 面向对象1.1 面向对象思想概述​ Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 区别: 面向过程：强调步骤。 面向对象：强调对象。 面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特征，即封装、继承和多态。 1.2 类和对象 1.类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。 现实中，描述一类事物： 属性：就是该事物的状态信息。 行为：就是该事物能够做什么。 举例：小猫。 ​ 属性：名字、体重、年龄、颜色。 行为：走、跑、叫。 2.对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。 举例：一只小猫。 ​ 属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。 3.类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 1.3 类的定义 事物与类的对比 :现实世界的一类事物： 属性：事物的状态信息。 行为：事物能够做什么。 Java中用class描述事物也是如此： 成员变量：对应事物的属性 成员方法：对应事物的行为 类的定义格式1234public class ClassName &#123; //成员变量 //成员方法&#125; 定义类：就是定义类的成员，包括成员变量和成员方法。 成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法：和以前定义方法几乎是一样的。只不过把static去掉，static的作用在面向对象后面课程中再详细讲解。 1.4 对象的使用对象的使用格式创建对象： 1类名 对象名 = new 类名(); 使用对象访问类中的成员: 12对象名.成员变量；对象名.成员方法()； 成员变量的默认值 数据类型 默认值 基本类型 整数（byte，short，int，long） 0 浮点数（float，double） 0.0 字符（char） ‘\\u0000’ 布尔（boolean） false 引用类型 数组，类，接口 null 1.5 对象内存图一个对象，调用一个方法内存图 通过上图，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。 但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。 补充：图中的X是指方法调用完出栈。 两个对象，调用同一方法内存图 对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。 补充：图中的X是指方法调用完出栈。 两个引用指向同一对象的内存图 一个引用，作为参数传递到方法中内存图 引用类型作为参数，传递的是地址值。 使用对象类型作为方法的参数 使用对象类型作为方法的返回值 1.6 成员变量和局部变量区别​ 变量根据定义位置的不同，我们给变量起了不同的名字。如下图所示： 在类中的位置不同 重点 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 重点 成员变量：类中 局部变量：方法中 初始化值的不同 重点 成员变量：有默认值 局部变量：没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 2. 封装2.1 封装概述​ 面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 原则将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 2.2 封装的步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。 2.3 封装的操作——private关键字private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 private的使用格式1private 数据类型 变量名 ； 2.4 封装优化1——this关键字 我们发现 setXxx 方法中的形参名字并不符合见名知意的规定，那么如果修改与成员变量名一致，是否就见名知意了呢？ 12345678910public class Student &#123; private String name; private int age; public void setName(String name) &#123; name = name; &#125; public void setAge(int age) &#123; age = age; &#125;&#125; 经过修改和测试，我们发现新的问题，成员变量赋值失败了。也就是说，在修改了 setXxx() 的形参变量名后，方法并没有给成员变量赋值！这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。所以，我们只能使用this关键字，来解决这个重名问题。 this的含义​ this代表所在类的当前对象的引用（地址值），即对象自己的引用。 记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 this使用格式1this.成员变量名 方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。 2.5 封装优化2——构造方法​ 当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。 小贴士：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。 构造方法的定义格式123修饰符 构造方法名(参数列表)&#123; // 方法体&#125; 构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型。 注意事项 如果你不提供构造方法，系统会给出无参数构造方法。 如果你提供了构造方法，系统将不再提供无参数构造方法。 构造方法是可以重载的，既可以定义参数，也可以不定义参数。 2.6 标准代码——JavaBean​ JavaBean 是 Java语言编写类的一种标准规范。 ​ 符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 123456789public class ClassName&#123; //成员变量 //构造方法 //无参构造方法【必须】 //有参构造方法【建议】 //成员方法 //getXxx() //setXxx()&#125;","categories":[{"name":"面向对象和封装","slug":"面向对象和封装","permalink":"https://mrchen229.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/"}],"tags":[{"name":"类与对象","slug":"类与对象","permalink":"https://mrchen229.github.io/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"name":"对象内存图","slug":"对象内存图","permalink":"https://mrchen229.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"封装private","slug":"封装private","permalink":"https://mrchen229.github.io/tags/%E5%B0%81%E8%A3%85private/"},{"name":"this","slug":"this","permalink":"https://mrchen229.github.io/tags/this/"},{"name":"构造","slug":"构造","permalink":"https://mrchen229.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://mrchen229.github.io/tags/JavaBean/"}]},{"title":"一维数组定义_内存图_作为方法参数与返回值","slug":"01.Java基础语法/一维数组定义_内存图_作为方法参数与返回值","date":"2020-08-26T05:07:08.000Z","updated":"2020-08-26T05:13:02.611Z","comments":true,"path":"2020/08/26/01.Java基础语法/一维数组定义_内存图_作为方法参数与返回值/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/","excerpt":"","text":"知识点 一维数组定义与索引 一维数组内存图 一维数组常见操作 数组作为方法参数与返回值 1. 数组定义和访问​ 数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 1.1 数组的定义方式一12数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];eg: int[] arr = new int[3]; 数组定义格式详解： 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [] : 表示数组。 数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 new：关键字，创建数组使用的关键字。 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [长度]：数组的长度，表示数组容器中可以存储多少个元素。 注意：数组有定长特性，长度一旦指定，不可更改。 和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。 方式二12数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;eg: int[] arr = new int[]&#123;1,2,3,4,5&#125;; 方式三12数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;eg: int[] arr = &#123;1,2,3,4,5&#125;; 1.2 数组的访问 索引： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 1数组名[索引] 数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度 语句为： 1数组名.length ，属性length的执行结果是数组的长度，int类型结果。由此可以推断出，数组的最大索引值为 数组名.length-1 。 索引访问数组中的元素： 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，取出数组中的元素 2. 数组原理内存图2.1 内存概述​ 内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。​ Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 2.2 Java虚拟机的内存划分​ 为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 JVM的内存划分： 区域名称 作用 寄存器 给CPU使用，和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组，new来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如main方法运行，进入方法栈中执行 2.3 数组在内存中的存储一个数组内存图1234public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr);//[I@5f150435&#125; ​ 以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。​ 输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素 两个数组内存图123456public static void main(String[] args) &#123; int[] arr = new int[3]; int[] arr2 = new int[2]; System.out.println(arr); System.out.println(arr2);&#125; 两个引用指向一个数组12345678910111213141516public static void main(String[] args) &#123; // 定义数组，存储3个元素 int[] arr = new int[3]; //数组索引进行赋值 arr[0] = 5; arr[1] = 6; arr[2] = 7; //输出3个索引上的元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); //定义数组变量arr2，将arr的地址赋值给arr2 int[] arr2 = arr; arr2[1] = 9; System.out.println(arr[1]);&#125; 3. 数组的常见操作3.1 数组越界异常1234public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arr[3]);&#125; ​ 创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 3.2 数组空指针异常12345public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; arr = null; System.out.println(arr[0]);｝ ​ arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 空指针异常在内存图中的表现 3.3 数组长度运行期间不可改变 3.4 数组遍历数组遍历： 就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。 1234int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 3.5 数组获取最大值元素 最大值获取：从数组的所有元素中找出最大值。 123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++) &#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println(&quot;数组最大值是： &quot; + max);&#125; 3.6 数组反转 数组的反转： 数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 123456789101112131415161718public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 4. 数组作为方法参数和返回值4.1 数组作为方法参数 **数组作为方法参数传递，传递的参数是数组内存的地址。 ** 1234567891011121314public static void main(String[] args) &#123; int[] arr = &#123; 1, 3, 5, 7, 9 &#125;; //调用方法，传递数组 printArray(arr); &#125; /* 创建方法，方法接收数组类型的参数 进行数组的遍历 */ public static void printArray(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 4.2 数组作为方法返回值 数组作为方法的返回值，返回的是数组的内存地址 1234567891011121314151617public static void main(String[] args) &#123; //调用方法，接收数组的返回值 //接收到的是数组的内存地址 int[] arr = getArray(); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; /* 创建方法，返回值是数组类型 return返回数组的地址*/public static int[] getArray() &#123; int[] arr = &#123; 1, 3, 5, 7, 9 &#125;; //返回数组的地址，返回到调用者 return arr;&#125; 补充 方法的参数为基本类型时,传递的是数据值。 方法的参数为引用类型时,传递的是地址值.","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"一维数组定义与索引","slug":"一维数组定义与索引","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%B4%A2%E5%BC%95/"},{"name":"一维数组内存图","slug":"一维数组内存图","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"数组作为方法参数与返回值","slug":"数组作为方法参数与返回值","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/"},{"name":"数组常见操作","slug":"数组常见操作","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"}]},{"title":"IDEA使用_方法重载与执行","slug":"01.Java基础语法/IDEA_方法重载与执行","date":"2020-08-26T02:50:08.000Z","updated":"2020-08-26T02:51:49.755Z","comments":true,"path":"2020/08/26/01.Java基础语法/IDEA_方法重载与执行/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/","excerpt":"","text":"知识点 IDEA使用 定义方法与方法重载 1. IDEA 回顾一下开发Java程序的步骤： 编写代码 启动cmd 调用javac编译 调用java运行 集成开发环境，是一种专门用来提高Java开发效率的软件。 ​ 免费的IDE当中：Eclipse​ 收费的IDE当中：IntelliJ IDEA免费+收费所有的IDE当中：全世界用得最多的就是IntelliJ IDEA IDEA是一个专门针对Java的集成开发工具(IDE)，由Java语言编写。所以，需要有JRE运行环境并配置好环境变量。它可以极大地提升我们的开发效率。可以自动编译，检查错误。 File-&gt;new-&gt;Project 创建Project选择java，并选择jdk的位置。 首次新建项目时，默认的Project Location路径有问题，如 c:\\\\xxx ，正确写法为 c:\\xxx 。更改后不会再出现此类问题。 1.1 创建包和类展开创建的工程，在源代码目录 src 上，鼠标右键，选择 new-&gt;package ，键入包名。 所谓包，就是文件夹，用来对类文件进行管理。 在创建好的包上，鼠标右键，选择 new-&gt;class 创建类，键入类名。 1.2 字体设置File-&gt;Settings-&gt;Editor-&gt;Font 修改字体 1.3 IDEA的项目目录 我们创建的项目，在project目录的文件夹下 .idea 目录和 demo.iml 和我们开发无关，是IDEA工具自己使用的 out 目录是存储编译后的.class文件 src 目录是存储我们编写的.java源文件 1.4 IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标位置下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+i 自动生成代码，toString，get，set等方法 Alt+Shift+上下箭头 移动当前代码行 1.5 IDEA修改快捷键​ 在IDEA工具中， Ctrl+空格 的快捷键，可以帮助我们补全代码，但是这个快捷键和Windows中的输入法切换快捷键冲突，需要修改IDEA中的快捷键。1.File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic 2.双击 Basic-&gt;选择remove Ctrl+空格 3.再次双击 Basic-&gt;Add Keyboard-&gt;键入 Alt+/-&gt;点击OK 1.6 IDEA导入和关闭项目​ 关闭IDEA中已经存在的项目， File-&gt;Close Project File-&gt;Close Project 这时IDEA回到了刚启动界面，点击项目上的 X ，IDEA中就没有这个项目了 若要打开，在IDEA的启动界面上，点击 OPEN ，选择项目目录即可 2. 方法2.1 定义方法的格式1234修饰符 返回值类型 方法名(参数列表)&#123; //代码省略... return 结果;&#125; 修饰符： public static 固定写法 返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者 参数列表：方法在运算过程中的未知数据，调用者调用方法时传递 return：将方法执行后的结果带给调用者，方法执行到 return ，整体方法运行结束 return 结果; 正确的叫法为方法的返回值 2.2 定义方法的两个明确 需求：定义方法实现两个整数的求和计算。 明确返回值类型：方法计算的是整数的求和，结果也必然是个整数，返回值类型定义为int类型。 明确参数列表：计算哪两个整数的和，并不清楚，但可以确定是整数，参数列表可以定义两个int类型的变量，由调用者调用方法时传递 1234567891011121314151617public class Method_Demo2 &#123; public static void main(String[] args) &#123; // 调用方法getSum，传递两个整数，这里传递的实际数据又称为实际参数 // 并接收方法计算后的结果，返回值 int sum = getSum(5, 6); System.out.println(sum); &#125; /* 定义 计算两个整数和的方法 返回值类型，计算结果是int 参数：不确定数据求和，定义int参数.参数又称为形式参数 */ public static int getSum(int a, int b) &#123; return a + b; &#125;&#125; 程序执行，主方法 main 调用 getSum 方法，传递了实际数据 5和6 ，两个变量 a和b 接收到的就是实际参数，并将计算后的结果返回，主方法 main 中的变量 sum 接收的就是方法的返回值。 2.3 定义方法的注意事项 定义位置，类中方法外面。返回值类型，必须要和 return 语句返回的类型相同，否则编译失败 。 不能在 return 后面写代码， return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。 不能用输出语句调用 void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。 123456// 返回值类型要求是intpublic static int getSum() &#123; return 5;// 正确，int类型 return 1.2;// 错误，类型不匹配 return true;// 错误，类型不匹配&#125; 2.4 方法重载 方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 参数列表：个数不同，数据类型不同，顺序不同。 重载方法调用：JVM通过方法的参数列表，调用不同的方法。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"IDEA使用","slug":"IDEA使用","permalink":"https://mrchen229.github.io/tags/IDEA%E4%BD%BF%E7%94%A8/"},{"name":"方法重载与执行","slug":"方法重载与执行","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"}]},{"title":"判断_选择_循环","slug":"01.Java基础语法/判断_选择_循环","date":"2020-08-26T01:56:08.000Z","updated":"2020-08-26T01:56:54.151Z","comments":true,"path":"2020/08/26/01.Java基础语法/判断_选择_循环/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%88%A4%E6%96%AD_%E9%80%89%E6%8B%A9_%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"知识点 判断语句 选择语句 循环语句 1. 判断语句1.1 if123if(关系表达式)｛ 语句体;｝ 1.2 if…else12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; 1.3 if..else if…else1234567891011if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125; ...&#125;else if (判断条件n) &#123; 执行语句n;&#125; else &#123; 执行语句n+1;&#125; 2. 选择语句2.1 switch123456789101112switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 注意： switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。 2.2 case的穿透性​ 在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会再判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 3. 循环语句3.1 for123for(初始化表达式①; 布尔表达式②; 步进表达式④)&#123; 循环体③&#125; 执行流程 执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。 ①负责完成循环变量初始化 ②负责判断是否满足循环条件，不满足则跳出循环 ③具体执行的语句 ④循环后，循环条件所涉及变量的变化情况 3.2 while12345初始化表达式①while(布尔表达式②)&#123; 循环体③ 步进表达式④&#125; 执行流程 执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。 ①负责完成循环变量初始化。 ②负责判断是否满足循环条件，不满足则跳出循环。 ③具体执行的语句。 ④循环后，循环变量的变化情况。 3.3 do…while12345初始化表达式①do&#123; 循环体③ 步进表达式④&#125;while(布尔表达式②); 执行流程 执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。①负责完成循环变量初始化。②负责判断是否满足循环条件，不满足则跳出循环。③具体执行的语句④循环后，循环变量的变化情况 do…while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。 3.4 for 和 while 的小区别 for所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 3.5 跳出语句break 使用场景：终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景：结束本次循环，继续下一次的循环 4. 扩展知识点死循环​ 死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。例如：while(true){}。 嵌套循环12345for(初始化表达式①; 循环条件②; 步进表达式⑦) &#123; for(初始化表达式③; 循环条件④; 步进表达式⑥) &#123; 执行语句⑤; &#125;&#125; 嵌套循环执行流程： 执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥外循环一次，内循环多次。比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"判断语句","slug":"判断语句","permalink":"https://mrchen229.github.io/tags/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"},{"name":"选择语句","slug":"选择语句","permalink":"https://mrchen229.github.io/tags/%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"},{"name":"循环语句","slug":"循环语句","permalink":"https://mrchen229.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"}]},{"title":"数据类型转换_运算符_方法定义","slug":"01.Java基础语法/数据类型转换_运算符_方法定义","date":"2020-08-26T01:17:08.000Z","updated":"2020-08-26T01:17:27.340Z","comments":true,"path":"2020/08/26/01.Java基础语法/数据类型转换_运算符_方法定义/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2_%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/","excerpt":"","text":"知识点 数据类型间的自动转换与强制转换 算数、比较、逻辑、三元运算符( 注意+= ) 方法定义 1.数据类型之间的转换​ Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。 1.1 自动转换一个 int 类型变量和一个 byte 类型变量进行加法运算， 结果是什么数据类型？ 运算结果，变量的类型将是 int 类型，这就是出现了数据类型的自动类型转换现象。 自动转换：将取值范围小的类型自动提升为取值范围大的类型 。 12345int i = 1;byte b = 2; // 一个byte是8位，范围-128-127// byte x = b + i; // 报错// int类型和byte类型运算，结果是int类型int j = b + i; 转换原理图解​ byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。 同样道理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。 12345int i = 1;double d = 2.5;//int类型和double类型运算，结果是double类型//int类型会提升为double类型double e = d+i; 转换规则​ 范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 1.2 强制转换​ 将 1.5 赋值到 int 类型变量会发生什么？产生编译失败，肯定无法赋值。 1int i = 1.5; // 错误 ​ double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。可以理解为 double 是8升的水壶， int 是4升的水壶，不能把大水壶中的水直接放进小水壶去。 ​ 想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。 强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。 比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。 ​ 转换格式： 数据类型 变量名 = （数据类型）被转数据值; ​ 将 1.5 赋值到 int 类型，代码修改为： 12// double类型数据强制转成int类型，直接去掉小数点。int i = (int)1.5; ​ 同样道理，当一个 short 类型与 1 相加，若想将结果赋值给short类型变量，就需要强制转换。 1234567891011//short类型变量，内存中2个字节short s = 1;/* 出现编译失败 s和1做运算的时候，1是int类型，s会被提升为int类型 s+1后的结果是int类型，将结果在赋值会short类型时发生错误 short内存2个字节，int类型4个字节 必须将int强制转成short才能完成赋值*/s = s + 1；//编译失败s = (short)(s+1);//编译成功 转换原理图解 注意点 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失 1234// 定义s为short范围内最大值short s = 32767;// 运算后，强制转换，砍掉2个字节后会出现不确定的结果s = (short)(s + 10); 1.3 ASCII编码表1234567public static void main(String[] args) &#123; //字符类型变量 char c = &#x27;a&#x27;; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98&#125; 在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。 编码表 ：就是将人类的文字和一个十进制数进行对应起来组成一张表格。 见ASCII表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 在char类型和int类型计算的过程中，char类型的字符先查询编码表，得到97，再和1求和，结果为98。char类型提升为int类型。char类型内存2个字节，int类型内存4个字节。 2. 运算符2.1 算数运算符 算数运算符包括： + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++ 、 – 自增自减运算 Java中，整数使用以上运算符，无论怎么计算，也不会得到小数。 12int i = 1234;System.out.println(i/1000*1000);//计算结果是1000 ++ 运算，变量自己增长1。反之， -- 运算，变量自己减少1，用法与 ++ 一致。 独立运算： 变量在独立运算时， 前++ 和 后++ 没有区别 。 混合运算： 和其他变量放在一起， 前++ 和 后++ 就产生了不同。 变量++ ： 即 a=1; b=a++; 得到a为 2，b为1。 ++变量 : 即 a=1; b=++a; 得到a为 2，b为2。 + 符号在字符串中的操作： 123+ 符号在遇到字符串的时候，表示连接、拼接的含义。 &quot;a&quot;+&quot;b&quot;的结果是“ab”，连接含义 System.out.println(&quot;5+5=&quot;+5+5);//输出5+5=55 2.2 赋值运算符 赋值运算符包括： = 等于号 += 加等于 -= 减等于 *= 乘等于 /= 除等于 %= 取模等 12eg : i+=5;//计算方式 i=i+5 变量i先加5，再赋值变量i 2.3 比较运算符 比较运算符包括： == 比较符号两边数据是否相等，相等结果是true。 &lt; 比较符号左边的数据是否小于右边的数据，如果小于结果是true。 &gt; 比较符号左边的数据是否大于右边的数据，如果大于结果是true。 &lt;= 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。 &gt;= 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。 ！= 不等于符号 ，如果符号两边的数据不相等，结果是true。 比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。 2.4 逻辑运算符 逻辑运算符包括： &amp;&amp; 短路与 1. 两边都是true，结果是true2. 一边是false，结果是false 短路特点：符号左边是false，右边不再运算 || 短路或 1. 两边都是false，结果是false 2. 一边是true，结果是true 短路特点： 符号左边是true，右边不再运算 ！ 取反 1. ! true 结果是false 2. ! false结果是true 逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false 2.5 三元运算符 三元运算符格式： 1数据类型 变量名 = 布尔类型表达式？结果1：结果2 三元运算符计算方式：布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 3. 方法入门3.1 概述 方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 3.2 方法的定义定义格式： 1234修饰符 返回值类型 方法名 （参数列表）｛ 代码... return ;｝ 定义格式解释： 修饰符： 目前固定写法 public static 。 返回值类型： 目前固定写法 void ，其他返回值类型在后面的课程讲解。 方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。 参数列表： 目前无参数， 带有参数的方法在后面的课程讲解。 return：方法结束。因为返回值类型是void，方法大括号内的return可以不写。 3.3 注意事项 方法定义注意事项： 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 4. 扩展知识点+=符号 12345public static void main(String[] args)&#123; short s = 1; s+=1; System.out.println(s);&#125; ​ 分析： s += 1 逻辑上看作是 s = s + 1 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， s=s+1进行两次运算 ， += 是一个运算符，只运算一次，并带有强制转换的特点。 ​ 也就是说s += 1 就是 s = (short)(s + 1) ，因此程序没有问题编译通过，运行结果是2 常量和变量的运算12345678public static void main(String[] args)&#123; byte b1=1; byte b2=2; byte b3=1 + 2; byte b4=b1 + b2; System.out.println(b3); System.out.println(b4);&#125; 分析： b3 = 1 + 2 ， 1 和 2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 ，因此b3=1 + 2 是正确的。 ​ 反之， b4 = b2 + b3 ， b2 和 b3 是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b2+b3的结果是什么，因此会将结果以int类型进行处理，所以int类型不能赋值给byte类型，因此编译失败。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据类型转换","slug":"数据类型转换","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"运算符细节","slug":"运算符细节","permalink":"https://mrchen229.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%86%E8%8A%82/"},{"name":"方法定义","slug":"方法定义","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"}]},{"title":"进制_Java执行顺序_常量_数据类型","slug":"01.Java基础语法/进制-Java执行顺序-常量-数据类型","date":"2020-08-25T07:27:08.000Z","updated":"2020-08-26T01:14:41.281Z","comments":true,"path":"2020/08/25/01.Java基础语法/进制-Java执行顺序-常量-数据类型/","link":"","permalink":"https://mrchen229.github.io/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"知识点 进制转换 JVM JRE JDK关系 Java程序执行过程 标识符的写法 常量 变量的定义 基本数据类型的分类 1. 计算机基础知识二进制​ 计算机中全部采用二进制数表示数据，它只包含0、1，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特）。 十进制数据转成二进制数据 ​ 使用除以2获取余数的方式 二进制数据转成十进制数据 ​ 使用8421编码的方式 二进制数系统中，每个0或1就是一个位，叫做bit（比特）。 字节123456789101112131415 字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性可以查看文件的字节大小。8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。位（bit）：一个数字0或者一个数字1，代表一位。 字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。 1 Byte &#x3D; 8 bit 1 KB &#x3D; 1024 Byte 1 MB &#x3D; 1024 KB 1 GB &#x3D; 1024 MB 1 TB &#x3D; 1024 GB 1 PB &#x3D; 1024 TB 1 EB &#x3D; 1024 PB 1 ZB &#x3D; 1024 EB 常用DOS命令 命令 操作符号 盘符切换命令 盘符名: 查看当前文件夹 dir 进入文件夹命令 cd 文件夹名 or cd 文件夹1\\文件夹2\\文件夹3 返回上一级 cd .. 退出到磁盘根目录 cd \\ 清屏 cls 退出 exit 2. JVM JRE JDK Java虚拟机——JVM​ JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。​ 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 ​ 如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。 JRE 和 JDK​ JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的核心类库 。​ JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 运行一个已有的Java程序，只需安装 JRE 即可。开发一个全新的Java程序，则必须安装 JDK 。 3. Java程序执行过程Java程序开发三步骤：编写、编译、运行 。 编写 新建文件，文件名修改为 xxx.java。 在文件中键入文本并保存： 12345public class xxx &#123; public static void main(String[] args) &#123; System.out.println(&quot;xxx&quot;); &#125;&#125; 文件名必须是 xxx ，保证文件名和类的名字是一致的，注意大小写。 ​ 此时需要将编写好的 Java源文件，编译成JVM可以看懂的字节码文件 。 编译在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。 ​ 命令：javac Java源文件名.java ​ 编译成功后，命令行没有任何提示。打开 Java源文件名对应的目录，发现产生了一个新的文件 xxx.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 Java源文件的编译工具 javac.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。 运行在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。 命令: java 类名字 ​ Java程序 .class文件 的运行工具 java.exe ，在JDK安装目录的bin目录下。由于配置了环境变量，可以再任意目录下使用。 补充编译和运行​ 编译：是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。​ 运行：是指将 class文件交给JVM去运行，此时JVM就会去执行我们编写的程序了。 关于main方法​ main方法：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 注释​ Java中有单行注释和多行注释 12单行注释以 &#x2F;&#x2F;开头 换行结束多行注释以 &#x2F;*开头 以*&#x2F;结束 标识符​ 标识符：是指在程序中自己定义的内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 命名规则： 硬性要求 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 标识符不能以数字开头。 标识符不能是关键字。 命名规范： 软性建议 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 变量名规范：全部小写。 4. 常量​ 常量：是指在Java程序中固定不变的数据。 分类 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’ ， ‘ ‘， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值（流程控制中讲解） true ， false 空常量 只有一个值（引用数据类型中讲解） null 5. 变量和数据类型变量概述​ 变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。 数据类型数据类型分类Java的数据类型分为两大类： 基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。 引用数据类型：包括 类 、 数组 、 接口、字符串、lambda 。 注意事项： 字符串不是基本类型，而是引用类型。 浮点型可能只是一个近似值，并非精确的值。 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。 浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。 基本数据类型​ 四类八种基本数据类型： 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int（默认） 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认） 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false Java中的默认类型：整数类型是 int 、浮点类型是 double 。 变量定义变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值 。 格式: 数据类型 变量名 = 数据值; ​ long类型：建议数据后加L表示。​ float类型：建议数据后加F表示 注意事项​ 变量名称：在同一个大括号范围内，变量的名字不可以相同。​ 变量赋值：定义的变量，不赋值不能使用。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"进制转换","slug":"进制转换","permalink":"https://mrchen229.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"name":"Java开发过程","slug":"Java开发过程","permalink":"https://mrchen229.github.io/tags/Java%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/"},{"name":"常量与数据类型","slug":"常量与数据类型","permalink":"https://mrchen229.github.io/tags/%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]}],"categories":[{"name":"集合","slug":"集合","permalink":"https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"},{"name":"常用API","slug":"常用API","permalink":"https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"},{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"},{"name":"面向对象和封装","slug":"面向对象和封装","permalink":"https://mrchen229.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/"},{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"栈_队列_数组_链表_红黑树","slug":"栈-队列-数组-链表-红黑树","permalink":"https://mrchen229.github.io/tags/%E6%A0%88-%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://mrchen229.github.io/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://mrchen229.github.io/tags/LinkedList/"},{"name":"HashSet","slug":"HashSet","permalink":"https://mrchen229.github.io/tags/HashSet/"},{"name":"可变参数","slug":"可变参数","permalink":"https://mrchen229.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"},{"name":"Collections工具类","slug":"Collections工具类","permalink":"https://mrchen229.github.io/tags/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Comparable与Comparator","slug":"Comparable与Comparator","permalink":"https://mrchen229.github.io/tags/Comparable%E4%B8%8EComparator/"},{"name":"Collection集合","slug":"Collection集合","permalink":"https://mrchen229.github.io/tags/Collection%E9%9B%86%E5%90%88/"},{"name":"Iterator迭代器","slug":"Iterator迭代器","permalink":"https://mrchen229.github.io/tags/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"增强for","slug":"增强for","permalink":"https://mrchen229.github.io/tags/%E5%A2%9E%E5%BC%BAfor/"},{"name":"泛型类_方法_接口","slug":"泛型类-方法-接口","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%96%B9%E6%B3%95-%E6%8E%A5%E5%8F%A3/"},{"name":"泛型通配符","slug":"泛型通配符","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"},{"name":"Object类(toString_equals)","slug":"Object类-toString-equals","permalink":"https://mrchen229.github.io/tags/Object%E7%B1%BB-toString-equals/"},{"name":"Objects类","slug":"Objects类","permalink":"https://mrchen229.github.io/tags/Objects%E7%B1%BB/"},{"name":"Date类","slug":"Date类","permalink":"https://mrchen229.github.io/tags/Date%E7%B1%BB/"},{"name":"DateFormat类(Date与String之间的转换)","slug":"DateFormat类-Date与String之间的转换","permalink":"https://mrchen229.github.io/tags/DateFormat%E7%B1%BB-Date%E4%B8%8EString%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"name":"Calendar类(方便获取各个时间属性)","slug":"Calendar类-方便获取各个时间属性","permalink":"https://mrchen229.github.io/tags/Calendar%E7%B1%BB-%E6%96%B9%E4%BE%BF%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"},{"name":"System类","slug":"System类","permalink":"https://mrchen229.github.io/tags/System%E7%B1%BB/"},{"name":"StringBuilder类","slug":"StringBuilder类","permalink":"https://mrchen229.github.io/tags/StringBuilder%E7%B1%BB/"},{"name":"包装类与自动拆装箱","slug":"包装类与自动拆装箱","permalink":"https://mrchen229.github.io/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"},{"name":"基本类型与字符串之间的转换","slug":"基本类型与字符串之间的转换","permalink":"https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"name":"final关键字","slug":"final关键字","permalink":"https://mrchen229.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"权限修饰符","slug":"权限修饰符","permalink":"https://mrchen229.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"成员内部类","slug":"成员内部类","permalink":"https://mrchen229.github.io/tags/%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"https://mrchen229.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"引用类型用法(class interface)","slug":"引用类型用法-class-interface","permalink":"https://mrchen229.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95-class-interface/"},{"name":"接口成员的定义","slug":"接口成员的定义","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"name":"接口多实现方法细节","slug":"接口多实现方法细节","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82/"},{"name":"接口的限制","slug":"接口的限制","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%99%90%E5%88%B6/"},{"name":"多态的前提","slug":"多态的前提","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90/"},{"name":"多态的上下转型","slug":"多态的上下转型","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B/"},{"name":"instanceof","slug":"instanceof","permalink":"https://mrchen229.github.io/tags/instanceof/"},{"name":"三大特性之继承","slug":"三大特性之继承","permalink":"https://mrchen229.github.io/tags/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"},{"name":"super关键字","slug":"super关键字","permalink":"https://mrchen229.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"this关键字","slug":"this关键字","permalink":"https://mrchen229.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"abstract方法与abstract类","slug":"abstract方法与abstract类","permalink":"https://mrchen229.github.io/tags/abstract%E6%96%B9%E6%B3%95%E4%B8%8Eabstract%E7%B1%BB/"},{"name":"Scanner类","slug":"Scanner类","permalink":"https://mrchen229.github.io/tags/Scanner%E7%B1%BB/"},{"name":"Random类","slug":"Random类","permalink":"https://mrchen229.github.io/tags/Random%E7%B1%BB/"},{"name":"ArrayList类","slug":"ArrayList类","permalink":"https://mrchen229.github.io/tags/ArrayList%E7%B1%BB/"},{"name":"String类的常用方法","slug":"String类的常用方法","permalink":"https://mrchen229.github.io/tags/String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"Arrays类的方法","slug":"Arrays类的方法","permalink":"https://mrchen229.github.io/tags/Arrays%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"},{"name":"Math类","slug":"Math类","permalink":"https://mrchen229.github.io/tags/Math%E7%B1%BB/"},{"name":"static变量_static方法_static代码块","slug":"static变量-static方法-static代码块","permalink":"https://mrchen229.github.io/tags/static%E5%8F%98%E9%87%8F-static%E6%96%B9%E6%B3%95-static%E4%BB%A3%E7%A0%81%E5%9D%97/"},{"name":"类与对象","slug":"类与对象","permalink":"https://mrchen229.github.io/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"name":"对象内存图","slug":"对象内存图","permalink":"https://mrchen229.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"封装private","slug":"封装private","permalink":"https://mrchen229.github.io/tags/%E5%B0%81%E8%A3%85private/"},{"name":"this","slug":"this","permalink":"https://mrchen229.github.io/tags/this/"},{"name":"构造","slug":"构造","permalink":"https://mrchen229.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://mrchen229.github.io/tags/JavaBean/"},{"name":"一维数组定义与索引","slug":"一维数组定义与索引","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%B4%A2%E5%BC%95/"},{"name":"一维数组内存图","slug":"一维数组内存图","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"数组作为方法参数与返回值","slug":"数组作为方法参数与返回值","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/"},{"name":"数组常见操作","slug":"数组常见操作","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"},{"name":"IDEA使用","slug":"IDEA使用","permalink":"https://mrchen229.github.io/tags/IDEA%E4%BD%BF%E7%94%A8/"},{"name":"方法重载与执行","slug":"方法重载与执行","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"},{"name":"判断语句","slug":"判断语句","permalink":"https://mrchen229.github.io/tags/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"},{"name":"选择语句","slug":"选择语句","permalink":"https://mrchen229.github.io/tags/%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"},{"name":"循环语句","slug":"循环语句","permalink":"https://mrchen229.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数据类型转换","slug":"数据类型转换","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"运算符细节","slug":"运算符细节","permalink":"https://mrchen229.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%86%E8%8A%82/"},{"name":"方法定义","slug":"方法定义","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"},{"name":"进制转换","slug":"进制转换","permalink":"https://mrchen229.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"name":"Java开发过程","slug":"Java开发过程","permalink":"https://mrchen229.github.io/tags/Java%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/"},{"name":"常量与数据类型","slug":"常量与数据类型","permalink":"https://mrchen229.github.io/tags/%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]}