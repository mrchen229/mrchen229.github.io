{"meta":{"title":"pigDong","subtitle":"","description":"","author":"pigDong","url":"https://mrchen229.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-08-11T06:04:17.644Z","updated":"2020-08-11T06:04:17.644Z","comments":false,"path":"about/index.html","permalink":"https://mrchen229.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2020-08-12T05:59:27.754Z","updated":"2020-08-11T06:04:17.638Z","comments":false,"path":"/404.html","permalink":"https://mrchen229.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-12T05:58:42.160Z","updated":"2020-08-12T05:58:42.160Z","comments":false,"path":"categories/index.html","permalink":"https://mrchen229.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-11T06:04:17.651Z","updated":"2020-08-11T06:04:17.651Z","comments":false,"path":"repository/index.html","permalink":"https://mrchen229.github.io/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-08-11T06:04:17.645Z","updated":"2020-08-11T06:04:17.645Z","comments":false,"path":"books/index.html","permalink":"https://mrchen229.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-11T06:04:17.649Z","updated":"2020-08-11T06:04:17.649Z","comments":true,"path":"links/index.html","permalink":"https://mrchen229.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-12T05:59:15.606Z","updated":"2020-08-12T05:59:15.606Z","comments":false,"path":"tags/index.html","permalink":"https://mrchen229.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"后台前端_Vuetify_nginx反向代理_商品分类_cors跨域_品牌查询_axios_分页和过滤","slug":"leyou_后台前端_反向代理_商品分类_cors跨域_品牌查询_axios_分页和过滤/后台前端_Vuetify_nginx反向代理_商品分类_cors跨域_品牌查询_axios_分页和过滤","date":"2020-08-31T07:10:08.000Z","updated":"2020-08-31T07:10:37.899Z","comments":true,"path":"2020/08/31/leyou_后台前端_反向代理_商品分类_cors跨域_品牌查询_axios_分页和过滤/后台前端_Vuetify_nginx反向代理_商品分类_cors跨域_品牌查询_axios_分页和过滤/","link":"","permalink":"https://mrchen229.github.io/2020/08/31/leyou_%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF_Vuetify_nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB_cors%E8%B7%A8%E5%9F%9F_%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2_axios_%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/","excerpt":"","text":"知识点 后台前端的目录结构 Vuetify的项目页面布局 nginx反向代理解决端口问题 商品分类查询功能 JPA 通用Mapper cors解决跨域 品牌查询功能 异步查询axios 分页和过滤 1. 搭建后台管理前端1.1 导入已有资源后台项目相对复杂，使用资料中的code： 我们解压缩，放到工作目录中： 然后在Intellij idea中导入新的工程： 选中我们的工程： 1.2 安装依赖这里并没有node_modules文件夹，package.json中定义了所需的一切依赖： 我们只需要打开终端，进入项目目录，输入：npm install命令，即可安装这些依赖。 大概需要几分钟。 如果安装过程出现以下问题： 建议删除node_modules目录，重新安装。或者copy其他人的node_modules使用 1.3 运行 在package.json文件中有scripts启动脚本配置，可以输入命令：npm run dev或者npm start 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转： 1.4 目录结构 webpack：是一个现代 JavaScript 应用程序的**静态模块打包器(module bundler)**。并且提供了前端项目的热部署插件。 1.5 调用关系我们最主要理清index.html、main.js、App.vue之间的关系： 注意：若文件夹中仅有一个index.js，可以直接引入文件夹就成 理一下： index.html：html模板文件。定义了空的div，其id为app。 main.js：实例化vue对象，并且通过id选择器绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就拥有了vue的内容（包括组件、样式等），所以，main.js也是webpack打包的入口。 index.js：定义请求路径和组件的映射关系。相当于之前的&lt;vue-router&gt; App.vue中也没有内容，而是定义了vue-router的锚点：&lt;router-view&gt;,我们之前讲过，vue-router路由后的组件将会在锚点展示。 最终结论：一切路由后的内容都将通过App.vue在index.html中显示。 访问流程：用户在浏览器输入路径，例如：http://localhost:9001/#/item/brand –&gt; index.js(/item/brand路径对应pages/item/Brand.vue组件) –&gt; 该组件显示在App.vue的锚点位置 –&gt; main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中） 2. Vuetify框架2.1 为什么要学习UI框架Vue虽然会帮我们进行视图的渲染，但样式还是由我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 2.2 为什么是Vuetify有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 官网说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 2.3 用法基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 2.4 项目页面布局接下来我们一起看下页面布局。 Layout组件是我们的整个页面的布局组件： 一个典型的三块布局。包含左，上，中三部分： 里面使用了Vuetify中的2个组件和一个布局元素： v-navigation-drawer ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 v-toolbar ：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。 v-content：并不是一个组件，而是标记页面布局的元素。可以根据您指定的app组件的结构动态调整大小，使得您可以创建高度可定制的组件。 那么问题来了：v-content中的内容来自哪里？ Layout映射的路径是/ 除了Login以外的所有组件，都是定义在Layout的children属性，并且路径都是/的下面 因此当路由到子组件时，会在Layout中定义的锚点中显示。 并且Layout中的其它部分不会变化，这就实现了布局的共享。 3. 使用域名访问本地项目3.1 统一环境我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com，leyou.com 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 3.2 域名解析一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 12# My hosts127.0.0.1 localhost 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 3.3 解决域名解析问题我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，推荐一个快捷修改host的工具（《资料》）： 解压，运行exe文件，效果： 我们添加了两个映射关系（中间用空格隔开）： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ 通过域名访问： 原因：我们配置了项目访问的路径，虽然manage.leyou.com映射的ip也是127.0.0.1，但是webpack会验证host是否符合配置。 在webpack.dev.conf.js中取消host验证：disableHostCheck: true 重新执行npm run dev，刷新浏览器： OK！ 3.4 nginx解决端口问题​ 域名问题解决了，但是现在要访问后台页面，还得自己加上端口：http://manage.taotao.com:9001。 ​ 这就不够优雅了。希望的是直接域名访问：http://manage.taotao.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ ​ 这里就要用到反向代理工具：Nginx 3.4.1 什么是Nginx nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 3.4.2 nginx作为web服务器Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 3.4.3 nginx作为反向代理什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 3.4.4 安装和使用 安装 安装非常简单，把资料提供的nginx直接解压即可 在本地安装一台nginx： 解压后，目录结构： conf：配置目录 contrib：第三方依赖 html：默认的静态资源目录，类似于tomcat的webapps logs：日志目录 nginx.exe：启动程序。可双击运行，但不建议这么做。 反向代理配置 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 使用 nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程： 3.5 测试问题：nginx监控得到的地址并没有manage.leyou.com，这时候有其他属性有携带该信息，eg：original 启动nginx，然后用域名访问后台管理系统： 现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行**域名解析** 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 4. 实现商品分类查询实现时的问题？12345678910111213141516171819202122231. 位置categoryController: public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoriesByPid的返回值是什么意思 ResponseEntity.badRequest().build()这个类中有哪些方法能用，怎么用2. 位置leyou_item_service的启动类 @MapperScan(&quot;com.leyou.item.mapper&quot;)为什么注解扫描需要写com.leyou3. 位置leyou_item_service的Category pojo类（JPA） @Table(name=&quot;tb_category&quot;) public class Category &#123; @Id @GeneratedValue(strategy= GenerationType.IDENTITY) 这些注解的含义是什么，为何从未见过，需要怎么去学习4. 类似service中使用categoryMapper.select(record);这些方法应该什么时候使用（通用mapper），怎么用。5. 理清这里的zuul和nginx和微服务的关系，以及怎样进行配置（已解决）6. 网关中LeyouCorsConfiguration的有关corsFilter的写法（很明确了）7. pagehelper的pojo定义以及使用（https://mybatis.io/）8. nginx监控得到的地址并没有manage.leyou.com，这时候有其他属性有携带该信息，eg：original。（已解决） ​ 商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，我们需要依次去完成：商品分类、品牌、商品的开发。 4.1 导入数据首先导入资料提供的sql： 先看商品分类表： 123456789CREATE TABLE &#96;tb_category&#96; ( &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;类目id&#39;, &#96;name&#96; varchar(20) NOT NULL COMMENT &#39;类目名称&#39;, &#96;parent_id&#96; bigint(20) NOT NULL COMMENT &#39;父类目id,顶级类目填0&#39;, &#96;is_parent&#96; tinyint(1) NOT NULL COMMENT &#39;是否为父节点，0为否，1为是&#39;, &#96;sort&#96; int(4) NOT NULL COMMENT &#39;排序指数，越小越靠前&#39;, PRIMARY KEY (&#96;id&#96;), KEY &#96;key_parent_id&#96; (&#96;parent_id&#96;) USING BTREE) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1424 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&#39;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 4.2 实现在浏览器页面点击“分类管理”菜单： 根据这个路由路径到路由文件（src/route/index.js），也就是路由路径是地址上的路径，而路由文件是实际项目的文件位置，可以定位到分类管理页面： 由路由文件知，页面是src/pages/item/Category.vue 商品分类使用了树状结构，而这种结构的组件vuetify并没有为我们提供，这里自定义了一个树状组件。不要求实现或者查询组件的实现，只要求可以参照文档使用该组件即可： 4.2.1 url异步请求点击商品管理下的分类管理子菜单，在浏览器控制台可以看到： 页面中没有，只是发起了一条请求：http://api.leyou.com/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径：/item/category/list，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://api.leyou.com/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是http://api.leyou.com，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名。 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 4.2.2 实体类(item-interface)在leyou-item-interface中添加category实体类： 内容： 1234567891011@Table(name=&quot;tb_category&quot;)public class Category &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private Long parentId; private Boolean isParent; // 注意isParent生成的getter和setter方法需要手动加上Is private Integer sort; // getter和setter略&#125; 需要注意的是，这里要用到jpa的注解，因此我们在leyou-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 4.2.3 controller编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值，这里返回值是根据全局组件的Tree.vue中的mockDB中的treedata来得知的。 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get，插叙肯定是get请求 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; &quot;id&quot;: 74, &quot;name&quot;: &quot;手机&quot;, &quot;parentId&quot;: 0, &quot;isParent&quot;: true, &quot;sort&quot;: 2 &#125;, &#123; &quot;id&quot;: 75, &quot;name&quot;: &quot;家用电器&quot;, &quot;parentId&quot;: 0, &quot;isParent&quot;: true, &quot;sort&quot;: 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。也就是List&lt;Category&gt; 添加Controller： controller代码： 123456789101112131415161718192021222324252627@Controller@RequestMapping(&quot;category&quot;)public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据父id查询子节点 * @param pid * @return */ @GetMapping(&quot;list&quot;) public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoriesByPid(@RequestParam(&quot;pid&quot;) Long pid) &#123; if (pid == null || pid.longValue() &lt; 0) &#123; // 响应400，相当于ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); return ResponseEntity.badRequest().build(); &#125; List&lt;Category&gt; categories = this.categoryService.queryCategoriesByPid(pid); if (CollectionUtils.isEmpty(categories)) &#123; // 响应404 return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(categories); &#125;&#125; 4.2.4 service一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 1234567891011121314151617@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; /** * 根据parentId查询子类目 * @param pid * @return */ public List&lt;Category&gt; queryCategoriesByPid(Long pid) &#123; Category record = new Category(); record.setParentId(pid); return this.categoryMapper.select(record); &#125;&#125; 4.2.5 mapper我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 123456789@SpringBootApplication@EnableDiscoveryClient@MapperScan(&quot;com.leyou.item.mapper&quot;) // mapper接口的包扫描public class LeyouItemServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouItemServiceApplication.class, args); &#125;&#125; 4.2.6.启动并测试我们不经过网关，直接访问：http://localhost:8081/category/list 然后试试网关是否畅通：http://api.leyou.com/api/item/category/list 一切OK！ 然后刷新后台管理页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 这其实是浏览器的同源策略造成的跨域问题。 5. 跨域问题跨域：浏览器对于javascript的同源策略的限制 。 以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods http和https也属于跨域 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 5.1 跨域问题的原因跨域不一定都会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 5.2 解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 5.3 cors解决跨域5.3.1 什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 5.3.2 两种请求对应的响应头格式浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名） Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 有关cookie 有关cookie： 要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求, 例如请求方式为PUT。 预检请求 ​ 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 ​ 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 响应 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 5.3.3 实现虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在leyou-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class LeyouCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(&quot;http://manage.leyou.com&quot;); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(&quot;OPTIONS&quot;); config.addAllowedMethod(&quot;HEAD&quot;); config.addAllowedMethod(&quot;GET&quot;); config.addAllowedMethod(&quot;PUT&quot;); config.addAllowedMethod(&quot;POST&quot;); config.addAllowedMethod(&quot;DELETE&quot;); config.addAllowedMethod(&quot;PATCH&quot;); // 4）允许的头信息 config.addAllowedHeader(&quot;*&quot;); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(&quot;/**&quot;, config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 重启测试，访问正常： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 6. 品牌的查询需要注意的是，页面中的排序和分页操作是前端ui通过watch pagination调用相应的函数来自动更新的，我们本身并没有对其进行处理。 搜索也是前端ui通过watch seach来调用函数完成，我们本身在后端并没有进行处理。 商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 点击“品牌管理”菜单： 路由路径：/item/brand 根据路由文件知，对应的页面是：src/pages/item/Brand.vue 页面会发送如下请求： 6.1 后台提供查询接口前台页面已经准备好，接下来就是后台提供数据接口了。 6.1.1 数据库表1234567CREATE TABLE &#96;tb_brand&#96; ( &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;品牌id&#39;, &#96;name&#96; varchar(50) NOT NULL COMMENT &#39;品牌名称&#39;, &#96;image&#96; varchar(200) DEFAULT &#39;&#39; COMMENT &#39;品牌图片地址&#39;, &#96;letter&#96; char(1) DEFAULT &#39;&#39; COMMENT &#39;品牌的首字母&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;325400 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;品牌表，一个品牌下有多个商品（spu），一对多关系&#39;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 123456CREATE TABLE &#96;tb_category_brand&#96; ( &#96;category_id&#96; bigint(20) NOT NULL COMMENT &#39;商品类目id&#39;, &#96;brand_id&#96; bigint(20) NOT NULL COMMENT &#39;品牌id&#39;, PRIMARY KEY (&#96;category_id&#96;,&#96;brand_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品分类和品牌的中间表，两者是多对多关系&#39;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 6.1.2 实体类 12345678910@Table(name = &quot;tb_brand&quot;)public class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; 6.1.3 mapper 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; 6.1.4 controller编写controller先思考四个问题，参照前端页面的控制台 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，查询源文件发现在$http.get中的params中传入了5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据，这里查询源文件发现在$http.get中的resp.data中用到了items和total，items的使用中又用到了id name image letter total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Integer totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; public Long getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Long totalPage) &#123; this.totalPage = totalPage; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到leyou-common中，提高复用性： 不要忘记在leyou-item-service工程的pom.xml中引入leyou-common的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 接下来，我们编写Controller 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(&quot;brand&quot;)public class BrandController &#123; @Autowired private BrandService brandService; /** * 根据查询条件分页并排序查询品牌信息 * @param key * @param page * @param rows * @param sortBy * @param desc * @return */ @GetMapping(&quot;page&quot;) public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandsByPage( @RequestParam(value = &quot;key&quot;, required = false)String key, @RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;)Integer page, @RequestParam(value = &quot;rows&quot;, defaultValue = &quot;5&quot;)Integer rows, @RequestParam(value = &quot;sortBy&quot;, required = false)String sortBy, @RequestParam(value = &quot;desc&quot;, required = false)Boolean desc )&#123; PageResult&lt;Brand&gt; result = this.brandService.queryBrandsByPage(key, page, rows, sortBy, desc); if (CollectionUtils.isEmpty(result.getItems()))&#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(result); &#125;&#125; 6.1.5 Service123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class BrandService &#123; @Autowired private BrandMapper brandMapper; /** * 根据查询条件分页并排序查询品牌信息 * * @param key * @param page * @param rows * @param sortBy * @param desc * @return */ public PageResult&lt;Brand&gt; queryBrandsByPage(String key, Integer page, Integer rows, String sortBy, Boolean desc) &#123; // 初始化example对象 Example example = new Example(Brand.class); Example.Criteria criteria = example.createCriteria(); // 根据name模糊查询，或者根据首字母查询 if (StringUtils.isNotBlank(key)) &#123; criteria.andLike(&quot;name&quot;, &quot;%&quot; + key + &quot;%&quot;).orEqualTo(&quot;letter&quot;, key); &#125; // 添加分页条件 PageHelper.startPage(page, rows); // 添加排序条件 if (StringUtils.isNotBlank(sortBy)) &#123; example.setOrderByClause(sortBy + &quot; &quot; + (desc ? &quot;desc&quot; : &quot;asc&quot;)); &#125; List&lt;Brand&gt; brands = this.brandMapper.selectByExample(example); // 包装成pageInfo PageInfo&lt;Brand&gt; pageInfo = new PageInfo&lt;&gt;(brands); // 包装成分页结果集返回 return new PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo.getList()); &#125;&#125; 6.1.6 测试通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染 6.2 异步查询工具axios​ 异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 6.2.1 axios入门（Get与POST）Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get(&quot;/item/category/list?pid=0&quot;) // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get(&quot;/item/category/list&quot;, &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post(&quot;/user&quot;,&#123; name:&quot;Jack&quot;, age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 6.2.2 axios的全局配置而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;import config from &#x27;./config&#x27;// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http 。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 6.2.3 项目中使用在组件Brand.vue的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： resp到底都有那些数据，查看控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 6.3 完成分页和过滤6.3.1 分页点击分页，会发起请求，通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，在回调函数中进行数据的查询！ 具体实现： 成功实现分页功能： 6.3.2 过滤过滤字段对应的是search属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 7. 总结123456789101.通过域名访问页面(nginx) hosts: 解析域名--&gt; ip switchHost工具修改 nginx: web和反向代理服务器 Web服务器 web应用服务器 nginx+tomcat 请求分发，反向代理，负载均衡 start nginx nginx -s reload/stop nginx.conf server&#123; server_name; proxy_pass; &#125; 12. 分类查询 12345678910113. 跨域 跨域场景： 协议不同 域名不同 端口不同 二级域名不同 跨域前提: ajax请求才会出现跨域 解决方案: jsonp nginx cors:无需处理请求，只需要处理响应即可，请求是浏览器自动携带的。 Access-Control-Allow-Origin: http://manage.leyou.com Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header 实现： springMVC提供了CorsFilter 12345674. 品牌查询 service // 添加查询条件key // 添加分页 // 添加排序 // 分页结果集 // 封装成自己的分页结果集","categories":[{"name":"乐优商城","slug":"乐优商城","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"},{"name":"后台前端_Vuetify_nginx反向代理_商品分类(JPA_通用Mapper)_cors跨域_品牌查询(axios_分页和过滤)","slug":"乐优商城/后台前端-Vuetify-nginx反向代理-商品分类-JPA-通用Mapper-cors跨域-品牌查询-axios-分页和过滤","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF-Vuetify-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB-JPA-%E9%80%9A%E7%94%A8Mapper-cors%E8%B7%A8%E5%9F%9F-%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2-axios-%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/"}],"tags":[{"name":"Vuetify","slug":"Vuetify","permalink":"https://mrchen229.github.io/tags/Vuetify/"},{"name":"nginx反向代理解决端口问题","slug":"nginx反向代理解决端口问题","permalink":"https://mrchen229.github.io/tags/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/"},{"name":"cors解决跨域","slug":"cors解决跨域","permalink":"https://mrchen229.github.io/tags/cors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"},{"name":"异步查询axios","slug":"异步查询axios","permalink":"https://mrchen229.github.io/tags/%E5%BC%82%E6%AD%A5%E6%9F%A5%E8%AF%A2axios/"},{"name":"分页和过滤","slug":"分页和过滤","permalink":"https://mrchen229.github.io/tags/%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/"}]},{"title":"Vue_router_webpack_cli","slug":"leyou_Vue_router_webpack_cli/Vue_router_webpack_cli","date":"2020-08-30T07:44:07.000Z","updated":"2020-08-31T08:43:16.492Z","comments":true,"path":"2020/08/30/leyou_Vue_router_webpack_cli/Vue_router_webpack_cli/","link":"","permalink":"https://mrchen229.github.io/2020/08/30/leyou_Vue_router_webpack_cli/Vue_router_webpack_cli/","excerpt":"","text":"知识点 Vue实例的常见属性 Vue生命周期的钩子函数 vue常见指令 插值表达式 v-model双向绑定 v-on绑定事件 v-for v-if和v-show v-bind绑定html属性 computed watch Vue全局组件与局部注册 父子组件间的通信 vue-router使用 webpack使用 使用vue-cli搭建项目 vue总结 html模板 插值表达式：声明式渲染 123&#123;&#123;js表达式、数据模型&#125;&#125;：单向，js表达式必须有返回值，会出现插值闪烁 v-text：把所有的内容当做文本渲染，通常使用该方式 v-html：解析js html css。有安全隐患 双向渲染：双向绑定 1v-model&#x3D;&quot;数据模型&quot;: 在表单元素中使用，才有意义。 事件： 123456789v-on:事件名： 简写@ eg.v-on:click&#x3D;&quot;js表达式或者函数名&quot; @click: 点击事件 @contextMenu： 右键点击事件 事件修饰符: .prevent:禁用默认事件 @keyup: 键盘事件 .enter(13):回车键盘事件 13或者enter键：回车事件@keyup.13 组合事件 钩子函数：初始化（new Vue()） 模板加载 视图渲染 更新 销毁 。 1created：加载数据模型 v-for: 遍历集合或者对象 123数组：v-for&#x3D;&quot;(item,index) in items&quot;对象：v-for&#x3D;&quot;(val, key, index) in user&quot; :key: 提高渲染速度 v-if: 判断 1234v-if&#x3D;&quot;布尔表达式&quot;： true为渲染，false为不渲染v-show&#x3D;&quot;布尔表达式&quot;： 总是渲染，false时为display:nonev-else-if&#x3D;&quot;布尔表达式&quot;v-else: 一定要跟在if后 v-bind:绑定属性（class、style、自定义的属性），简写（:） 1:class&#x3D;&quot;active:布尔表达式&quot; vue实例js 123456789101112131415161718192021222324el: &quot;#app&quot; // vue实例的作用范围,选择器对应html模板data: &#123;数据模型&#125;methods: &#123;定义方法&#125;computed: 定义计算属性，计算本质就是方法，但方法必须有返回值，计算属性可以像数据模型一样使用。如果计算属性的依赖项没有改变，直接从缓存中命中watch: 监听，方法名是要监听的数据模型名称 message(newVal, oldVal)&#123;&#125;钩子函数：created()&#123;加载数据&#125;，在对象初始化之后执行，通常在created中初始化数据components: 局部子组件 全局组件：Vue.componet(&quot;组件名&quot;,&#123; template: &quot;html模板&quot;, data()&#123; return &#123; 数据模型 &#125; &#125; methods,watch &#125;) 局部组件：const 组件对象名 = &#123;同上&#125; 组件的通信： 1.父向子通信: a.父自定义属性，属性名随便写，属性值是要传递的数据模型 b.子通过props接收，参数名是自定义属性的属性名[&quot;属性名&quot;] or &#123;属性名:&#123;type default required&#125;&#125; 2.子向父通信: a.父自定义事件，时间名随便写，属性值是要传递的方法 b.定义事件调用子自己的方法，子的方法中通过this.$emit(&quot;自定义事件名&quot;) 路由: vue-router npm install vue-router –save 1234567891011121314路由: vue-router npm install vue-router --save 引入vue-router组件 实例化vue-router: const router &#x3D; new VueRouter(&#123; routes:[ &#123; path: 路由路径，要以&#x2F;开头 component: l路由组件 &#125;, &#123;&#125; ] &#125;) 引入到vue实例中: 通过router &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;&lt;&#x2F;router-link&gt; &lt;router-view &#x2F;&gt; :锚点 0.前言已经对后端的技术栈有了初步的了解、并且已经搭建了整个后端微服务的平台。 接下来就是功能开发。要了解一下前端的一些技术，完成前端页面搭建。 先聊一下前端开发模式的发展。 静态页面 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容即可。 异步刷新，操作DOM 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言. 随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如Jquery就是典型代表。 MVVM，关注模型和视图 2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。 2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。 基于事件循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台代码，前后台统一编程语言 node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。 2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。 随后，在node的基础上，涌现出了一大批的前端框架： MVVM模式 M：即Model，模型，包括数据和一些基本操作 V：即View，视图，页面渲染结果 VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作（document.getElementById()，$(“#da”).）Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 1. 认识VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 ​ 前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs 2. Node和NPM​ NPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJsw都有。方便起见，先安装node及NPM工具。 2.1 下载Node.js下载地址：https://nodejs.org/en/ 推荐下载LTS版本。 完成以后，在控制台输入： 1node -v 可以看到版本信息。 2.2 NPMNode自带NPM，在控制台输入 1npm -v 可以查看npm的版本。 ​ npm默认的仓库地址是在国外网站，速度较慢，建议设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm ​ 首先安装nrm，这里-g代表全局安装。可能需要一点儿时间 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库： 通过nrm use taobao来指定要使用的镜像源： 然后通过nrm test npm 来测试速度： 注意： 使用cnpm命令，使用发现cnpm有时会有bug，不推荐。 安装完成请需要重启电脑！ 3. 快速入门3.1 创建工程创建一个新的空工程： 然后新建一个module： 选中static web，静态web项目： 位置信息： 3.2 安装vue3.2.1 下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件。 3.2.2 使用CDN或者也可以直接使用公共的CDN服务： 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 或者： 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 3.2.3 推荐npm安装在idea的左下角，有个Terminal按钮，点击打开控制台： 进入hello-vue目录，先输入：npm init -y 进行初始化 安装Vue，输入命令：npm install vue --save 然后就会在hello-vue目录发现一个node_modules目录，并且在下面有一个vue目录。 node_modules是通过npm安装的所有模块的默认位置。 3.3 vue示例3.3.1 HTML模板 在hello-vue目录新建一个HTML 在hello.html中，我们编写一段简单的代码： h2中要输出一句话：xx 非常帅。前面的xx是要渲染的数据。 3.3.2 vue声明式渲染然后我们通过Vue进行渲染： 12345678910111213141516&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;，非常帅！！！&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;node_modules/vue/dist/vue.js&quot; &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el:&quot;#app&quot;, // el即element，里面是选择器，该vue实例要渲染的页面元素 data:&#123; // 渲染页面需要的数据 name: &quot;峰哥&quot; &#125; &#125;);&lt;/script&gt; 首先通过 new Vue()来创建Vue实例 然后构造函数接收一个对象，对象中有一些属性： el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 name：这里我们指定了一个name属性 页面中的h2元素中，我们通过**的方式，来渲染刚刚定义的name属性** ​ 注意：&#123;&#123;&#125;&#125;`中写js表达式。 打开页面查看效果： 更神奇的在于，修改name属性时，页面会跟着变化： ### 3.3.3 双向绑定 对刚才的案例进行简单修改： 1234567891011121314151617181920&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125;，非常帅！！！有&#123;&#123;num&#125;&#125;位女神为他着迷。 &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;node_modules/vue/dist/vue.js&quot; &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el: &quot;#app&quot;, // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: &quot;峰哥&quot;, num: 5 &#125; &#125;);&lt;/script&gt; - 在data添加了新的属性：`num` - 在页面中有一个`input`元素，**通过`v-model`与`num`进行绑定**。 - 同时通过`&#123;&#123;num&#125;&#125;在页面输出 效果： 可以观察到，输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。 input与num绑定，input的value值变化，影响到了data中的num值 页面&#123;&#123;num&#125;&#125;与数据num绑定，因此num值变化，引起了页面效果变化。 没有任何dom操作，这就是双向绑定的魅力。 3.3.4 事件处理我们在页面添加一个按钮：v-on:事件名=js表达式 1&lt;button v-on:click=&quot;num++&quot;&gt;点我&lt;/button&gt; 这里用v-on指令绑定点击事件，而不是普通的onclick，然后直接操作num 普通click是无法直接操作num的。 效果： 4. Vue实例4.1 new Vue: 创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; // 选项&#125;) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 接下来一 一介绍。 4.2 el: 模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： 123&lt;div id=&quot;app&quot;&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div 123var vm = new Vue(&#123; el:&quot;#app&quot;&#125;) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 4.3 data: 数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： 123&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;&lt;/div&gt; js: 123456var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; name:&quot;刘德华&quot; &#125;&#125;) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 4.4 methods: 方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue实例的作用范围内使用。方法也可以用箭头函数的写法。 html: 1234&lt;div id=&quot;app&quot;&gt; &#123;&#123;num&#125;&#125; &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;&lt;/div&gt; js: 123456789101112var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; num: 0 &#125;, methods:&#123; add:function()&#123; // this代表的当前vue实例 this.num++; &#125; &#125;&#125;) 4.5 生命周期钩子4.5.1 生命周期​ 每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 4.5.2 钩子函数 beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化时调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 created：在创建实例之后进行调用，**多用于初始化数据 **。 beforeMount：页面加载完成，没有渲染。如：此时页面还是 mounted：我们可以将他理解为原生js中的window.onload=function({.,.}),或许大家也在用jquery，所以也可以理解为jquery中的$(document).ready(function(){….})，他的功能就是：在dom文档渲染完毕之后将要执行的函数，该函数在Vue1.0版本中名字为compiled。 此时页面中的已被渲染成峰哥，即取得数据。 beforeUpdate：组件更新之前。 updated：组件更新之后。 beforeDestroy：该函数将在销毁实例前进行调用 。 destroyed：改函数将在销毁实例时进行调用。 例如：created代表在vue实例创建后； 我们可以在Vue中定义一个created函数，代表这个时期的钩子函数： 12345678910111213141516// 创建vue实例var app = new Vue(&#123; el: &quot;#app&quot;, // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: &quot;峰哥&quot;, num: 5 &#125;, methods: &#123; add: function()&#123; this.num--; &#125; &#125;, created: function () &#123; this.num = 100; &#125;&#125;); 结果： 4.5.3 this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this 123456methods: &#123; add: function()&#123; this.num--; console.log(this); &#125;&#125;, 控制台的输出： 5. 指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。 ​ 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 5.1 插值表达式5.1.1 {{}}花括号 格式： 1&#123;&#123;表达式&#125;&#125; 说明： - 该表达式支持JS语法，**可以调用js内置函数（必须有返回值）**,注意函数是写成调用的形式 - 表达式**必须有返回结果**。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1; - 可以**直接获取Vue实例中定义的数据或函数** 示例： HTML： 1&lt;div id=&quot;app&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; JS: 123456var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; name:&quot;Jack&quot; &#125;&#125;) ### 5.1.2 插值闪烁 使用{{}}方式在网速较慢时会出现问题。**在数据未加载完成时，页面会显示出原始的{{}}**，加载完毕后才显示正确数据，我们称为**插值闪烁**。 我们将网速调慢一些，然后试试看刚才的案例： 刷新页面： ### 5.1.3 v-text和v-html替代{{}}使用v-text和v-html指令来替代{{}} 说明： v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出，这种更常用 v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染 示例： HTML: 1234&lt;div id=&quot;app&quot;&gt; v-text:&lt;span v-text=&quot;hello&quot;&gt;&lt;/span&gt; &lt;br/&gt; v-html:&lt;span v-html=&quot;hello&quot;&gt;&lt;/span&gt;&lt;/div&gt; JS: 123456var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; hello: &quot;&lt;h1&gt;大家好，我是峰哥&lt;/h1&gt;&quot; &#125;&#125;) 效果： 并且不会出现插值闪烁，当没有数据时，会显示空白。 5.2 v-model双向绑定​ 刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 基本上除了最后一项，其它都是表单的输入项。 举例： html： 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;language&quot; value=&quot;Java&quot; /&gt;Java&lt;br/&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;language&quot; value=&quot;PHP&quot; /&gt;PHP&lt;br/&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;language&quot; value=&quot;Swift&quot; /&gt;Swift&lt;br/&gt; &lt;h1&gt; 你选择了：&#123;&#123;language.join(&#x27;,&#x27;)&#125; &#125; &lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; language: [] &#125; &#125;)&lt;/script&gt; 多个CheckBox对应一个model时，model的类型是一个数组，单个checkbox值默认是boolean类型 radio对应的值是input的value值 input 和textarea 默认对应的model是字符串 select单选对应字符串，多选对应也是数组 效果： 5.3 v-on绑定事件(@)5.3.1 基本用法v-on指令用于给页面元素绑定事件。 语法： 12v-on:事件名&#x3D;&quot;js片段或函数名&quot;事件名多为click keyup等 示例： 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click=&quot;num++&quot;&gt;增加一个&lt;/button&gt;&lt;br/&gt; &lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt; &lt;button v-on:click=&quot;decrement&quot;&gt;减少一个&lt;/button&gt;&lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125; &#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; num:100 &#125;, methods:&#123; decrement()&#123; this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果： 另外，事件绑定可以简写，例如v-on:click=&#39;add&#39;可以简写为@click=&#39;add&#39; 5.3.2 事件修饰符.stop .prevent .capture在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡到父元素 .prevent：阻止默认事件发生 .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once：只执行一次 阻止默认事件 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;!--右击事件，并阻止默认事件发生--&gt; &lt;button v-on:contextmenu.prevent=&quot;num++&quot;&gt;增加一个&lt;/button&gt; &lt;br/&gt; &lt;!--右击事件，不阻止默认事件发生--&gt; &lt;button v-on:contextmenu=&quot;decrement($event)&quot;&gt;减少一个&lt;/button&gt; &lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125; &#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; num: 100 &#125;, methods: &#123; decrement(ev) &#123; // ev.preventDefault(); this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果：（右键“增加一个”，不会触发默认的浏览器右击事件；右键“减少一个”，会触发默认的浏览器右击事件） 5.3.3 按键修饰符keyup.在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 5.3.4 组合按钮可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; 5.4 v-for遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 5.4.1 遍历数组 语法： 1v-for&#x3D;&quot;item in items&quot; items：要遍历的数组，需要在vue的data中定义好。 item：迭代得到的数组元素的别名 示例：注意这里是在li上操作。 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot;&gt; &#123;&#123;user.name&#125; &#125; - &#123;&#123;user.gender&#125; &#125; - &#123;&#123;user.age&#125; &#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; users:[ &#123;name:&#x27;柳岩&#x27;, gender:&#x27;女&#x27;, age: 21&#125;, &#123;name:&#x27;峰哥&#x27;, gender:&#x27;男&#x27;, age: 18&#125;, &#123;name:&#x27;范冰冰&#x27;, gender:&#x27;女&#x27;, age: 24&#125;, &#123;name:&#x27;刘亦菲&#x27;, gender:&#x27;女&#x27;, age: 18&#125;, &#123;name:&#x27;古力娜扎&#x27;, gender:&#x27;女&#x27;, age: 25&#125; ] &#125;, &#125;)&lt;/script&gt; 效果： 5.4.2 数组角标index在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数： 语法 1v-for&#x3D;&quot;(item,index) in items&quot; items：要迭代的数组 item：迭代得到的数组元素别名 index：迭代到的当前元素索引，从0开始。 示例 12345&lt;ul&gt; &lt;li v-for=&quot;(user, index) in users&quot;&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 5.4.3 遍历对象v-for除了可以迭代数组，也可以迭代对象。语法基本类似 语法： 123v-for=&quot;value in object&quot;v-for=&quot;(value,key) in object&quot;v-for=&quot;(value,key,index) in object&quot; 1个参数时，得到的是对象的属性 2个参数时，第一个是属性，第二个是键 3个参数时，第三个是索引，从0开始 示例： 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key, index) in user&quot;&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; user:&#123;name:&#x27;峰哥&#x27;, gender:&#x27;男&#x27;, age: 18&#125; &#125; &#125;)&lt;/script&gt; 效果： 5.4.4 key​ 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这个功能可以有效的提高渲染的效率。 ​ 但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 示例： 123&lt;ul&gt; &lt;li v-for=&quot;(item,index) in items&quot; :key=index&gt;&lt;/li&gt;&lt;/ul&gt; 这里使用了一个特殊语法：:key=&quot;&quot; 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性 这里我们绑定的key是数组的索引，应该是唯一的 5.5 v-if和v-show5.5.1 基本使用v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 语法： 1v-if&#x3D;&quot;布尔表达式&quot; 示例： 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt;点我呀&lt;/button&gt; &lt;br&gt; &lt;h1 v-if=&quot;show&quot;&gt; 看到我啦？！ &lt;/h1&gt; &lt;h1 v-show=&quot;show&quot;&gt; 看到我啦？！show &lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 效果： 5.5.2 与v-for结合当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 修改v-for中的案例，添加v-if： 12345&lt;ul&gt; &lt;li v-for=&quot;(user, index) in users&quot; v-if=&quot;user.gender `==` &#x27;女&#x27;&quot;&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 只显示女性用户信息 5.5.3 v-else与v-else-if你可以使用 v-else 指令来表示 v-if 的“else 块”： 12345678&lt;div id=&quot;app&quot;&gt; &lt;h1 v-if=&quot;Math.random() &gt; 0.5&quot;&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;random=Math.random()&quot;&gt;点我呀&lt;/button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;/span&gt; &lt;h1 v-if=&quot;random &gt;= 0.75&quot;&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else-if=&quot;random &gt; 0.5&quot;&gt; 看到我啦？！if 0.5 &lt;/h1&gt; &lt;h1 v-else-if=&quot;random &gt; 0.25&quot;&gt; 看到我啦？！if 0.25 &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; random: 1 &#125; &#125;)&lt;/script&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 演示： 5.5.4 v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 示例： 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt;点击切换&lt;/button&gt;&lt;br/&gt; &lt;h1 v-if=&quot;show&quot;&gt; 你好 &lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码：这里的v-show是已经渲染，只是设置成display:none，而v-if是为true时才进行渲染，v-if更常用 5.6 v-bind绑定html属性(:)html属性不能使用双大括号形式绑定，只能使用v-bind指令。 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;!--可以是数据模型，可以是具有返回值的js代码块或者函数--&gt; &lt;div v-bind:title=&quot;title&quot; style=&quot;border: 1px solid red; width: 50px; height: 50px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; title: &quot;title&quot;, &#125; &#125;)&lt;/script&gt; 效果： 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。 表达式结果的类型除了字符串之外，还可以是对象或数组。 5.6.1 绑定class样式数组语法 数组语法 我们可以借助于v-bind指令来实现： HTML： 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;activeClass&quot;&gt;&lt;/div&gt; &lt;div v-bind:class=&quot;errorClass&quot;&gt;&lt;/div&gt; &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; activeClass: &#x27;active&#x27;, errorClass: [&#x27;text-danger&#x27;, &#x27;text-error&#x27;] &#125; &#125;)&lt;/script&gt; 渲染后的效果：（具有active和hasError的样式） 对象语法 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 上面的语法表示 —-特别注意： ​ active这个 class 存在与否将取决于数据属性 isActive 的 truthiness（所有的值都是真实的，除了false,0,“”,null,undefined和NaN）。其他class也是如此。根据true或false来决定该class是否存在，style同样也是如此。 ​ 但是这里的true或false是取决于数据属性 的 truthiness。动态的class会追加到静态的class中。 ​ 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。如下模板: 123&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt; 和如下 data： 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 1&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; ​ active样式和text-danger样式的存在与否，取决于isActive和hasError的值。本例中isActive为true，hasError为false，所以active样式存在，text-danger不存在。 通常情况下，绑定的数据对象不必内联定义在模板里： 1&lt;div class=&quot;static&quot; v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; 数据： 123456data: &#123; classObject: &#123; active: true, &#x27;text-danger&#x27;: false &#125;&#125; 效果和之前一样： 1&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; 5.6.2 绑定style样式数组语法 数组语法 数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 数据： 1234data: &#123; baseStyles: &#123;&#x27;background-color&#x27;: &#x27;red&#x27;&#125;, overridingStyles: &#123;border: &#x27;1px solid black&#x27;&#125;&#125; 渲染后的结果： 1&lt;div style=&quot;background-color: red; border: 1px solid black;&quot;&gt;&lt;/div&gt; 对象语法 对象语法 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; 数据： 1234data: &#123; activeColor: &#x27;red&#x27;, fontSize: 30&#125; 效果： 1&lt;div style=&quot;color: red; font-size: 30px;&quot;&gt;&lt;/div&gt; 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: &#x27;red&#x27;, fontSize: &#x27;13px&#x27; &#125;&#125; 效果同上。 5.6.3 简写成:v-bind:class可以简写为:class 5.7 computed计算属性​ 在插值表达式中使用js表达式是非常方便的，而且也经常被用到。 但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值： 123data:&#123; birthday:1529032123201 // 毫秒值&#125; 我们在页面渲染，希望得到yyyy-MM-dd的样式： 1234&lt;h1&gt;您的生日是：&#123;&#123; new Date(birthday).getFullYear() + &#x27;-&#x27;+ new Date(birthday).getMonth()+ &#x27;-&#x27; + new Date(birthday).getDay() &#125;&#125;&lt;/h1&gt; 虽然能得到结果，但是非常麻烦。 Vue中提供了计算属性，来替代复杂的表达式： 123456789101112var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; birthday:1429032123201 // 毫秒值 &#125;, computed:&#123; birth()&#123;// 计算属性本质是一个方法，但是必须返回结果 const d = new Date(this.birthday); return d.getFullYear() + &quot;-&quot; + d.getMonth() + &quot;-&quot; + d.getDay(); &#125; &#125;&#125;) 计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。 页面使用： 123&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;您的生日是：&#123;&#123;birth&#125;&#125; &lt;/h1&gt;&lt;/div&gt; 效果： ​ 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要birthday还没有发生改变，多次访问 birthday 计算属性会立即返回之前的计算结果，而不必再次执行函数。 5.8 watch监控watch可以让我们监控一个值的变化。从而做出相应的反应。 示例： 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&quot;&quot; &#125;, watch:&#123; message(newVal, oldVal)&#123; console.log(newVal, oldVal); &#125; &#125; &#125;)&lt;/script&gt; 效果： 6. 组件化​ 在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 ​ 但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。 6.1 全局组件Vue.component我们通过Vue的component方法来定义一个全局组件，此外template中只能有一个根标签。 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 定义全局组件，两个参数：1，组件名称。2，组件参数 Vue.component(&quot;counter&quot;,&#123; template:&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;&#x27;, data()&#123; return &#123; count:0 &#125; &#125; &#125;) var app = new Vue(&#123; el:&quot;#app&quot; &#125;)&lt;/script&gt; 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data必须是一个函数，不再是一个对象。 这里的父子的意思是vue示例是div上的组件，而&lt;counter&gt;是div中的，因此是其子组件 效果： 6.2 组件的复用定义好的组件，可以任意复用多次： 123456&lt;div id=&quot;app&quot;&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 效果： 你会发现每个组件互不干扰，都有自己的count值。怎么实现的？ 组件的data属性必须是函数 组件的data属性必须是函数！ 当我们定义这个 &lt;counter&gt; 组件时，它的data 并不是像这样直接提供一个对象： 1234data: &#123; count: 0&#125; ​ 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！ 6.3 局部组件(注册),components一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，我们会采用局部注册。 ​ 我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致： ​ 注意这里的定义不同，这里需要定义好对象之后再到vue中去使用，最后在页面中使用； ​ 而全局组件只需要定义再去页面使用就可以了。 12345678const counter = &#123; template:&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;&#x27;, data()&#123; return &#123; count:0 &#125; &#125;&#125;; 然后在Vue中使用它： 123456var app = new Vue(&#123; el:&quot;#app&quot;, components:&#123; counter:counter // 将定义的对象注册为组件，使用时就是&lt;counter&gt;&lt;/counter&gt; &#125;&#125;) components就是当前vue对象子组件集合。 其key就是子组件名称 其值就是组件对象的属性 效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用 6.4 组件通信通常一个单页应用会以一棵嵌套的组件树的形式来组织： 页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 左侧内容区又分为上下两个组件 右侧边栏中又包含了3个子组件 各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 6.4.1 props（父向子传递） 注意点：传递的是属性，所以需要v-bind 两种写法[] {} 父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据）,注意这里是标签内的属性 子组件通过props接收父组件属性，通过自定义属性的属性名 父组件使用子组件，并自定义了title属性：(全局示例) 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;打个招呼：&lt;/h1&gt; &lt;!--使用子组件，同时传递title属性--&gt; &lt;introduce title=&quot;大家好，我是锋哥&quot;/&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;introduce&quot;,&#123; // 直接使用props接收到的属性来渲染页面 template:&#x27;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&#x27;, props:[&#x27;title&#x27;] // 通过props来接收一个父组件传递的属性，多个时[&#x27;title1&#x27;,&#x27;title2&#x27;],其中title1,title2是自定义属性，这里给的初始值就是大家好，我是锋哥。也可以在new Vue的#app中添加数据模型来给定初始值。 &#125;) var app = new Vue(&#123; el:&quot;#app&quot; &#125;)&lt;/script&gt; 效果： 6.4.2 props验证我们定义一个子组件，并接受复杂数据：（局部示例） 1234567891011121314const myList = &#123; template: &#x27;\\ &lt;ul&gt;\\ &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.id&#125;&#125; : &#123;&#123;item.name&#125;&#125;&lt;/li&gt;\\ &lt;/ul&gt;\\ &#x27;, props: &#123; items: &#123; type: Array, default: [], required: true &#125; &#125;&#125;; 这个子组件可以对 items 进行迭代，并输出到页面。 props：定义需要从父组件中接收的属性，注意这里传递的是属性。 items：是要接收的属性名称 type：限定父组件传递来的必须是数组 default：默认值 required：是否必须 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 我们在父组件中使用它，:items是v-bind的简写： 12345&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;传智播客已开设如下课程：&lt;/h2&gt; &lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt; &lt;my-list :items=&quot;lessons&quot;/&gt;&lt;/div&gt; 12345678910111213var app = new Vue(&#123; el:&quot;#app&quot;, components:&#123; myList // 当key和value一样时，可以只写一个 &#125;, data:&#123; lessons:[ &#123;id:1, name: &#x27;java&#x27;&#125;, &#123;id:2, name: &#x27;php&#x27;&#125;, &#123;id:3, name: &#x27;ios&#x27;&#125;, ] &#125;&#125;) 效果： type类型，可以有： 6.4.3 动态静态传递给 prop 传入一个静态的值： 1&lt;introduce title=&quot;大家好，我是锋哥&quot;/&gt; 给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值） 1&lt;introduce :title=&quot;title&quot;/&gt; 静态传递时，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 props。 123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt; 6.4.4 $emit() 子向父的通信来看这样的一个案例： 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;!--使用子组件的时候，传递num到子组件中--&gt; &lt;counter :num=&quot;num&quot;&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;counter&quot;, &#123;// 子组件，定义了两个按钮，点击数字num会加或减 template:&#x27;\\ &lt;div&gt;\\ &lt;button @click=&quot;num++&quot;&gt;加&lt;/button&gt; \\ &lt;button @click=&quot;num--&quot;&gt;减&lt;/button&gt; \\ &lt;/div&gt;&#x27;, props:[&#x27;num&#x27;]// count是从父组件获取的。 &#125;) var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; num:0 &#125; &#125;)&lt;/script&gt; 子组件接收父组件的num属性 子组件定义点击按钮，点击后对num进行加或减操作 我们尝试运行，好像没问题，点击按钮试试： 子组件接收到父组件属性后，默认是不允许修改的。怎么办？ 既然只有父组件能修改，那么加和减的操作一定是放在父组件： 1234567891011121314var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125;&#125;) 但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？ v-on将父组件函数绑定到子组件我们可以通过v-on指令将父组件的函数绑定到子组件上,这时候只有绑定操作，后面才到template中定义button来使用： 1234&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;counter :count=&quot;num&quot; @inc=&quot;increment&quot; @dec=&quot;decrement&quot;&gt;&lt;/counter&gt;&lt;/div&gt; 子组件定义函数调用父的实现在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数： 12345678910111213141516Vue.component(&quot;counter&quot;, &#123; template:&#x27;\\ &lt;div&gt;\\ &lt;button @click=&quot;plus&quot;&gt;加&lt;/button&gt; \\ &lt;button @click=&quot;reduce&quot;&gt;减&lt;/button&gt; \\ &lt;/div&gt;&#x27;, props:[&#x27;count&#x27;], methods:&#123; plus()&#123; this.$emit(&quot;inc&quot;); &#125;, reduce()&#123; this.$emit(&quot;dec&quot;); &#125;· &#125;&#125;) vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数 效果： 7. 路由vue-router7.1 场景模拟实现这样一个功能： ​ 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换。 7.1.1 编写父组件为了让接下来的功能比较清晰，先新建一个文件夹：src ​ 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el:&quot;#app&quot; &#125;)&lt;/script&gt; 样式： 7.1.2 编写登录及注册组件接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放入独立的JS文件中 新建一个user目录以及login.js及register.js： 编写组件，只写模板，不写功能。 login.js内容如下，注意这里的&amp;emsp与&amp;ensp： 123456789const loginForm = &#123; template:&#x27;\\ &lt;div&gt;\\ &lt;h2&gt;登录页&lt;/h2&gt; \\ 用户名：&lt;input type=&quot;text&quot;&gt;&lt;br/&gt;\\ 密码：&lt;input type=&quot;password&quot;&gt;&lt;br/&gt;\\ &lt;/div&gt;\\ &#x27;&#125; register.js内容： 12345678910const registerForm = &#123; template:&#x27;\\ &lt;div&gt;\\ &lt;h2&gt;注册页&lt;/h2&gt; \\ 用&amp;ensp;户&amp;ensp;名：&lt;input type=&quot;text&quot;&gt;&lt;br/&gt;\\ 密&amp;emsp;&amp;emsp;码：&lt;input type=&quot;password&quot;&gt;&lt;br/&gt;\\ 确认密码：&lt;input type=&quot;password&quot;&gt;&lt;br/&gt;\\ &lt;/div&gt;\\ &#x27;&#125; 7.1.3 在父组件中引用123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--&lt;loginForm&gt;&lt;/loginForm&gt;--&gt; &lt;!-- 疑问：为什么不采用上面的写法？ 由于html是大小写不敏感的，如果采用上面的写法，则被认为是&lt;loginform&gt;&lt;/loginform&gt; 所以，如果是驼峰形式的组件，需要把驼峰转化为“-”的形式 --&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;user/login.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;user/register.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, components: &#123; loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 7.1.5 问题​ 我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 ​ 但是，如何才能动态加载组件，实现组件切换呢？ ​ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 7.2 vue-router简介和安装使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src=&quot;../node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; 7.3 示例新建对象并指定路由规则1）新建vue-router对象，并且指定路由规则： 12345678910// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写路由规则 &#123; path:&quot;/login&quot;, // 请求路径（路由路径），必须以/开头 component:loginForm // 组件名称 &#125;, &#123;path:&quot;/register&quot;,component:registerForm&#125;, ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径，必须以/开头 component：组件名称 父组件引入router对象2）在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:&quot;#app&quot;, components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制3）页面跳转控制： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html 8.webpackWebpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle。 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 8.1 安装webpack支持全局安装和本地安装，官方推荐是本地安装。 安装最新版本webpack，输入命令：npm install --save-dev webpack webpack 4+ 版本，你还需要安装 CLI ，输入命令：npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 8.2 核心概念学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 8.3 编写webpack配置接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 8.3.1 入口entrywebpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？ 我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！ 然后把原来index.html中的js代码全部移动到index.js中 123456789101112131415161718192021222324// 使用es6的语法导入js模块import Vue from &#x27;../node_modules/vue/dist/vue&#x27;;import VueRouter from &#x27;../node_modules/vue-router/dist/vue-router&#x27;;import loginForm from &#x27;./user/login&#x27;;import registerForm from &#x27;./user/register&#x27;;Vue.use(VueRouter);// 创建vue对象const router = new VueRouter(&#123; routes: [ // 编写路由规则 // path: 路由请求路径；component：组件名称 &#123;path: &quot;/login&quot;, component: loginForm&#125;, &#123;path: &quot;/register&quot;, component: registerForm&#125; ]&#125;);var vm = new Vue(&#123; el: &quot;#app&quot;, components: &#123; loginForm, registerForm &#125;, router&#125;); 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 注意，要使用import，就需要在login.js和register.js中添加export导出语句： 123456789const loginForm=&#123; template: &#x27;\\ &lt;div&gt;\\ &lt;h2&gt;登陆页&lt;/h2&gt;\\ 用户名：&lt;input type=&quot;text&quot;&gt;&lt;br&gt;\\ 密&amp;emsp;码：&lt;input type=&quot;password&quot;&gt;\\ &lt;/div&gt;&#x27;, &#125; export default loginForm; register.js: 1234567891011const registerForm = &#123; template:&#x27;\\ &lt;div&gt;\\ &lt;h2&gt;注册页&lt;/h2&gt; \\ 用&amp;ensp;户&amp;ensp;名：&lt;input type=&quot;text&quot;&gt;&lt;br/&gt;\\ 密&amp;emsp;&amp;emsp;码：&lt;input type=&quot;password&quot;&gt;&lt;br/&gt;\\ 确认密码：&lt;input type=&quot;password&quot;&gt;&lt;br/&gt;\\ &lt;/div&gt;\\ &#x27; &#125; export default registerForm; vue-router使用模块化加载后，必须增加一句：Vue.use(VueRouter) 这样，index.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //指定打包的入口文件&#125; 8.3.2 出口output出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports=&#123; entry:&#x27;./src/main.js&#x27;, //指定打包的入口文件 output:&#123; // path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 path : __dirname+&#x27;/dist&#x27;, filename:&#x27;build.js&#x27; //输出的js文件名 &#125;&#125; 8.4 执行打包在控制台输入以下命令： 1npx webpack --config webpack.config.js 随后，查看dist目录： 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 8.5 测试运行在index.html中引入刚刚生成的build.js文件， 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../dist/build.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行： 8.6 打包CSS我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a&#123; display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;&#125;#app a:hover&#123; background-color: whitesmoke; color: dodgerblue;&#125;#app div&#123; width: 300px; height: 150px;&#125;#app&#123; width: 305px; border: 1px solid dodgerblue;&#125; 8.6.1.安装加载器前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 命令：npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： 8.6.2 index.js引入css文件因为入口在index.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import &#x27;./css/main.css&#x27; 8.6.3 配置加载器在webpack.config.js配置文件中配置css的加载器 123456789101112131415161718module.exports = &#123; entry: &#x27;./src/main.js&#x27;, //指定打包的入口文件 output: &#123; path: __dirname + &#x27;/dist&#x27;, // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: &#x27;build.js&#x27; //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ] &#125; ] &#125;&#125; 8.6.4 重新打包再次输入打包指令：npx webpack --config webpack.config.js 效果： 8.7 script脚本我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是配置脚本的名称build 8.8 打包HTML之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件：npm install --save-dev html-webpack-plugin 需要在webpack.config.js中添加插件： 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; entry: &#x27;./src/main.js&#x27;, //指定打包的入口文件 output: &#123; path: __dirname + &#x27;/dist&#x27;, // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: &#x27;build.js&#x27; //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ] &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: &#x27;首页&#x27;, //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: &#x27;index.html&#x27;, // dist目录下生成的文件名 template: &#x27;./src/index.html&#x27; // 我们原来的index.html，作为模板 &#125;) ]&#125; 2）将原来HTML中的引入js代码删除： 3）再次打包：npm run build 4）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;build.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.9 热更新的web服务刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件：npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1&quot;&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3）运行脚本：npm run dev 4）效果： 9.vue-cli9.1 介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令： 1npm install -g vue-cli 9.2 快速上手我们新建一个module： 切换到该目录： 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 前面几项都走默认或yes 下面这些我们选no 最后，再选yes，使用 npm安装 开始初始化项目，并安装依赖，可能需要 安装成功！ 可以使用npm run dev命令启动。 9.3 项目结构安装好的项目结构： 入口文件：main.js 9.4 单文件组件需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 9.5 运行看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面：","categories":[{"name":"乐优商城","slug":"乐优商城","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"},{"name":"Vue_router_webpack_cli","slug":"乐优商城/Vue-router-webpack-cli","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/Vue-router-webpack-cli/"}],"tags":[{"name":"Vue实例的常见属性","slug":"Vue实例的常见属性","permalink":"https://mrchen229.github.io/tags/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7/"},{"name":"Vue生命周期的钩子函数","slug":"Vue生命周期的钩子函数","permalink":"https://mrchen229.github.io/tags/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"},{"name":"vue常见指令","slug":"vue常见指令","permalink":"https://mrchen229.github.io/tags/vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"},{"name":"Vue全局组件与局部注册","slug":"Vue全局组件与局部注册","permalink":"https://mrchen229.github.io/tags/Vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C/"},{"name":"vue_router使用","slug":"vue-router使用","permalink":"https://mrchen229.github.io/tags/vue-router%E4%BD%BF%E7%94%A8/"},{"name":"webpack使用","slug":"webpack使用","permalink":"https://mrchen229.github.io/tags/webpack%E4%BD%BF%E7%94%A8/"},{"name":"使用vue_cli搭建项目","slug":"使用vue-cli搭建项目","permalink":"https://mrchen229.github.io/tags/%E4%BD%BF%E7%94%A8vue-cli%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"乐优商城结构_基本框架搭建_ES6语法","slug":"leyou_结构_基本框架搭建_ES6/乐优商城结构_基本框架搭建_ES6语法","date":"2020-08-30T02:15:08.000Z","updated":"2020-08-30T02:18:10.569Z","comments":true,"path":"2020/08/30/leyou_结构_基本框架搭建_ES6/乐优商城结构_基本框架搭建_ES6语法/","link":"","permalink":"https://mrchen229.github.io/2020/08/30/leyou_%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA_ES6%E8%AF%AD%E6%B3%95/","excerpt":"","text":"知识点 电商行业介绍 乐优商城整体项目结构 项目基本框架的搭建（EurekaServer、zuul、leyou-item、leyou-common） ES6语法 1. 电商行业1.1 项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1 传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2 互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 互联网项目中的重要角色：电商: 1.2 电商行业的发展1.2.1 涉及点​ alisql oceanbase dubbo rabbitMQ 1.2.2 技术特点​ 电商行业的特点： 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3 常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：闲鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4 一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV * 平均页面大小（单位MB）* 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV * 80%） / （3600s * 24 * 20%） * 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 技术经理： 产品经理：设计需求原型 测试： 前端：大前端：UI 前端页面。 后端： 移动端： 项目开发流程图： 2. 乐优商城介绍2.1 项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单 可以评论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2 系统架构2.2.1 架构图乐优商城架构缩略图： 2.2.2 系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 Eureka注册中心 Zuul网关服务 … 3.项目搭建1234整个springcloud项目结构： 浏览器访问接口，需要先经过zuul网关，后面是一堆的微服务 zuul网关也在eureka-server中,当有微服务时，配置zuul的路由 这时候zuul会根据指定需要代理的微服务，当通过zuul端口进行访问时，（映射路径），就会代理到eureka相应的服务名称所对应的服务中，并实现了负载均衡（负载均衡就能够帮我们根据service名称，获取到服务实例的ip和端口）。 需要学习的部分12341. zuul网关怎么分发请求的 OK2. datasource的配置是怎么和mybatis springmvc结合的3. yml文件中会有bean注入什么的吗 不会，是覆盖的springboot的默认配置，内部会对这个application*.yml的文件进行读取。 3.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify（UI框架） 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.x和MyBatis3 Spring Boot 2.0.7版本 Spring Cloud 最新版 Finchley.SR2 Redis-4.0 RabbitMQ-3.4 Elasticsearch-6.3 nginx-1.14.2 FastDFS - 5.0.8 MyCat Thymeleaf mysql 5.6 3.2 开发环境环境： IDE：Idea 2019.3 ，参考资料的《idea使用指南.md》 JDK：使用JDK1.8 项目构建：maven3.3.9以上版本即可（3.5.2） 版本控制工具：git 3.3 域名开发过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com，leyou.com leyou.cn 二级域名：manage.leyou.com/item , api.leyou.com 可以通过switchhost工具《资料》来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 也可以自己在hosts文件中修改。 3.4 创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是module 填写项目信息： 填写保存的位置信息： pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等，很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 可以删除src目录，工程结构如下： 3.5 创建EurekaServer3.5.1 创建工程注册中心起名为：leyou-registry 选择新建module： 不要选择骨架： 然后填写项目坐标，我们的项目名称为leyou-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 3.5.2 pom.xml添加依赖添加EurekaServer的依赖： 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-registry&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.5.3 启动类12345678@SpringBootApplication@EnableEurekaServerpublic class LeyouRegistryApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouRegistryApplication.class, args); &#125;&#125; 3.5.4 yml配置文件1234567891011121314server: port: 10086spring: application: name: leyou-registryeureka: client: service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka register-with-eureka: false # 把自己注册到eureka服务列表 fetch-registry: false # 拉取eureka服务信息 server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒钟，进行一次服务列表的清理 3.5.5 项目的结构目前，整个项目的结构如图： 3.6 创建Zuul网关3.6.1 创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：leyou-gateway 填写保存的目录： 3.6.2 pom.xml添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-gateway&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot提供微服务检测接口，默认对外提供几个接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6.3 启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LeyouGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouGatewayApplication.class, args); &#125;&#125; 3.6.4 yml配置文件123456789101112server: port: 10010spring: application: name: leyou-gatewayeureka: client: registry-fetch-interval-seconds: 5 service-url: defaultZone: http://127.0.0.1:10086/eurekazuul: prefix: /api # 路由路径前缀 3.6.5 项目结构目前，leyou下有两个子模块： leyou-registry：服务的注册中心（EurekaServer） leyou-gateway：服务网关（Zuul） 目前，服务的结构如图所示： 到这里已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）以后添加。 3.7 创建商品微服务既然是一个全品类的电商购物平台，那么核心自然就是商品。 因此搭建的第一个服务就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 3.7.1 微服务的结构因为与商品的品类相关，工程命名为leyou-item. 需要注意的是，leyou-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，获取的接口数据，也需要对应的实体类来封装，因此肯定也会使用到接口中关联的实体类。 因此这里需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 会在leyou-item中创建两个子工程： leyou-item-interface：主要是对外暴露的接口及相关实体类 leyou-item-service：所有业务逻辑及内部使用接口，这是微服务模块 调用关系如图所示： 3.7.2 leyou-item依然是使用maven构建： 保存的位置： pom.xml因为是聚合工程，所以把项目打包方式设置为pom 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 3.7.3.leyou-item-interface在leyou-item工程上点击右键，选择new –&gt; module: 依然是使用maven构建，注意父工程是leyou-item： 注意：目录结构，保存到leyou-item下的leyou-item-interface目录中： 点击Finish完成。 此时的项目结构： 3.7.4 leyou-item-service与leyou-item-interface类似，我们选择在leyou-item上右键，新建module，然后填写项目信息： 填写存储位置 点击Finish完成。 3.7.5 整个微服务结构如图所示： 我们打开leyou-item的pom查看，会发现leyou-item-interface和leyou-item-service都已经成为module了： 可以删除leyou-item工程的src目录 3.7.6 item-serivice的pom.xml添加依赖接下来我们给leyou-item-service中添加依赖： 需要: Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要leyou-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- web启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jdbc启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springboot检测服务启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; leyou-item-interface需要什么依赖，再引入。 3.7.7 编写启动类和yml配置在整个leyou-item工程中，只有leyou-item-service是需要启动的。因此在其中编写启动类即可： 12345678@SpringBootApplication@EnableDiscoveryClientpublic class LeyouItemServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouItemServiceApplication.class, args); &#125;&#125; 然后是yml全局属性文件： 12345678910111213141516171819server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/leyou username: root password: root hikari: max-lifetime: 28830000 # 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数（show variables like &#x27;%timeout%&#x27;;） maximum-pool-size: 9 # 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count)eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 5秒钟发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 3.8 添加item-service的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 修改leyou-gateway工程的application.yml配置文件： 1234zuul: prefix: /api # 路由路径前缀 routes: item-service: /item/** # 商品微服务的映射路径 3.9 启动测试我们分别启动：leyou-registry，leyou-gateway，leyou-item-service 查看Eureka面板： 3.10 测试路由规则为了测试路由规则是否畅通，是不是需要在item-service中编写一个controller接口呢？ 其实不需要，SpringBoot提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 3.11 leyou-common通用工具有些工具或通用的约定内容希望被各个服务共享，因此需要创建一个工具模块：leyou-common 右键leyou工程，使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 当前项目整体结构 4. ES6语法指南后端项目搭建完毕，接下来就是前端页面了, 需要学习ES6的语法标准。 ES6就是ECMAScript第6版标准。 4.1 什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 4.2 ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4.0 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 4.3 ES5和6的一些新特性详细参考：阮一峰的ES6教程 创建一个空的html页面： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script&gt;&lt;/script&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4.3.1 let 和 constvar var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(&quot;循环外：&quot; + i) 你猜下打印的结果是什么？ let let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(&quot;循环外：&quot; + i) 结果： const const const声明的变量是常量，不能被修改 4.3.2 字符串API 新的API ES6为字符串扩展了几个新的API，字符串只要是” “串起来的就成。eg const s =”str”： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记： 在两个`之间的部分都会被作为字符串的值，不管任意换行，甚至加入js脚本，这个换行也会当作字符串的一部分 4.3.3 解构表达式数组结构 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 对象解构 例如有个person对象： 12345const person = &#123; name:&quot;jack&quot;, age:21, language: [&#x27;java&#x27;,&#x27;js&#x27;,&#x27;css&#x27;]&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： &#123;name:n&#125;：name是person中的属性名，冒号后面的n是解构后要赋值给的变量，也就是说n是该属性的别名。 4.3.4 函数优化函数参数默认值 1）函数参数默认值 在ES6以前无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 只传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 2）箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用&#123;&#125;括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: &quot;jack&quot;, // 以前： eat: function (food) &#123; console.log(this.name + &quot;在吃&quot; + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food), // 特别注意-----------这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + &quot;在吃&quot; + food); &#125;&#125; 箭头函数结合解构表达式 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:&quot;jack&quot;, age:21, language: [&#x27;java&#x27;,&#x27;js&#x27;,&#x27;css&#x27;]&#125;function hello(person) &#123; console.log(&quot;hello,&quot; + person.name)&#125; 如果用箭头函数和解构表达式，这个就相当于说是参数为{name}，而不是person 12var hi = (&#123;name&#125;) =&gt; console.log(&quot;hello,&quot; + name); //注意这里是&#123;&#125;hi(person) 4.3.5 map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 12345let arr = [&#x27;1&#x27;,&#x27;20&#x27;,&#x27;-5&#x27;,&#x27;3&#x27;];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选）。 第一个参数（函数）接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 相当于跟循环计数类似，只是说写法不同。 举例： 1const arr &#x3D; [1,20,-5,3] 没有初始值： 这里第一个就是 1+20 ==&gt; 21+-5 ==&gt; 16+3 指定初始值： 这里的第四个就是 -1*1==&gt; -1*20 ==&gt; -20*-5 ==&gt; 100*3 4.3.6 对象扩展keys values entries assignES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 ​ 使用: Object.keys(person1) values(obj)：获取对象的所有value形成的数组 ​ 使用：Object.values(person1) entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] ​ 使用：Object.entries(person1) assign(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝），相同的属性会覆盖，不同属性会添加。 4.3.7 数组扩展find findIndex includesES6给数组新增了许多方法： find(callback)：数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 ​ eg: arr.find(a=&gt;a==30) arr.find(p=&gt;p.age==30) findIndex(callback)：数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 includes(数组元素)：与find类似，如果匹配到元素，则返回true，代表找到了，注意这只能适用基本数据类型。 ES6总结123456789101112131415161718192021222324252627282930313233341.let:声明一个变量，不会越界 const：声明一个常量 2.字符串 includes startsWith endsWith const ss = `` 3.解构表达式 数组：let [x,y,z]=arr 对象: let &#123;name:a, age:b&#125;=person 4.函数 赋默认值：方法参数列表赋默认值 (a, b=1)=&gt;&#123;&#125; 箭头函数：()=&gt;&#123;&#125; 对象中定义函数： 传统 eat：function()&#123;&#125; 箭头 eat：()=&gt;&#123;&#125; 简写 eat()&#123;&#125; 箭头函数结合结构表达式：(&#123;name&#125;)=&gt;&#123;&#125;5.map和reduce map(fun)：处理一个数组，遍历数组中的每一个元素用fun处理，把处理结果放入新的数组 reduce(fun(a, b)[, 100])：没有初始值（1. a=10 b=20 2. a=30 b=30） 有初始值（1.a=100 b=10 2.a=110 b=20） 6.对象的扩展 keys values entries：二维数组 assign(dest, ...src) 7.数组扩展 find findIndex includes","categories":[{"name":"乐优商城","slug":"乐优商城","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"},{"name":"乐优商城结构_基本框架_ES6","slug":"乐优商城/乐优商城结构-基本框架-ES6","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6-ES6/"}],"tags":[{"name":"乐优商城结构","slug":"乐优商城结构","permalink":"https://mrchen229.github.io/tags/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84/"},{"name":"基本框架搭建(EurekaServer_zuul_item_common)","slug":"基本框架搭建-EurekaServer-zuul-item-common","permalink":"https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA-EurekaServer-zuul-item-common/"},{"name":"ES6语法","slug":"ES6语法","permalink":"https://mrchen229.github.io/tags/ES6%E8%AF%AD%E6%B3%95/"}]},{"title":"Hystrix(降级_熔断)_Feign_Zuul_ZuulFilter","slug":"leyou_springcloud_hystrix_feign_zuul/Hystrix(降级_熔断)_Feign_Zuul_ZuulFilter","date":"2020-08-29T06:04:08.000Z","updated":"2020-08-29T06:50:33.612Z","comments":true,"path":"2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(降级_熔断)_Feign_Zuul_ZuulFilter/","link":"","permalink":"https://mrchen229.github.io/2020/08/29/leyou_springcloud_hystrix_feign_zuul/Hystrix(%E9%99%8D%E7%BA%A7_%E7%86%94%E6%96%AD)_Feign_Zuul_ZuulFilter/","excerpt":"","text":"总结基本流程： 1231.引入启动器2.覆盖默认配置3.在引导类上启用组件 Eureka 高可用 心跳过期 service-provider 1234eureka： instance: lease-renewal-interval-in-seconds: 5 # 心跳时间 lease-expiration-duration-in-seconds: 15 # 过期时间 拉取服务的间隔时间 service-consumer 123eureka: client: registry-fetch-interval-seconds: 5 关闭自我保护，定期清除无效连接 1234eureka: server: eviction-interval-timer-in-ms: 5000 enable-self-preservation: false ribbon: 负载均衡组件 1231.eureka集成了2.@LoadBalanced：开启负载均衡3.this.restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, User.class); hystrix：容错组件 1234567服务降级：检查每次请求，是否请求超时，或者连接池已满 1.引入hystrix启动器 2.熔断时间，默认1s,可以修改 3.在引导类上添加了一个注解：@EnableCircuitBreaker @SpringCloudApplication 4.定义熔断方法：局部（要和被熔断的方法返回值和参数列表一致） 全局（返回值类型要被熔断的方法一致，参数列表必须为空） 5.@HystrixCommand(fallbackMethod=&quot;局部熔断方法名&quot;)：声明被熔断的方法 6.@DefaultProperties(defaultFallback=&quot;全局熔断方法名&quot;) 1234熔断：不再发送请求 1.close：闭合状态，所有请求正常方法 2.open：打开状态，所有请求都无法访问。如果在一定时间内容，失败的比例不小于50%或者次数不少于20次 3.half open：半开状态，打开状态默认5s休眠期，在休眠期所有请求无法正常访问。过了休眠期会进入半开状态，放部分请求通过 feign 1234561.引入openFeign启动器2.feign.hystrix.enable=true,开启feign的熔断功能3.在引导类上 @EnableFeignClients4.创建一个接口，在接口添加@FeignClient(value=&quot;服务id&quot;, fallback=实现类.class)5.在接口中定义一些方法，这些方法的书写方式跟之前controller类似6.创建了一个熔断类，实现feign接口，实现对应的方法，这些实现方法就是熔断方法 zuul 123456789101112131415161718192021 1.引入zuul的启动器 2.配置： zuul.routes.&lt;路由名称&gt;.path&#x3D;&#x2F;service-provider&#x2F;** zuul.routes.&lt;路由名称&gt;.url&#x3D;http:&#x2F;&#x2F;localhost:8082 zuul.routes.&lt;路由名称&gt;.path&#x3D;&#x2F;service-provider&#x2F;** zuul.routes.&lt;路由名称&gt;.serviceId&#x3D;service-provider zuul.routes.服务名&#x3D;&#x2F;service-provider&#x2F;** ******************* 不用配置，默认就是服务id开头路径 3.@EnableZuulProxy过滤器： 创建一个类继承ZuulFilter基类 重写四个方法 filterType：pre route post error filterOrder：返回值越小优先级越高 shouldFilter：是否执行run方法。true执行 run：具体的拦截逻辑 设置负载均衡和熔断 知识点 Hystix配置 服务降级 服务熔断 Feign配置（集成了ribbon与hystrix） Zuul网关配置（集成了ribbon与hystrix） Zuul的过滤器 注意点：要区分 注册中心、服务提供方、服务消费方的配置 1.Hystrix1.1 简介Hystrix是一种保护机制, 是Netflix公司的一款组件。 主页：https://github.com/Netflix/Hystrix/ ​ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 1.2 雪崩问题微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路： 如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。 如果此时，某个服务出现异常： 例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞： 服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。 Hystix解决雪崩问题的手段有两个： 线程隔离 服务熔断 1.3 线程隔离，服务降级1.3.1 原理线程隔离示意图： 解读： ​ Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队。加速失败判定时间。 ​ 用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务 ​ 如果线程池已满，或者请求超时，则会进行降级处理，也就是服务降级： 服务降级：优先保证核心服务，而非核心服务不可用或弱可用。 ​ 用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息）。 ​ 服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。 触发Hystix服务降级的情况： 1.线程池已满 2.请求超时 1.3.2 示例（配置消费方）引入依赖首先在service-consumer的pom.xml中引入Hystrix依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 开启熔断 ​ 可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：**@SpringCloudApplication** 因此可以使用这个组合注解来代替之前的3个注解。 12345678910111213@SpringCloudApplicationpublic class ItcastServiceConsumerApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 编写降级逻辑改造service-consumer，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成： 12345678910111213141516171819@Controller@RequestMapping(&quot;consumer/user&quot;)public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody @HystrixCommand(fallbackMethod = &quot;queryUserByIdFallBack&quot;) public String queryUserById(@RequestParam(&quot;id&quot;) Long id) &#123; String user = this.restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, String.class); return user; &#125; public String queryUserByIdFallBack(Long id)&#123; return &quot;请求繁忙，请稍后再试！&quot;; &#125;&#125; 要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：相同的参数列表和返回值声明。 ​ 失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。 说明： @HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法 测试： ​ 当itcast-service-provider正常提供服务时，访问与以前一致。但是将service-provider停机时，页面返回了降级处理信息： 默认FallBack​ 刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以可以把Fallback配置加在类上，实现默认fallback： 1234567891011121314151617181920212223242526@Controller@RequestMapping(&quot;consumer/user&quot;)@DefaultProperties(defaultFallback = &quot;fallBackMethod&quot;) // 指定一个类的全局熔断方法public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody @HystrixCommand // 标记该方法需要熔断 public String queryUserById(@RequestParam(&quot;id&quot;) Long id) &#123; String user = this.restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, String.class); return user; &#125; /** * 熔断方法 * 返回值要和被熔断的方法的返回值一致 * 熔断方法不需要参数 * @return */ public String fallBackMethod()&#123; return &quot;请求繁忙，请稍后再试！&quot;; &#125;&#125; 1）@DefaultProperties(defaultFallback = “defaultFallBack”)：在类上指明统一的默认失败降级方法 2）@HystrixCommand：在方法上直接使用该注解，使用默认的剪辑方法，若指定了方法则使用指定的。 3）defaultFallback：默认降级方法，不用任何参数，以匹配更多方法，但是返回值一定一致 注意： ​ 若熔断方法写了返回值不是String需要自己进行序列化操作(ObjectMapper)。 设置超时​ 在之前的案例中，请求在超过1秒后都会返回错误信息，部署时这个时间较小，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值： ​ 可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。该配置没有提示。 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms 改造服务提供者 改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断： 123456789@GetMapping(&quot;&#123;id&#125;&quot;)public User queryUserById(@PathVariable(&quot;id&quot;) Long id) &#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return this.userService.queryUserById(id);&#125; 1.4 服务熔断1.4.1 熔断条件与状态熔断器，也叫断路器，其英文单词为：Circuit Breaker 熔断状态机3个状态： 1）Closed：关闭状态，所有请求都正常访问。 2）Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。 三个重要参数：快照时间窗、请求总数阈值、错误百分比阈值 1231.快照时间窗: 断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒2.请求总数阈值：在快照时间窗内，必须满足请求综述阈值才有资格熔断。默认为20s，意味着10秒内，若该hystrix命令的调用次数不足20次，即使所有的请求都超时或者其他原因失败，断路器都不会打开。3.错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了20次调用，若在这20次调用中10次发生了超时异常，也就是超过了50%的错误百分比，此时断路器就会打开。 3）Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S），随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求成功，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时 1.4.2 配置修改熔断策略为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑： 123456789@GetMapping(&quot;&#123;id&#125;&quot;)@HystrixCommandpublic String queryUserById(@PathVariable(&quot;id&quot;) Long id)&#123; if(id == 1)&#123; throw new RuntimeException(&quot;太忙了&quot;); &#125; String user = this.restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, String.class); return user;&#125; 这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空service-provider中的休眠逻辑） 我们准备两个请求窗口： 一个请求：http://localhost/consumer/user/1，注定失败 一个请求：http://localhost/consumer/user/2，肯定成功 当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会断开，一切请求都会被降级处理。 此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有几毫秒左右： 不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略： 123circuitBreaker.requestVolumeThreshold=10circuitBreaker.sleepWindowInMilliseconds=10000circuitBreaker.errorThresholdPercentage=50 解读： requestVolumeThreshold：触发熔断的最小请求次数，默认20 errorThresholdPercentage：触发熔断的失败请求最小占比，默认50% sleepWindowInMilliseconds：休眠时长，默认是5000毫秒 2. Feign(集成ribbon与hystrix)Ribbon的负载均衡功能 能大大简化远程调用时的代码： 1String user = this.restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, String.class); 但需要编写类似的大量重复代码，格式基本相同，无非参数不一样。Feign能够对其进一步优化。 2.1 简介​ Feign就是伪装，Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign 2.2.快速入门（配置消费方）改造service-consumer工程 2.2.1 导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2.2.2 开启Feign功能我们在service-consumer启动类上，添加注解，开启Feign功能 12345678@SpringCloudApplication@EnableFeignClients // 开启feign客户端public class ItcastServiceConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 删除RestTemplate：feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，此处不需要再注册RestTemplate。 2.2.3 Feign的客户端在service-consumer工程中，添加UserClient接口： 内容： 123456@FeignClient(value = &quot;service-provider&quot;) // 标注该类是一个feign接口public interface UserClient &#123; @GetMapping(&quot;user/&#123;id&#125;&quot;) User queryById(@PathVariable(&quot;id&quot;) Long id); //这里和service-provider的写法相同&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，调用UserClient接口： 123456789101112131415@Controller@RequestMapping(&quot;consumer/user&quot;)public class UserController &#123; @Autowired private UserClient userClient; @GetMapping //@GetMapping(&quot;$&#123;id&#125;&quot;)，下面就要改成@PathVariable(&quot;id&quot;) @ResponseBody public User queryUserById(@RequestParam(&quot;id&quot;) Long id)&#123; User user = this.userClient.queryUserById(id); return user; &#125;&#125; 补充： ​ @GetMapping,@PostMapping,@PutMapping注解无value值时，不写value值的时候默认调用根路径，所以一个controller中不能有多个注解不写value值。当如果请求方式不一样是可以多个的，但是每种请求方法也只能有一个不写value值。 ​ 所以这里还是写上的好。 2.2.4 启动测试访问接口： 正常获取到了结果。 2.3 负载均衡(ribbon)Feign中本身已经集成了Ribbon依赖和自动配置： 因此不需要额外引入依赖，也不需要再注册RestTemplate对象。 2.4 熔断(Hystrix)(配置消费方)Feign默认也有对Hystrix的集成： 只不过，默认情况下是关闭的。需要通过下面的参数来开启：**(在service-consumer工程添加配置内容)** 123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像hystrix中那样简单了。 1）首先，我们要**定义一个类UserClientFallback，实现刚才编写的UserClient**，作为fallback的处理类，注意这里的@Component ​ @component （把普通pojo实例化到spring容器中，相当于配置文件中的 &lt;bean id=&quot;&quot; class=&quot;&quot;/&gt; ） 12345678910@Componentpublic class UserClientFallback implements UserClient &#123; @Override public User queryById(Long id) &#123; User user = new User(); user.setUserName(&quot;服务器繁忙，请稍后再试！&quot;); return user; &#125;&#125; 2）然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = &quot;service-provider&quot;, fallback = UserClientFallback.class) // 标注该类是一个feign接口public interface UserClient &#123; @GetMapping(&quot;user/&#123;id&#125;&quot;) User queryUserById(@PathVariable(&quot;id&quot;) Long id);&#125; 3）重启测试： 2.5 请求压缩(了解)Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： 123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： 123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 2.6 日志级别(配置消费方)​ 前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置com.leyou包下的日志级别都为debug 123logging: level: com.leyou: debug 2）编写配置类，定义日志级别 内容： 12345678@Configurationpublic class FeignLogConfiguration &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 这里指定的Level级别是FULL，Feign支持4种级别： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： 12345@FeignClient(value = &quot;service-privider&quot;, fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User queryUserById(@PathVariable(&quot;id&quot;) Long id);&#125; 4）重启项目，即可看到每次访问的日志： 3. Zuul网关(集成ribbon与hystrix)通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现； 而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。 为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含： 内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。 在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要**实现对服务访问的权限控制**(每个需要重复实现权限控制)，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 解决：服务网关！ ​ 为了解决这些问题，需要将权限控制这样的东西从服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，需要一个更强大一些的均衡负载器的 服务网关。 ​ 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。 ​ Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 3.1 简介官网：https://github.com/Netflix/zuul 12路由：分发给不同的微服务（服务名），service-provider-a， service-provider-b负载均衡：同一个微服务的不同实例 service-provider 3.2.Zuul加入后的架构 ​ 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。 ​ Zuul就是我们服务的统一入口。 12注意，这个示例中是用zuul代理service-provider，所以说zuul是代理某一些指定的服务，并不是所有。 这些服务被zuul代理后，请求会经过zuul再到服务之中。 3.3 快速入门3.3.1 新建工程填写基本信息： 添加Zuul依赖： 这一步的依赖是自动添加，手动则为： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 3.3.2 编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 3.3.3 编写引导类通过@EnableZuulProxy 注解开启Zuul的功能： 12345678@SpringBootApplication@EnableZuulProxy // 开启zuul网关public class ItcastZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastZuulApplication.class, args); &#125;&#125; 3.3.4 编写路由规则我们需要用Zuul来代理service-provider服务，先看一下控制面板中的服务状态： ip为：127.0.0.1 端口为：8081 映射规则： 12345678910server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名zuul: routes: service-provider: # 这里是路由id，随意写,习惯上是路由到哪个服务，就写哪个服务名 path: /service-provider/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们**将 /service-provider/开头的请求，代理到http://127.0.0.1:8081 ** 3.3.5 启动测试访问的路径中需要加上配置规则的映射路径，我们访问：http://127.0.0.1:10010/service-provider/user/1 即 域名+端口+服务名称+请求地址 能访问到该服务，实际上是该服务对应的负载均衡后的ip+端口+请求地址。 这样就路由到了这个服务。 3.4 面向服务的路由​ 在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ ​ 对itcast-zuul工程修改优化：将zuul注入到eureka容器，才能拉取服务列表 3.4.1 添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2 添加Eureka配置，获取服务信息12345eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka 3.4.3 开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 3.4.4 修改映射配置，通过服务名称获取​ 因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: service-provider: # 这里是路由id，随意写 path: /service-provider/** # 这里是映射路径 serviceId: service-provider # 指定服务名称 3.4.5 启动测试再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： 3.5 简化的路由配置（常用）在刚才的配置中，我们的规则是这样的： zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 zuul.routes.&lt;route&gt;.serviceId=service-provider：来指定服务名。 ​ 而大多数情况下，我们的**&lt;route&gt;路由名称往往和服务名会写成一样的**。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; ​ 比方说上面我们关于service-provider的配置可以简化为一条： 123zuul: routes: service-provider: /service-provider/** # 这里是映射路径 省去了对服务名称的配置。这里就是把所有 /service-provider/** 的请求代理到service-provider服务 3.6 默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。 因此Zuul就指定了默认的路由规则： ​ 默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：service-provider，则默认的映射路径就 是：/service-provider/** 也就是说，刚才的映射规则我们完全不配置也是OK的。eg http://127.0.0.1:10010/service-provider/user/1 3.7 路由前缀配置示例： 12345zuul: routes: service-provider: /service-provider/** service-consumer: /service-consumer/** prefix: /api # 添加路由前缀 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 3.8 过滤器​ Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。 ​ 而这个动作我们往往是通过Zuul提供的过滤器来实现的。即对请求的拦截。 3.8.1 ZuulFilterZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 1234567public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行，路由之前的过滤器 route：在路由请求时调用，路由之中的过滤器 post：在route和errror过滤器之后调用，路由之后的过滤器 error：处理请求时发生错误调用，错误处理 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 3.8.2.过滤器执行生命周期这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 正常流程： 请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。 如果是POST过滤器出现异常，会跳转到error过滤器然后响应，但是与pre和route不同的是，请求不会再到达POST过滤器了。 所有内置过滤器列表： 3.8.3 使用场景场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 3.9 自定义过滤器​ 接下来我们来自定义一个过滤器，模拟一个登录的校验。 ​ 基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 3.9.1 定义过滤器类 内容：注意@Component放入spring容器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Componentpublic class LoginFilter extends ZuulFilter &#123; /** * 过滤器类型，pre route post error，这里是前置过滤器 * @return */ @Override public String filterType() &#123; return &quot;pre&quot;; &#125; /** * 过滤器的执行顺序 * @return */ @Override public int filterOrder() &#123; return 1; &#125; /** * 该过滤器是否生效 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /** * 过滤器的业务逻辑：登陆校验逻辑 * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123; // 获取zuul提供的context上下文对象（zuul包中） RequestContext context = RequestContext.getCurrentContext(); // 从上下文对象中获取request请求对象 HttpServletRequest request = context.getRequest(); // 获取token信息（获取参数） String token = request.getParameter(&quot;access-token&quot;); // 判断 if (StringUtils.isBlank(token)) &#123; // 过滤该请求，不转发请求，不对其进行路由，即进行拦截 context.setSendZuulResponse(false); // 设置响应状态码，401 context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED); // 设置响应信息 context.setResponseBody(&quot;&#123;\\&quot;status\\&quot;:\\&quot;401\\&quot;, \\&quot;text\\&quot;:\\&quot;request error!\\&quot;&#125;&quot;); &#125; // 校验通过，把登陆信息放入上下文信息，继续向后执行 context.set(&quot;token&quot;, token); // 返回值null，代表该过滤器什么都不做，即相当于没有该过滤器 return null; &#125;&#125; 3.9.2 测试没有token参数时，访问失败： 添加token参数后： 3.10 设置负载均衡和熔断​ Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms","categories":[{"name":"乐优商城","slug":"乐优商城","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"},{"name":"SpringCloud","slug":"乐优商城/SpringCloud","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/SpringCloud/"}],"tags":[{"name":"Hystrix(降级_熔断)","slug":"Hystrix-降级-熔断","permalink":"https://mrchen229.github.io/tags/Hystrix-%E9%99%8D%E7%BA%A7-%E7%86%94%E6%96%AD/"},{"name":"Feign","slug":"Feign","permalink":"https://mrchen229.github.io/tags/Feign/"},{"name":"Zuul","slug":"Zuul","permalink":"https://mrchen229.github.io/tags/Zuul/"},{"name":"ZuulFilter","slug":"ZuulFilter","permalink":"https://mrchen229.github.io/tags/ZuulFilter/"}]},{"title":"RPC_HTTP_RestTemplate_Springcloud_搭建Eureka(注册中心_提供_消费)_Eureka配置(心跳_获取服务列表_失效剔除_自我保护)_Ribbon配置","slug":"leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_搭建Eureka(注册中心_提供_消费)_Eureka配置(心跳_获取服务列表_失效剔除_自我保护)_Ribbon配置","date":"2020-08-29T01:10:08.000Z","updated":"2020-08-29T01:10:48.550Z","comments":true,"path":"2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_搭建Eureka(注册中心_提供_消费)_Eureka配置(心跳_获取服务列表_失效剔除_自我保护)_Ribbon配置/","link":"","permalink":"https://mrchen229.github.io/2020/08/29/leyou_springcloud_ribbon/RPC_HTTP_RestTemplate_Springcloud_%E6%90%AD%E5%BB%BAEureka(%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83_%E6%8F%90%E4%BE%9B_%E6%B6%88%E8%B4%B9)_Eureka%E9%85%8D%E7%BD%AE(%E5%BF%83%E8%B7%B3_%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8_%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4_%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4)_Ribbon%E9%85%8D%E7%BD%AE/","excerpt":"","text":"知识点 系统架构演变 服务调用方式(RPC、HTTP、RestTemplate) SpringCloud概念 独立搭建Eureka注册中心、服务提供者、服务消费者 Eureka的配置（心跳、获取服务列表、失效剔除、自我保护） Ribbon的配置与负载均衡策略 1. 系统架构演变​ 随着互联网的发展，网站应用的规模不断扩大。系统架构不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。 下面介绍系统架构演变的历程。 1.1 集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 例如一个tomcat包括后台、前台、用户管理、订单管理、购物车管理 存在的问题： 代码耦合度高，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差，并发数低 好处：维护简单 1.2 垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题，提高并发 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 解耦合 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 增加维护成本 补充： ​ 垂直拆分：功能拆分 ​ 水平拆分：分层：web service mapper 1.3 分布式服务​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 解决了代码冗余和重复开发 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 1.4 流动计算架构（SOA）SOA ：面向服务的架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 过去的问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 1.5 微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者容易混淆但有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 SpringCloud dubbo(阿里巴巴，品优购 淘淘 apache) 微服务结构图： 2. 服务调用方式2.1 RPC和HTTP无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下2种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。 现在热门的Rest风格，就可以通过http协议来实现。 如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。 ​ 相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。在项目中会选择SpringCloud套件，因此会使用Http方式来实现服务间调用。 RPCRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 1）采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 2）数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 2.2 Http客户端工具 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient (apache) OKHttp URLConnection 接下来，不过这些不同的客户端，API各不相同 12可以在idea中，new module选择已经存在的模块导入《资料》中的http_demo 在test中可以看到相关使用,B笔记中有详解。 2.3 Spring的RestTemplate(封装Http与实现序列化)Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 首先导入资料提供的http-demo 然后在项目中注册一个RestTemplate对象，可以在启动类位置注册： 123456789101112@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入：注意这里的@SpringBootTest 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; // 调用springboot案例中的rest接口 User user = this.restTemplate.getForObject(&quot;http://localhost/user/1&quot;, User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 3.SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。 后台硬：Spring家族的一员。 技术强：Spring作为Java领域的前辈，有强力的技术团队支撑。SpringCloud与Spring的各个框架无缝整合。 使用方便：SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 3.1.简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： Eureka：服务治理组件，包含服务注册中心，服务注册与发现机制的实现。（服务治理，服务注册/发现） Zuul：网关组件，提供智能路由，访问过滤功能 Ribbon：客户端负载均衡的服务调用组件（客户端负载） Feign：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) 架构图： 以上只是其中一部分。 3.2 版本版本是版本名+版本号 （如Angel.SR6）。 ​ 版本名：是伦敦的地铁名 ​ 版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 所以 Edgware.SR3就是Edgware的第3个Release版本。 项目中会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来学习SpringCloud中的重要组件。 4. 微服务场景模拟首先，我们需要模拟一个服务调用的场景，搭建两个工程：itcast-service-provider（服务提供方）和itcast-service-consumer（服务调用方）。 ​ 服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并对外提供rest接口服务。 ​ 服务消费方：使用restTemplate远程调用服务提供方的rest接口服务，获取数据。 4.1 服务提供者我们新建一个项目：itcast-service-provider，对外提供根据id查询用户的服务。 4.1.1 Spring脚手架创建工程借助于Spring提供的快速搭建工具： next–&gt;填写项目信息： next –&gt; 添加web依赖： 添加mybatis依赖： Next –&gt; 填写项目位置： 生成的项目结构，已经包含了引导类（itcastServiceProviderApplication）： 依赖也已经全部自动引入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 需要手动引入通用mapper的启动器，spring没有收录该依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 因为要使用通用mapper，需要手动加一条依赖： 12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; 4.1.2 编写代码 配置属性文件,这里我们采用了yaml语法，而不是properties： 123456789server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mybatis #你学习mybatis时，使用的数据库地址 username: root password: rootmybatis: type-aliases-package: cn.itcast.service.pojo 实体类1234567891011121314151617181920212223242526272829303132333435@Table(name = &quot;tb_user&quot;)public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; ...省略get和set方法&#125; UserMapper123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; UserService12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125; UserController添加一个对外查询的接口： 123456789101112@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;&#123;id&#125;&quot;) public User queryById(@PathVariable(&quot;id&quot;) Long id) &#123; return this.userService.queryById(id); &#125;&#125; 此外，需要在启动类中添加 @MapperScan(&quot;cn.itcast.service.mapper&quot;) //Mapper接口的包扫描 加了后UserMapper上就不用加@Mapper了 4.1.3 启动并测试启动项目，访问接口：http://localhost:8081/user/1 4.2 服务消费者搭建itcast-service-consumer服务消费方工程。 4.2.1 创建工程与上面类似，这里不再赘述，需要注意的是，我们调用itcast-service-provider的解耦获取数据，因此不需要mybatis相关依赖了。 pom： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4.2.2 编写代码 首先在引导类中注册RestTemplate： 123456789101112@SpringBootApplicationpublic class ItcastServiceConsumerApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 编写配置（application.yml）： 12server: port: 80 编写UserController： 123456789101112131415@Controller@RequestMapping(&quot;consumer/user&quot;)public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody public User queryUserById(@RequestParam(&quot;id&quot;) Long id)&#123; User user = this.restTemplate.getForObject(&quot;http://localhost:8081/user/&quot; + id, User.class); return user; &#125;&#125; pojo对象（User）： 1234567891011121314151617181920212223242526272829303132public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; ...set和get方法&#125; 4.2.3 启动测试因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost/consumer/user?id=1 4.3 问题?刚才的工程包含： itcast-service-provider：一个提供根据id查询用户的微服务。 itcast-service-consumer：一个服务调用者，通过RestTemplate远程调用itcast-service-provider。 存在什么问题？ 在consumer中把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆provider的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚provider的状态，服务宕机也不知道 provider只有1台服务，不具备高可用性 即便provider形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 以上的问题SpringCloud都能解决。 5.Eureka注册中心5.1.认识Eureka​ 解决第一问题，服务的管理。 问题分析 ​ 在刚才的案例中，itcast-service-provider对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。 ​ 当一个项目拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 Eureka做什么？ ​ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 ​ 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 5.2.原理图 基本架构： Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 5.3 案例5.3.1 搭建EurekaServer接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖：EurekaServer-服务注册中心依赖，Eureka Discovery-服务提供方和服务消费方。 因为，对于eureka来说：服务提供方和服务消费方都属于客户端 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.eureka&lt;/groupId&gt; &lt;artifactId&gt;itcast-eureka&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-eureka&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml12345678910server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示，将来作为微服务名称注入到eureka容器eureka: client: service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 # 忘记写时可以点击这个文件中的属性进去类中查看。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 引导类添加@EnableEurekaServer修改引导类，在类上添加@EnableEurekaServer注解： 12345678@SpringBootApplication@EnableEurekaServer // 声明当前springboot应用是一个eureka服务中心，启用eureka服务端public class ItcastEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastEurekaApplication.class, args); &#125;&#125; 启动服务，并访问：http://127.0.0.1:10086 5.3.2 注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 修改itcast-service-provider工程 在pom.xml中，添加springcloud的相关依赖。 在application.yml中，添加springcloud的相关依赖。 在引导类上添加注解，把服务注入到eureka注册中心。 具体操作 pom.xml参照itcast-eureka，先添加SpringCloud依赖： 123456789101112&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 完整pom.xml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; application.yml12345678910111213141516server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/heima username: root password: root driverClassName: com.mysql.jdbc.Driver application: name: service-provider # 应用名称，注册到eureka后的服务名称,将来会作为微服务的名称mybatis: type-aliases-package: cn.itcast.service.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 引导类添加@EnableDiscoveryClient在引导类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 12345678@SpringBootApplication@EnableDiscoveryClient //启用eureka客户端，也可以用@EnableEurekaClient,一般不用public class ItcastServiceProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceApplication.class, args); &#125;&#125; 重启项目，访问Eureka监控页面查看 service-provider服务已经注册成功了 5.3.3 从Eureka获取服务接下来我们修改**itcast-service-consumer，尝试从EurekaServer获取服务**。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- SpringCloud的依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; application.yml123456789server: port: 80spring: application: name: service-consumereureka: client: service-url: defaultZone: http://localhost:10086/eureka 在启动类开启Eureka客户端12345678910111213@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class ItcastServiceConsumerApplication &#123; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 此时已经注册成功。 UserController​ 修改UserController代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例，下面的示例能解决硬编码的问题： 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;consumer/user&quot;)public class UserController &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; // eureka客户端，可以获取到eureka中服务的信息 //包含了拉取的所有服务信息。 @GetMapping @ResponseBody public User queryUserById(@RequestParam(&quot;id&quot;) Long id)&#123; // 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;service-provider&quot;); // 因为只有一个Service-provider。所以获取第一个实例 ServiceInstance instance = instances.get(0); // 获取ip和端口信息，拼接成服务地址 String baseUrl = &quot;http://&quot; + instance.getHost() + &quot;:&quot; + instance.getPort() + &quot;/user/&quot; + id; User user = this.restTemplate.getForObject(baseUrl, User.class); return user; &#125;&#125; Debug跟踪运行： 生成的URL： 访问结果： 5.4 Eureka详解详解Eureka的原理及配置。 5.4.1 基础架构Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的itcast-eureka。 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的itcast-service-provider。 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的itcast-service-consumer。 5.4.2 高可用的Eureka Server模拟​ Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 ​ 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。因此相互注册只要注册一个就可以了，会进行同步。 动手搭建高可用的EurekaServer ​ 我们假设要运行两个EurekaServer的集群，端口分别为：10086和10087。只需要把itcast-eureka启动两次即可。 第一个eurekaServer1）启动第一个eurekaServer，我们修改原来的EurekaServer配置，以下就是10086注册给10087： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 启动报错，很正常。因为10087服务没有启动： 第二个eurekaServer2）启动第二个eurekaServer，再次修改itcast-eureka的配置（另一个已经部署，不会影响运行）： 123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10086 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：(也可以在Run Dashboard中右键启动器–Copy Configuration) 然后启动即可。 访问集群3）访问集群，测试： 客户端注册服务到集群4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 1234eureka: client: service-url: # EurekaServer地址,多个地址以&#x27;,&#x27;隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka 10086： 10087： 5.4.3 服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册细节 服务注册 ​ 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-eureka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。 ​ 也就是说若该属性设置为false则不会注册到EurekaServer。 1Map&lt;serviceId, Map&lt;服务示例名， 实例对象 (instance)&gt; &gt; 第一层Map的Key就是服务id，一般是配置中的spring.application.name属性 第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：locahost:service-provider:8081 值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。 服务续约配置心跳) 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为 服务的续约（renew） ； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除（应该是失效？），这两个值在生产环境不要修改，默认即可。 ​ 开发时经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 5.4.4 服务消费者获取服务列表配置 获取服务列表 ​ 当服务消费者启动时，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。 ​ 若该参数为false则不会拉取Eureka Server服务的列表。 我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 5.4.5 失效剔除和自我保护服务下线 服务下线 ​ 当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。 服务提供方的失效剔除配置 失效剔除 ​ 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。（可以理解成之前的失效但是没有剔除，这里进行剔除） ​ 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生产环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒 自我保护 自我保护 ​ 我们关停一个服务，就会在Eureka面板看到一条警告： ​ 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%**。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除**。生产环境下这很有效，保证了大多数服务依然可用。 ​ 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（itcast-eureka） 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 失效剔除与续约失效时间的区别同一个服务部署了多个实例，在通过网关调用时会随机调用其中一个。但是，当某个服务挂掉之后，依然在注册中心中，依然会随机被调用到，调用时便会超时报错。 也就是说，续约失效时间是指客户端最后一次续约后，经过默认的90秒后失效。 而失效剔除则是对失效的服务进行剔除（默认60秒） 注册中心的配置： 123456789101112131415161718192021222324252627# 注册中心的配置eureka: instance: hostname: localhost # 过期时间，默认90s, 可不配置 lease-expiration-duration-in-seconds: 90 # 续约时间，默认30s，可不配置 lease-renewal-interval-in-seconds: 30 # ip地址优先 prefer-ip-address: true server: # 关闭注册中心自我保护模式，避免注册中心不移除失效的服务，默认为true enable-self-preservation: true # 去除失效服务的时间间隔（毫秒），默认是60s eviction-interval-timer-in-ms: 1000 client: # 启用eureka客户端，默认为true, 可不配置 enabled: true # 取注册信息，默认为true，可不配置 fetchRegistry: false # 两个心跳参数，默认都是30s,可不配置 instance-info-replication-interval-seconds: 30 registry-fetch-interval-seconds: 30 # 注册到注册中心，默认为true,可不配置 registerWithEureka: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 业务微服务配置 12345678910111213#业务微服务配置示例eureka: instance: prefer-ip-address: true #以IP地址注册到服务中心 instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125; #eureka实例id ip-address: 192.168.217.211 #Eureka客户端向服务端发送心跳的时间间隔，单位为秒（客户端告诉服务端自己会按照该规则），默认30 lease-renewal-interval-in-seconds: 1 #Eureka服务端在收到最后一次心跳之后等待的时间上限，单位为秒，超过则剔除（客户端告诉服务端按照此规则等待自己），默认90 lease-expiration-duration-in-seconds: 3 client: service-url: defaultZone: http://localhost:8761/eureka/ #微服务 Eureka Server提供服务发现的能力，各个微服务启动时，会向Eureke Server注册自己的信息（如IP、端口、微服务名称等），Eureka Server会存储这些信息。 Eureka Client是一个Java客户端，用于简化与Eureke Server的交互（启动时会向Eureke Server注册自己的信息） 微服务启动后renew，会周期性（默认30秒）向Eureke Server发送心跳以续约自己的“租期” 若Eureke Server一定时间内没有接收到某个微服务实例的心跳（最后一次续约时间开始计算），Eureke Server将会注销该实例（默认90秒） 默认情况下，Eureke Server同时也是Eureke Client。多个Eureke Server实例互相之间通过增量复制的方式来实现服务注册表中数据的同步。Eureke Server默认保证在90秒内，Eureke Server集群内的所有实例中的数据达到一致。 小结1234567891011121314151617181920212223242526271.架构的演变 传统架构--&gt;水平拆分--&gt;垂直拆分（最早的分布式）--&gt;soa(dubbo)--&gt;微服务(springCloud)2.远程调用技术：rpc http rpc协议：自定义数据格式，限定技术，传输速度快，效率高 tcp，dubbo http协议：统一的数据格式，不限定技术 rest接口 tcp协议 springCloud3.什么是springCloud 微服务架构的解决方案，是很多组件的集合 eureka：注册中心，服务的注册与发现 zull：网关协议，路由请求，过滤器（ribbon hystrix） ribbon：负载均衡组件 hystrix：熔断组件 feign：远程调用组件(ribbon hystrix)*4.eureka 注册中心：itcast-eureka （1.引入启动器， 2.配置spring.application.name=itcast-eureka 3.在引导类上@EnableEurekaServer） 客户端：itcast-service-provider itcast-service-consumer （1.引入启动器 2.配置spring.application.name eureka.client.service-url.defaultZone=http://localhost:10086/eureka 3.在引导类上@EnableDiscoveryClient(启用eureka客户端)） itcast-service-consumer能通过注入的DiscoveryClient获取服务信息 6.负载均衡Ribbon​ 在刚才的案例中，我们启动了一个itcast-service-provider，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。但实际环境中，我们往往会开启很多个itcast-service-provider的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ ​ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 ​ 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 6.1 启动两个服务实例首先参照itcast-eureka启动两个ItcastServiceProviderApplication实例，一个8081，一个8082。 Eureka监控面板： 6.2 消费方开启负载均衡因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖，直接修改代码。 修改**itcast-service-consumer 的引导类，在RestTemplate的配置方法上添加@LoadBalanced注解**： 12345@Bean@LoadBalanced //开启负载均衡public RestTemplate restTemplate() &#123; return new RestTemplate();&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 123456789101112131415161718192021@Controller@RequestMapping(&quot;consumer/user&quot;)public class UserController &#123; @Autowired private RestTemplate restTemplate; //@Autowired //private DiscoveryClient discoveryClient; // 注入discoveryClient，通过该客户端获取服务列表 @GetMapping @ResponseBody public User queryUserById(@RequestParam(&quot;id&quot;) Long id)&#123; // 通过client获取服务提供方的服务列表，这里我们只有一个 // ServiceInstance instance = discoveryClient.getInstances(&quot;service-provider&quot;).get(0); String baseUrl = &quot;http://service-provider/user/&quot; + id; User user = this.restTemplate.getForObject(baseUrl, User.class); return user; &#125;&#125; 访问页面，查看结果： 6.3 源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 在如下代码打断点： 一路源码跟踪：RestTemplate.getForObject –&gt; RestTemplate.execute –&gt; RestTemplate.doExecute： 点击进入AbstractClientHttpRequest.execute –&gt; AbstractBufferingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.execute: 继续跟入：LoadBalancerInterceptor.intercept方法 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 6.4 负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，可以测试一下： ​ 编写测试类，在刚才的源码中我们看到拦截中是使用 RibbonLoadBalanceClient 来进行负载均衡的，其中有一个choose方法，找到choose方法的接口方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们注入这个类的对象，然后对其测试： 测试内容： 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTest(classes = ItcastServiceConsumerApplication.class)public class LoadBalanceTest &#123; @Autowired private RibbonLoadBalancerClient client; @Test public void testLoadBalance()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose(&quot;service-provider&quot;); System.out.println(instance.getHost() + &quot;:&quot; +instance.getPort()); &#125; &#125;&#125; 结果： 修改负载均衡的策略: ​ 继续跟踪源码，发现这么一段代码： ​ 我们看看这个rule是谁： ​ 这里的**rule默认值是一个RoundRobinRule**，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口，在itcast-service-consumer的application.yml中添加如下配置： 123456789101112server: port: 80spring: application: name: service-consumereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eurekaservice-provider: # 服务提供方的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：&#123;服务名称&#125;.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机：","categories":[{"name":"乐优商城","slug":"乐优商城","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"},{"name":"SpringCloud","slug":"乐优商城/SpringCloud","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/SpringCloud/"}],"tags":[{"name":"系统架构演变","slug":"系统架构演变","permalink":"https://mrchen229.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/"},{"name":"RPC_HTTP_RestTemplate","slug":"RPC-HTTP-RestTemplate","permalink":"https://mrchen229.github.io/tags/RPC-HTTP-RestTemplate/"},{"name":"Springcloud概念","slug":"Springcloud概念","permalink":"https://mrchen229.github.io/tags/Springcloud%E6%A6%82%E5%BF%B5/"},{"name":"搭建Eureka(注册中心_提供_消费)","slug":"搭建Eureka-注册中心-提供-消费","permalink":"https://mrchen229.github.io/tags/%E6%90%AD%E5%BB%BAEureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E6%8F%90%E4%BE%9B-%E6%B6%88%E8%B4%B9/"},{"name":"Eureka配置(心跳_获取服务列表_失效剔除_自我保护)","slug":"Eureka配置-心跳-获取服务列表-失效剔除-自我保护","permalink":"https://mrchen229.github.io/tags/Eureka%E9%85%8D%E7%BD%AE-%E5%BF%83%E8%B7%B3-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8-%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/"},{"name":"Ribbon配置与负载均衡策略","slug":"Ribbon配置与负载均衡策略","permalink":"https://mrchen229.github.io/tags/Ribbon%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"}]},{"title":"栈_队列_数组_链表_红黑树_ArrayList_LinkedList_HashSet_LinkedHashSet_可变参数_Collections工具_Comparable_Comparator","slug":"05.集合/栈_队列_数组_链表_红黑树_ArrayList_LinkedList_HashSet_LinkedHashSet_可变参数_Collections工具_Comparable_Comparator","date":"2020-08-28T11:58:08.000Z","updated":"2020-08-28T12:00:01.721Z","comments":true,"path":"2020/08/28/05.集合/栈_队列_数组_链表_红黑树_ArrayList_LinkedList_HashSet_LinkedHashSet_可变参数_Collections工具_Comparable_Comparator/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/%E6%A0%88_%E9%98%9F%E5%88%97_%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8_%E7%BA%A2%E9%BB%91%E6%A0%91_ArrayList_LinkedList_HashSet_LinkedHashSet_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_Collections%E5%B7%A5%E5%85%B7_Comparable_Comparator/","excerpt":"","text":"知识点 栈、队列、数组、链表、红黑树 List集合 ArrayList LinkedList Set集合 HashSet LinkedHashSet 可变参数 Collections工具类 Comparable与Comparator 1. 数据结构1.1 数据结构有什么用？常见的数据结构：堆栈、队列、数组、链表和红黑树，了解它们的特点。 1.2 常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。 栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 对元素的存取有如下的特点: 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。 栈的入口、出口的都是栈的顶端位置。 注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 数组：Array，是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。 对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。 每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： ​ 二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: ​ 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 2. List集合12345java.util.List接口 extends Collection接口List接口的特点: 1.有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123) 2.有索引,包含了一些带索引的方法 3.允许存储重复的元素 12345678910List接口中带索引的方法(特有) - public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 - public E get(int index):返回集合中指定位置的元素。 - public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 - public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。注意: 操作索引的时候,一定要防止索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 2.1 List接口介绍​ java.util.List接口继承自Collection接口，是单列集合的一个重要分支，将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 2.2 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index): 返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element): 用指定元素替换集合中指定位置的元素, 返回值的更新前的元素。 List集合特有的方法都是跟索引相关： 12345678910111213141516171819202122232425262728293031323334353637383940public class ListDemo &#123; public static void main(String[] args) &#123; // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素 list.add(&quot;图图&quot;); list.add(&quot;小美&quot;); list.add(&quot;不高兴&quot;); System.out.println(list); // add(int index,String s) 往指定位置添加 list.add(1,&quot;没头脑&quot;); System.out.println(list); // String remove(int index) 删除指定位置元素 返回被删除元素 // 删除索引位置为2的元素 System.out.println(&quot;删除索引位置为2的元素&quot;); System.out.println(list.remove(2)); System.out.println(list); // String set(int index,String s) // 在指定位置 进行 元素替代（改） // 修改指定位置元素 list.set(0, &quot;三毛&quot;); System.out.println(list); // String get(int index) 获取指定位置元素 // 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; //还可以使用增强for for (String string : list) &#123; System.out.println(string); &#125; &#125;&#125; 3. List的子类3.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快。 3.2 LinkedList集合123456789101112131415161718java.util.LinkedList集合 implements List接口LinkedList集合的特点: 1.底层是一个链表结构:查询慢,增删快 2.里边包含了大量操作首尾元素的方法 注意:使用LinkedList集合特有的方法,不能使用多态 - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。 - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。 - public boolean isEmpty()：如果列表不包含元素，则返回true。 java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e): 将指定元素插入此列表的开头。 public void addLast(E e): 将指定元素添加到此列表的结尾。 public E getFirst(): 返回此列表的第一个元素。 public E getLast(): 返回此列表的最后一个元素。 public E removeFirst(): 移除并返回此列表的第一个元素。 public E removeLast(): 移除并返回此列表的最后一个元素。 public E pop(): 从此列表所表示的堆栈处弹出一个元素。 public void push(E e): 将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。 方法演示： 12345678910111213141516171819202122public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); //添加元素 link.addFirst(&quot;abc1&quot;); link.addFirst(&quot;abc2&quot;); link.addFirst(&quot;abc3&quot;); System.out.println(link); // 获取元素 System.out.println(link.getFirst()); System.out.println(link.getLast()); // 删除元素 System.out.println(link.removeFirst()); System.out.println(link.removeLast()); while (!link.isEmpty()) &#123; //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素 &#125; System.out.println(link); &#125;&#125; 4. Set接口 1234java.util.Set接口 extends Collection接口Set接口的特点: 1.不允许存储重复的元素 2.没有索引,没有带索引的方法,也不能使用普通的for循环遍历 123456java.util.HashSet集合 implements Set接口HashSet特点: 1.不允许存储重复的元素 2.没有索引,没有带索引的方法,也不能使用普通的for循环遍历 3.是一个无序的集合,存储元素和取出元素的顺序有可能不一致 4.底层是一个哈希表结构(查询的速度非常的快) ​ java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。 ​ 与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 ​ Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips: Set集合取出元素的方式可以采用：迭代器、增强for。 4.1 HashSet集合介绍 ​ java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持。 ​ HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。 保证元素唯一性的方式依赖于：hashCode与equals方法。 使用Set集合存储: 12345678910111213141516public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String(&quot;cba&quot;)); set.add(&quot;abc&quot;); set.add(&quot;bac&quot;); set.add(&quot;cba&quot;); //遍历 for (String name : set) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果如下，说明集合中不能存储重复元素： 123cbaabcbac tips: 字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。 4.2 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ ​ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 123456哈希值:是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址)在Object类有一个方法,可以获取对象的哈希值int hashCode() 返回该对象的哈希码值。hashCode方法的源码: public native int hashCode(); native:代表该方法调用的是本地操作系统的方法 4.3 HashSet存储自定义类型元素1234HashSet存储自定义类型元素set集合报错元素唯一: 存储的元素(String,Integer,...Student,Person...),必须重写hashCode方法和equals方法 ​ 给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(&quot;于谦&quot;, 43); stuSet.add(stu); stuSet.add(new Student(&quot;郭德纲&quot;, 44)); stuSet.add(new Student(&quot;于谦&quot;, 43)); stuSet.add(new Student(&quot;郭麒麟&quot;, 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] 4.4 LinkedHashSet123java.util.LinkedHashSet集合 extends HashSet集合LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(&quot;bbb&quot;); set.add(&quot;aaa&quot;); set.add(&quot;abc&quot;); set.add(&quot;bbc&quot;); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 4.5 可变参数12345678可变参数:是JDK1.5之后出现的新特性使用前提: 当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数.使用格式:定义方法时使用 修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;可变参数的原理: 可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数 传递的参数个数,可以是0个(不传递),1,2...多个 在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 JDK1.5以后。出现了简化操作。 ​ … 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。 代码演示： 1234567891011121314151617181920212223242526272829303132public class ChangeArgs &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 4, 62, 431, 2 &#125;; int sum = getSum(arr); System.out.println(sum); // 6 7 2 12 2121 // 求 这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); &#125; /* * 完成数组 所有元素的求和 原始写法 public static int getSum(int[] arr)&#123; int sum = 0; for(int a : arr)&#123; sum += a; &#125; return sum; &#125; */ //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 5. Collections工具类123- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： - public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 - public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 5.1 常用方法 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 12345678910111213141516171819public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[5, 222, 1, 2][1, 2, 5, 222] 代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？ 我们发现还有个方法没有讲，public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。 5.2 Comparator比较器123456789- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。注意: sort(List&lt;T&gt; list)使用前提 被排序的集合 里边 存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则Comparable接口的排序规则: 自己(this)-参数:升序 123456789- java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator和Comparable的区别 Comparable:自己(this)和别人(参数)比较,自己需要实现Comparable接口,重写比较的规则compareTo方法 Comparator:相当于找一个第三方的裁判,比较两个Comparator的排序规则: o1-o2:升序 我们还是先研究这个方法 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 不过这次存储的是字符串类型。 123456789101112public class CollectionsDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;cba&quot;); list.add(&quot;aba&quot;); list.add(&quot;sba&quot;); list.add(&quot;nba&quot;); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125; 结果： 1[aba, cba, nba, sba] 我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？ ​ 说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 ​ 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; ​ String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 ​ public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一, 该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: 1234567891011121314151617public class CollectionsDemo3 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;cba&quot;); list.add(&quot;aba&quot;); list.add(&quot;sba&quot;); list.add(&quot;nba&quot;); //排序方法 按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0) - o1.charAt(0); &#125; &#125;); System.out.println(list); &#125;&#125; 结果如下： 1[sba, nba, cba, aba] 5.3 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 5.4 练习Comparable创建一个学生类，存储到ArrayList集合中完成指定排序操作。 Student 初始类 123456789101112131415161718192021222324252627282930313233343536public class Student&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526public class Demo &#123; public static void main(String[] args) &#123; // 创建四个学生对象 存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(&quot;rose&quot;,18)); list.add(new Student(&quot;jack&quot;,16)); list.add(new Student(&quot;abc&quot;,16)); list.add(new Student(&quot;ace&quot;,17)); list.add(new Student(&quot;mark&quot;,16)); /* 让学生 按照年龄排序 升序 */// Collections.sort(list);//要求 该list中元素类型 必须实现比较器Comparable接口 for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125; 发现，当我们调用Collections.sort()方法的时候 程序报错了。 原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。 于是我们就完成了Student类的一个实现，如下： 1234567public class Student implements Comparable&lt;Student&gt;&#123; .... @Override public int compareTo(Student o) &#123; return this.age-o.age;//升序 &#125;&#125; 再次测试，代码就OK 了效果如下： 12345Student&#123;name=&#x27;jack&#x27;, age=16&#125;Student&#123;name=&#x27;abc&#x27;, age=16&#125;Student&#123;name=&#x27;mark&#x27;, age=16&#125;Student&#123;name=&#x27;ace&#x27;, age=17&#125;Student&#123;name=&#x27;rose&#x27;, age=18&#125; 5.5 练习Comparator如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor&lt;T&gt; c)方式，自己定义规则： 123456Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o2.getAge()-o1.getAge();//以学生的年龄降序 &#125;&#125;); 效果： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125; 如果想要规则更多一些，可以参考下面代码： 12345678910111213Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 年龄降序 int result = o2.getAge()-o1.getAge();//年龄降序 if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序 result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); 效果如下： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;","categories":[{"name":"集合","slug":"集合","permalink":"https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"栈_队列_数组_链表_红黑树","slug":"栈-队列-数组-链表-红黑树","permalink":"https://mrchen229.github.io/tags/%E6%A0%88-%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://mrchen229.github.io/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://mrchen229.github.io/tags/LinkedList/"},{"name":"HashSet","slug":"HashSet","permalink":"https://mrchen229.github.io/tags/HashSet/"},{"name":"可变参数","slug":"可变参数","permalink":"https://mrchen229.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"},{"name":"Collections工具类","slug":"Collections工具类","permalink":"https://mrchen229.github.io/tags/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Comparable与Comparator","slug":"Comparable与Comparator","permalink":"https://mrchen229.github.io/tags/Comparable%E4%B8%8EComparator/"}]},{"title":"Collection_Iterator(增强for)_泛型(泛型通配符)","slug":"05.集合/Collection_Iterator(增强for)_泛型(泛型通配符)","date":"2020-08-28T06:51:08.000Z","updated":"2020-08-28T07:16:29.956Z","comments":true,"path":"2020/08/28/05.集合/Collection_Iterator(增强for)_泛型(泛型通配符)/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/05.%E9%9B%86%E5%90%88/Collection_Iterator(%E5%A2%9E%E5%BC%BAfor)_%E6%B3%9B%E5%9E%8B(%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6)/","excerpt":"","text":"知识点 Collection集合 Iterator迭代器 增强for 泛型 泛型类、方法、接口 泛型通配符(只能使用Object类中的共性方法) 1. Collection集合共性的方法123java.util.Collection接口 所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法 任意的单列集合都可以使用Collection接口中的方法 12345678共性的方法: public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 1.1 集合概述 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别**是java.util.List和java.util.Set**。 其中，List的特点是元素有序、元素可重复。 Set的特点是元素无序，而且不可重复。 List接口的主要实现类有java.util.ArrayList和java.util.LinkedList Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 ​ 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用方法Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() : 清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println(&quot;判断 扫地僧 是否在集合中&quot;+coll.contains(&quot;扫地僧&quot;)); //boolean remove(E e) 删除在集合中的o元素 System.out.println(&quot;删除石破天：&quot;+coll.remove(&quot;石破天&quot;)); System.out.println(&quot;操作之后集合中元素:&quot;+coll); // size() 集合中有几个元素 System.out.println(&quot;集合中有&quot;+coll.size()+&quot;个元素&quot;); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println(&quot;集合中内容为：&quot;+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 2. Iterator迭代器2.1 Iterator接口123456java.util.Iterator接口:迭代器(对集合进行遍历)有两个常用的方法 boolean hasNext() 如果仍有元素可以迭代，则返回 true。 判断集合中还有没有下一个元素,有就返回true,没有就返回false E next() 返回迭代的下一个元素。 取出集合中的下一个元素 123Iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象,获取实现类的方式比较特殊Collection接口中有一个方法,叫iterator(),这个方法返回的就是迭代器的实现类对象 Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。 1234迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 3.使用Iterator接口中的方法next取出集合中的下一个元素 ​ 在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。 ​ Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而**Iterator主要用于迭代访问（即遍历）Collection中的元素**，因此Iterator对象也被称为迭代器。 获取迭代器的方法想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(&quot;串串星人&quot;); coll.add(&quot;吐槽星人&quot;); coll.add(&quot;汪星人&quot;); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理 当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，演示Iterator对象迭代元素的过程： ​ 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for(foreach)123456789101112增强for循环:底层使用的也是迭代器,使用for循环的格式,简化了迭代器的书写是JDK1.5之后出现的新特性Collection &lt;E&gt; extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强forpublic interface Iterable&lt;T&gt; 实现这个接口允许对象成为 &quot;foreach&quot; 语句的目标。增强for循环:用来遍历集合和数组格式: for(集合/数组的数据类型 变量名: 集合名/数组名)&#123; sout(变量名); &#125; 增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1: 遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2: 遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(&quot;小河神&quot;); coll.add(&quot;老河神&quot;); coll.add(&quot;神婆&quot;); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 3. 泛型3.1 泛型概述 创建集合对象,使用泛型 好处: 1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型 2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) 弊端: 泛型是什么类型,只能存储什么类型的数据 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 创建集合对象，不使用泛型 好处： ​ 集合不使用泛型，默认是Object类型，可以存储任意类型的数据 弊端： ​ 不安全，会引发异常 大家观察下面代码： 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add(&quot;abc&quot;); coll.add(&quot;itcast&quot;); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 为什么会发生类型转换异常呢？ ​ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ ​ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;abc&quot;); list.add(&quot;itcast&quot;); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips: 泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(&quot;大胡子登登&quot;); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(&quot;aaa&quot;); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口12345678含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型public interface Iterator&lt;E&gt; &#123; E next();&#125;Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重写的next方法泛型默认就是Stringpublic final class Scanner implements Iterator&lt;String&gt;&#123; public String next() &#123;&#125;&#125; 定义格式： 1修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(&quot;aa&quot;); &#125;&#125; 3.4 泛型通配符泛型的通配符: ?:代表任意的数据类型 使用方式: 不能创建对象使用 只能作为方法的参数使用 当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。 一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的。 通配符高级使用—-受限泛型泛型的上限限定: ? extends E 代表使用的泛型只能是E类型的子类/本身 泛型的下限限定: ? super E 代表使用的泛型只能是E类型的父类/本身 之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;","categories":[{"name":"集合","slug":"集合","permalink":"https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Collection集合","slug":"Collection集合","permalink":"https://mrchen229.github.io/tags/Collection%E9%9B%86%E5%90%88/"},{"name":"Iterator迭代器","slug":"Iterator迭代器","permalink":"https://mrchen229.github.io/tags/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"增强for","slug":"增强for","permalink":"https://mrchen229.github.io/tags/%E5%A2%9E%E5%BC%BAfor/"},{"name":"泛型类_方法_接口","slug":"泛型类-方法-接口","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%96%B9%E6%B3%95-%E6%8E%A5%E5%8F%A3/"},{"name":"泛型通配符","slug":"泛型通配符","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"}]},{"title":"Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_包装类与拆装箱_基本类型与String转换","slug":"03.常用API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_包装类与拆装箱_基本类型与String转换","date":"2020-08-28T05:20:08.000Z","updated":"2020-08-28T07:15:36.446Z","comments":true,"path":"2020/08/28/03.常用API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_包装类与拆装箱_基本类型与String转换/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/03.%E5%B8%B8%E7%94%A8API/Object_Objects_Date_DateFormat_Calendar_System_StringBuilder_%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E6%8B%86%E8%A3%85%E7%AE%B1_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"知识点 Object类 Object类的toString方法 Object类的equals方法 Objects类 Date类 DateFormat类(Date与String之间的转换) Calendar类（方便获取各个时间属性） System类 currentTimeMillis方法 arraycopy方法 StringBuilder类 包装类与自动拆装箱 基本类型与字符串之间的转换 1. Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它其中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类，那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。 tips: 直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较​ 如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较​ 如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： tips：Object类当中的hashCode等其他方法，今后学习。 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是 null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b): 判断两个对象是否相等。 源码： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 2. 日期时间类2.1 Date类概述 java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 getTime()方法（返回毫秒值）Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类（Date的转换）​ java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换, 也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法​ 由于DateFormat为抽象类，不能直接使用，所以需要**常用的子类java.text.SimpleDateFormat**。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; &#125; 常用方法format parseDateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); String str = &quot;2018年12月11日&quot;; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 Calendar类（方便获取各个时间属性）概念java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 创建方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2015年1月18日; &#125;&#125; getTime方法（返回Date对象）Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 3. System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 4. StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = &quot;Hello&quot;; s += &quot;World&quot;; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 ​ 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(&quot;itcast&quot;); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(&quot;hello&quot;); //对比一下 System.out.println(&quot;builder:&quot;+builder); System.out.println(&quot;builder2:&quot;+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(&quot;hello&quot;); builder.append(&quot;world&quot;); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100); System.out.println(&quot;builder:&quot;+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 5. 包装类5.1 概述 Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.3 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(&quot;100&quot;); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[{"name":"常用API","slug":"常用API","permalink":"https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"}],"tags":[{"name":"Object类(toString_equals)","slug":"Object类-toString-equals","permalink":"https://mrchen229.github.io/tags/Object%E7%B1%BB-toString-equals/"},{"name":"Objects类","slug":"Objects类","permalink":"https://mrchen229.github.io/tags/Objects%E7%B1%BB/"},{"name":"Date类","slug":"Date类","permalink":"https://mrchen229.github.io/tags/Date%E7%B1%BB/"},{"name":"DateFormat类(Date与String之间的转换)","slug":"DateFormat类-Date与String之间的转换","permalink":"https://mrchen229.github.io/tags/DateFormat%E7%B1%BB-Date%E4%B8%8EString%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"name":"Calendar类(方便获取各个时间属性)","slug":"Calendar类-方便获取各个时间属性","permalink":"https://mrchen229.github.io/tags/Calendar%E7%B1%BB-%E6%96%B9%E4%BE%BF%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"},{"name":"System类","slug":"System类","permalink":"https://mrchen229.github.io/tags/System%E7%B1%BB/"},{"name":"StringBuilder类","slug":"StringBuilder类","permalink":"https://mrchen229.github.io/tags/StringBuilder%E7%B1%BB/"},{"name":"包装类与自动拆装箱","slug":"包装类与自动拆装箱","permalink":"https://mrchen229.github.io/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"},{"name":"基本类型与字符串之间的转换","slug":"基本类型与字符串之间的转换","permalink":"https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"}]},{"title":"final_权限修饰符_成员内部类_匿名内部类_引用类型用法(class_interface)","slug":"04.继承与多态/final_权限修饰符_成员内部类_匿名内部类_引用类型用法(class_interface)","date":"2020-08-28T01:40:08.000Z","updated":"2020-08-28T01:40:55.505Z","comments":true,"path":"2020/08/28/04.继承与多态/final_权限修饰符_成员内部类_匿名内部类_引用类型用法(class_interface)/","link":"","permalink":"https://mrchen229.github.io/2020/08/28/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95(class_interface)/","excerpt":"","text":"知识点 final关键字 权限修饰符 成员内部类 匿名内部类 引用类型用法(class interface) 1. final关键字1.1 概述学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 final 关键字，用于修饰不可改变内容。 final： 不可改变。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 1.2 使用方式修饰类 12final class 类名 &#123;&#125; 查询API发现像 public final class String 、 public final class Math 、 public final class Scanner等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。 修饰方法123修饰符 final 返回值类型 方法名(参数列表)&#123; //方法体&#125; 重写被 final 修饰的方法，编译时就会报错。 修饰变量局部变量——基本类型基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。 123456789101112131415public class FinalDemo1 &#123; public static void main(String[] args) &#123; // 声明变量，使用final修饰 final int a; // 第一次赋值 a = 10; // 第二次赋值 a = 20; // 报错,不可重新赋值 // 声明变量，直接赋值，使用final修饰 final int b = 10; // 第二次赋值 b = 20; // 报错,不可重新赋值 &#125;&#125; 局部变量——引用类型引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下： 12345678910public class FinalDemo2 &#123; public static void main(String[] args) &#123; // 创建 User 对象 final User u = new User(); // 创建 另一个 User对象 u = new User(); // 报错，指向了新的对象，地址值改变。 // 调用setName方法 u.setName(&quot;张三&quot;); // 可以修改 &#125;&#125; 成员变量成员变量涉及到初始化的问题，初始化方式有两种，只能二选一： 显示初始化 1234public class User &#123; final String USERNAME = &quot;张三&quot;; private int age;&#125; 构造方法初始化 12345678public class User &#123; final String USERNAME ; private int age; public User(String username, int age) &#123; this.USERNAME = username; this.age = age; &#125;&#125; 被final修饰的常量名称，一般都有书写规范，所有字母都大写。 2. 权限修饰符public protected default private在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， public：公共的。 protected：受保护的 default：默认的 private：私有的 2.1 不同权限的访问能力 public protected default（空的） private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。 建议： 成员变量使用 private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用 public ，方便调用方法。 小贴士：不加权限修饰符，其访问能力与default修饰符相同 3. 内部类3.1 概述​ 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 3.2 成员内部类成员内部类 ：定义在类中方法外的类。 定义格式： 1234class 外部类 &#123; class 内部类&#123; &#125;&#125; 在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 创建内部类对象格式： 1外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； 示例： 1234567891011121314151617181920public class Person &#123; private boolean live = true; class Heart &#123; public void jump() &#123; // 直接访问外部类成员 if (live) &#123; System.out.println(&quot;心脏在跳动&quot;); &#125; else &#123; System.out.println(&quot;心脏不跳了&quot;); &#125; &#125; &#125; public boolean isLive() &#123; return live; &#125; public void setLive(boolean live) &#123; this.live = live; &#125;&#125; 123456789101112public static void main(String[] args) &#123; // 创建外部类对象 Person p = new Person(); // 创建内部类对象 Heart heart = p.new Heart(); // 调用内部类方法 heart.jump(); // 调用外部类方法 p.setLive(false); // 调用内部类方法 heart.jump();&#125; 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Person$Heart.class 3.3 匿名内部类【重点】匿名内部类 ：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。 前提​ 匿名内部类必须继承一个父类或者实现一个父接口。 格式1234567new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 使用方式以接口为例，匿名内部类的使用示例：定义接口： 123public abstract class FlyAble&#123; public abstract void fly();&#125; 创建匿名内部类，并调用： 123456789101112131415public class InnerDemo &#123; public static void main(String[] args) &#123; /* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 */ FlyAble f = new FlyAble()&#123; //相当于重写接口方法的子类，并且创建对象 public void fly() &#123; System.out.println(&quot;我飞了~~~&quot;); &#125; &#125;; //调用 fly方法,执行重写后的方法 f.fly(); &#125;&#125; 在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。 4. 引用类型用法总结​ 实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。 4.1 class作为成员变量 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。 4.2 interface作为成员变量 接口是对方法的封装接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。 4.3 interface作为方法参数和返回值类型​ 当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 ArrayList 类我们并不陌生，查看API我们发现，实际上，它是 java.util.List 接口的实现类。所以，当我们看见 List 接口作为参数或者返回值类型时，当然可以将 ArrayList 的对象进行传递或返回。 接口作为参数时，传递它的子类对象。接口作为返回值类型时，返回它的子类对象。","categories":[{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"}],"tags":[{"name":"final关键字","slug":"final关键字","permalink":"https://mrchen229.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"权限修饰符","slug":"权限修饰符","permalink":"https://mrchen229.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"成员内部类","slug":"成员内部类","permalink":"https://mrchen229.github.io/tags/%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"https://mrchen229.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"引用类型用法(class interface)","slug":"引用类型用法-class-interface","permalink":"https://mrchen229.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95-class-interface/"}]},{"title":"接口成员_接口多实现方法细节_多态前提与上下转型_instanceof","slug":"04.继承与多态/接口成员_接口多实现方法细节_多态前提与上下转型_instanceof","date":"2020-08-27T02:32:08.000Z","updated":"2020-08-27T02:32:52.496Z","comments":true,"path":"2020/08/27/04.继承与多态/接口成员_接口多实现方法细节_多态前提与上下转型_instanceof/","link":"","permalink":"https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98_%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82_%E5%A4%9A%E6%80%81%E5%89%8D%E6%8F%90%E4%B8%8E%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B_instanceof/","excerpt":"","text":"知识点 接口成员的定义 接口多实现的细节(多个方法的实现) 接口的限制 多态的前提 多态的向上向下转型 多态的转型异常(instanceof) 1. 接口1.1 概述​ 接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。​ 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 ​ 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 1.2 接口定义格式123456public interface 接口名称 &#123; // 抽象方法 // 默认方法 // 静态方法 // 私有方法&#125; 含有抽象方法 抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。 123public interface InterFaceName &#123; public abstract void method();&#125; 含有默认方法和静态方法 默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。 静态方法：使用 static 修饰，供接口直接调用。 12345678public interface InterFaceName &#123; public default void method() &#123; // 执行语句 &#125; public static void method2() &#123; // 执行语句 &#125;&#125; 含有私有方法和私有静态方法私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。 12345public interface InterFaceName &#123; private void method() &#123; // 执行语句 &#125;&#125; 1.3 基本的实现实现的概述​ 类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。 非抽象子类实现接口： 必须重写接口中所有抽象方法。 继承了接口的默认方法，即可以直接调用，也可以重写。 实现格式： 1234class 类名 implements 接口名 &#123; // 重写接口中抽象方法【必须】 // 重写接口中默认方法【可选】&#125; 抽象方法的使用 必须全部实现 默认方法的使用可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 1.继承默认方法 2.重写默认方法 静态方法的使用静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 私有方法的使用 私有方法：只有默认方法可以调用。 私有静态方法：默认方法和静态方法可以调用。 如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。 1.4 接口的多实现​ 之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。 1234class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123; // 重写接口中抽象方法【必须】 // 重写接口中默认方法【不重名时可选】&#125; [ ]： 表示可选操作。 抽象方法​ 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。 默认方法​ 接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。 静态方法​ 接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。 优先级的问题​ 当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。 1.5 接口的多继承​ 一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。 子接口重写默认方法时，default关键字可以保留。子类重写默认方法时，default关键字不可以保留。 1.6 接口其他成员特点（限制） 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 接口中，没有构造方法，不能创建对象。 接口中，没有静态代码块。 1.7 小结123456789101112131415161718192021222324在Java 9+版本中，接口的内容可以有：1. 成员变量其实是常量，格式： [public] [static] [final] 数据类型 常量名称 = 数据值; 注意： 常量必须进行赋值，而且一旦赋值不能改变。 常量名称完全大写，用下划线进行分隔。2. 接口中最重要的就是抽象方法，格式： [public] [abstract] 返回值类型 方法名称(参数列表); 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。3. 从Java 8开始，接口里允许定义默认方法，格式： [public] default 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 注意：默认方法也可以被覆盖重写4. 从Java 8开始，接口里允许定义静态方法，格式： [public] static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法5. 从Java 9开始，接口里允许定义私有方法，格式： 普通私有方法：private 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 静态私有方法：private static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125; 注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。 2. 多态2.1 概述多态是继封装、继承之后，面向对象的第三大特性。 多态： 是指同一行为，具有多个不同表现形式。 前提（★） 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 2.2 多态的体现多态体现的格式： 12父类类型 变量名 = new 子类对象；变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 2.3 多态的好处​ 实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。 2.4 引用类型转换 ​ 多态的转型分为向上转型与向下转型两种： 向上转型 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 使用格式： 12父类类型 变量名 = new 子类类型();如：Animal a = new Cat(); 向下转型 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 12子类类型 变量名 = (子类类型) 父类变量名;如: Cat c =(Cat) a; 为什么要转型​ 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 示例： 12345678910111213141516171819abstract class Animal &#123; abstract void eat();&#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse() &#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void watchHouse() &#123; System.out.println(&quot;看家&quot;); &#125;&#125; 12345678910public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125;&#125; 转型的异常12345678910public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 &#125;&#125; 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。 为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 12345变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。eg: a instanceof Cat","categories":[{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"}],"tags":[{"name":"接口成员的定义","slug":"接口成员的定义","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"name":"接口多实现方法细节","slug":"接口多实现方法细节","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82/"},{"name":"接口的限制","slug":"接口的限制","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%99%90%E5%88%B6/"},{"name":"多态的前提","slug":"多态的前提","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90/"},{"name":"多态的上下转型","slug":"多态的上下转型","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B/"},{"name":"instanceof","slug":"instanceof","permalink":"https://mrchen229.github.io/tags/instanceof/"}]},{"title":"继承_super_this_abstract","slug":"04.继承与多态/继承_super_this_abstract","date":"2020-08-27T01:34:08.000Z","updated":"2020-08-27T01:35:17.250Z","comments":true,"path":"2020/08/27/04.继承与多态/继承_super_this_abstract/","link":"","permalink":"https://mrchen229.github.io/2020/08/27/04.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E7%BB%A7%E6%89%BF_super_this_abstract/","excerpt":"","text":"知识点 三大特性之继承 super关键字 this关键字 abstract方法与abstract类 1. 继承1.1 概述​ 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。 ​ 其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。​ 继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 好处 提高代码的复用性。 类与类之间产生了关系，是多态的前提。 1.2 继承的格式​ 通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 123456class 父类 &#123; ...&#125; class 子类 extends 父类 &#123; ...&#125; 1.3 继承后的特点——成员变量​ 当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？ 成员变量不重名​ 如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。 成员变量重名​ 如果子类父类中出现重名的成员变量，这时的访问是有影响的。 123456789101112131415161718192021222324252627class Fu &#123; // Fu中的成员变量。 int num = 5;&#125; class Zi extends Fu &#123; // Zi中的成员变量 int num = 6; public void show() &#123; // 访问父类中的num System.out.println(&quot;Fu num=&quot; + num); // 访问子类中的num System.out.println(&quot;Zi num=&quot; + num); &#125;&#125; class ExtendsDemo03 &#123; public static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125;&#125; 演示结果： Fu num = 6 Zi num = 6 ​ 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this 。 1super.父类成员变量名 Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。 通常编码时，我们遵循封装的原则，使用private修饰成员变量，那如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。 1.4 继承后的特点——成员方法当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？ 成员方法不重名​ 如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 成员方法重名——重写(Override)​ 如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 123456789101112131415161718class Fu &#123; public void show() &#123; System.out.println(&quot;Fu show&quot;); &#125;&#125; class Zi extends Fu &#123; //子类重写了父类的show方法 public void show() &#123; System.out.println(&quot;Zi show&quot;); &#125;&#125; public class ExtendsDemo05&#123; public static void main(String[] args) &#123; Zi z = new Zi(); // 子类中有show方法，只执行重写后的show方法 z.show(); // Zi show &#125;&#125; 子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。 用到super.父类成员方法，表示调用父类的成员方法。 重写的注意事项 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 1.5 继承后的特点——构造方法当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？ 首先我们要回忆两个事情，构造方法的定义格式和作用。 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。 12345678910111213141516171819202122class Fu &#123; private int n; Fu()&#123; System.out.println(&quot;Fu()&quot;); &#125;&#125;class Zi extends Fu &#123; Zi()&#123; // super（），调用父类构造方法 super(); System.out.println(&quot;Zi（）&quot;); &#125;&#125; public class ExtendsDemo07&#123; public static void main (String args[])&#123; Zi zi = new Zi(); &#125;&#125; 输出结果： Fu（） Zi（） 1.6 super和this 父类空间优先于子类对象产生​ 在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。 ​ 代码体现在子类的构造方法调用时，一定先调用父类的构造方法。 super和this的含义 super ：代表父类的存储空间标识(可以理解为父亲的引用)。 this ：代表当前对象的引用(谁调用就代表谁)。 super和this的用法 访问成员 1234this.成员变量 ‐‐ 本类的super.成员变量 ‐‐ 父类的this.成员方法名() ‐‐ 本类的super.成员方法名() ‐‐ 父类的 访问构造方法 12this(...) ‐‐ 本类的构造方法super(...) ‐‐ 父类的构造方法 子类的每个构造方法中均有默认的super()**，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 1.7 继承的特点 Java只支持单继承，不支持多继承。 123//一个类只能有一个父类，不可以有多个父类。class C extends A&#123;&#125; //okclass C extends A，B... //error Java支持多层继承(继承体系)。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; 顶层父类是Object类。所有的类默认继承Object，作为父类。 子类和父类是一种相对的概念。 2. 抽象类2.1 概述​ 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 定义 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 2.2 abstract使用格式抽象方法​ 使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。 1修饰符 abstract 返回值类型 方法名 (参数列表)； 抽象类​ 如果一个类包含抽象方法，那么该类必须是抽象类。 12abstract class 类名字 &#123;&#125; 抽象的使用​ 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。 2.3 注意事项关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。","categories":[{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"}],"tags":[{"name":"三大特性之继承","slug":"三大特性之继承","permalink":"https://mrchen229.github.io/tags/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"},{"name":"super关键字","slug":"super关键字","permalink":"https://mrchen229.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"this关键字","slug":"this关键字","permalink":"https://mrchen229.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"abstract方法与abstract类","slug":"abstract方法与abstract类","permalink":"https://mrchen229.github.io/tags/abstract%E6%96%B9%E6%B3%95%E4%B8%8Eabstract%E7%B1%BB/"}]},{"title":"Scanner_Random_ArrayList_String常见方法_Arrays_Math_static关键字","slug":"03.常用API/Scanner_Random_ArrayList_String常见方法_Arrays_Math_static关键字","date":"2020-08-26T14:58:08.000Z","updated":"2020-08-26T14:59:55.308Z","comments":true,"path":"2020/08/26/03.常用API/Scanner_Random_ArrayList_String常见方法_Arrays_Math_static关键字/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/03.%E5%B8%B8%E7%94%A8API/Scanner_Random_ArrayList_String%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95_Arrays_Math_static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"知识点 Scanner类 Random类 ArrayList类 String类的常用方法 Arrays类的方法 Math类 static关键字（static变量、static方法、static代码块） 1. API​ API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。 1.1 API使用步骤 打开帮助文档。 点击显示，找到索引，看到输入框。 在输入框里输入内容，然后回车。 看包。java.lang下的类不需要导包，其他需要。 看类的解释和说明。 学习构造方法 使用成员方法 2. Scanner类2.1 什么是Scanner类​ 一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 System.in 中读取一个数： 12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); 备注：System.in 系统输入指的是通过键盘录入数据。 2.2 引用类型使用步骤导包​ 使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 12import 包名.类名;eg: import java.util.Scanner 创建对象​ 使用该类的构造方法，创建一个该类的对象。 1数据类型 变量名 = new 数据类型(参数列表); 调用方法​ 调用该类的成员方法，完成指定功能。 1变量名.方法名(); 2.3 Scanner使用步骤查看类 java.util.Scanner ：该类需要import导入后使用。 查看构造方法 public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 查看成员方法 public int nextInt() ：将输入信息的下一个标记扫描为一个 int 值。 使用Scanner类，完成接收键盘录入数据的操作，代码如下： 12345678910111213//1. 导包import java.util.Scanner;public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println(&quot;请录入一个整数：&quot;); int i = sc.nextInt(); //4. 输出数据 System.out.println(&quot;i:&quot;+i); &#125;&#125; 2.4 匿名对象​ 创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。 匿名对象 ：没有变量名的对象。 格式: 1new 类名(参数列表)； 应用场景 创建匿名对象直接调用方法，没有变量名。 1new Scanner(System.in).nextInt(); 一旦调用两次方法，就是创建了两个对象，造成浪费 匿名对象可以作为方法的参数和返回值 作为参数 123456789101112class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125;&#125; 作为返回值 12345678910111213class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125; 3. Random类3.1 什么是Random类此类的实例用于生成伪随机数。例如，以下代码使用户能够得到一个随机数： 12Random r = new Random();int i = r.nextInt(); 3.2 Random使用步骤 查看类java.util.Random ：该类需要 import导入使后使用。 查看构造方法public Random() ：创建一个新的随机数生成器。 查看成员方法public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的int 值。 使用Random类，完成生成3个10以内的随机整数的操作，代码如下： 1234567891011121314//1. 导包import java.util.Random;public class Demo01_Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 int number = r.nextInt(10); //4. 输出数据 System.out.println(&quot;number:&quot;+ number); &#125; &#125;&#125; 创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。 获取随机数获取1-n之间的随机数，包含n，代码如下： 12345678910111213// 导包import java.util.Random;public class Test01Random &#123; public static void main(String[] args) &#123; int n = 50; // 创建对象 Random r = new Random(); // 获取随机数 int number = r.nextInt(n) + 1; // 输出随机数 System.out.println(&quot;number:&quot; + number); &#125;&#125; 4. ArrayList类 想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需求。 为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据 4.1 什么是ArrayList类java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。 4.2 ArrayList使用步骤 查看类 java.util.ArrayList &lt;E&gt; ：该类需要 import导入使后使用。 &lt;E&gt; ，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下： 1ArrayList&lt;String&gt;，ArrayList&lt;Student&gt; 查看构造方法 public ArrayList() ：构造一个内容为空的集合。基本格式: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： 1ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 查看成员方法public boolean add(E e) ： 将指定的元素添加到此集合的尾部。参数 E e ，在构造ArrayList对象时， &lt;E&gt; 指定了什么数据类型，那么 add(E e) 方法中，只能添加什么数据类型的对象。 使用ArrayList类，存储三个字符串元素，代码如下： 12345678910111213141516171819public class Test02StudentArrayList &#123; public static void main(String[] args) &#123; //创建学生数组 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //创建学生对象 String s1 = &quot;曹操&quot;; String s2 = &quot;刘备&quot;; String s3 = &quot;孙权&quot;; //打印学生ArrayList集合 System.out.println(list); //把学生对象作为元素添加到集合 list.add(s1); list.add(s2); list.add(s3); //打印学生ArrayList集合 System.out.println(list); &#125;&#125; 4.3 常用方法和遍历对于元素的操作,基本体现在——增、删、查。常用的方法有： public boolean add(E e) ：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 这些都是最基本的方法，操作非常简单，代码如下: 1234567891011121314151617181920212223242526public class Demo01ArrayListMethod &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //public E get(int index):返回指定索引处的元素 System.out.println(&quot;get:&quot;+list.get(0)); System.out.println(&quot;get:&quot;+list.get(1)); System.out.println(&quot;get:&quot;+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(&quot;size:&quot;+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(&quot;remove:&quot;+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++)&#123; System.out.println(list.get(i)); &#125; &#125;&#125; 4.4 如何存储基本数据类型​ ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 &lt;int&gt; 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下： 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5. String类5.1 String类概述java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。 类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。 5.2 特点 字符串不变：字符串的值在创建后不能被更改。 1234String s1 = &quot;abc&quot;;s1 += &quot;d&quot;;System.out.println(s1); // &quot;abcd&quot;// 内存中有&quot;abc&quot;，&quot;abcd&quot;两个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。 因为String对象是不可变的，所以它们可以被共享。 123String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。 &quot;abc&quot; 等效于 char[] data=&#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125; 。 123456例如：String str = &quot;abc&quot;;相当于：char data[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;String str = new String(data);// String底层是靠字符数组实现的。 字符串的常量池 5.3 使用步骤 查看类 java.lang.String ：此类不需要导入。 查看构造方法 public String() ：初始化新创建的 String对象，以使其表示空字符序列。 public String(char[] value) ：通过当前参数中的字符数组来构造新的String。 public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。 构造举例，代码如下： 12345678// 无参构造String str = new String（）；// 通过字符数组构造char chars[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;;String str3 = new String(bytes); 5.4 常用方法判断功能的方法 public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。 public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写。方法演示，代码如下： 12345678910111213141516public class String_Demo01 &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; String s3 = &quot;HELLO&quot;; // boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s1.equals(s2)); // true System.out.println(s1.equals(s3)); // false System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); //boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); // true System.out.println(s1.equalsIgnoreCase(s3)); // true System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); &#125;&#125; Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。 获取功能的方法 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。 方法演示，代码如下 12345678910111213141516171819202122232425262728293031323334public class String_Demo02 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;helloworld&quot;; // int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length()); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String concat (String str):将将指定的字符串连接到该字符串的末尾. String s = &quot;helloworld&quot;; String s2 = s.concat(&quot;**hello itheima&quot;); System.out.println(s2);// helloworld**hello itheima // char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1 System.out.println(s.indexOf(&quot;l&quot;)); System.out.println(s.indexOf(&quot;owo&quot;)); System.out.println(s.indexOf(&quot;ak&quot;)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String substring(int start):从start开始截取字符串到字符串结尾 System.out.println(s.substring(0)); System.out.println(s.substring(5)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String substring(int start,int end):从start到end截取字符串。含start，不含end。 System.out.println(s.substring(0, s.length())); System.out.println(s.substring(3,8)); &#125;&#125; 转换功能的方法 public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 方法演示，代码如下： 1234567891011121314151617181920212223public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;abcde&quot;; // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); for(int x = 0; x &lt; chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); // byte[] getBytes ():把字符串转换为字节数组 byte[] bytes = s.getBytes(); for(int x = 0; x &lt; bytes.length; x++) &#123; System.out.println(bytes[x]); &#125; System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); // 替换字母it为大写IT String str = &quot;itcast itheima&quot;; String replace = str.replace(&quot;it&quot;, &quot;IT&quot;); System.out.println(replace); // ITcast ITheima System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); &#125;&#125; CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中 分割功能的方法 public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 方法演示，代码如下： 12345678910public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;aa|bb|cc&quot;; String[] strArray = s.split(&quot;|&quot;); // [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;] for(int x = 0; x &lt; strArray.length; x++) &#123; System.out.println(strArray[x]); // aa bb cc &#125; &#125;&#125; 6. Arrays类6.1 概述 java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 6.2 操作数组的方法 public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 12345678910public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;2,34,35,4,657,8,69,9&#125;; // 打印数组,输出地址值 System.out.println(arr); // [I@2ac1fdc4 // 数组内容转为字符串 String s = Arrays.toString(arr); // 打印字符串,输出内容 System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9]&#125; public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 12345678public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;24, 7, 5, 48, 4, 46, 35, 11, 6, 2&#125;; System.out.println(&quot;排序前:&quot;+ Arrays.toString(arr)); // 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6, 2] // 升序排序 Arrays.sort(arr); System.out.println(&quot;排序后:&quot;+ Arrays.toString(arr));// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]&#125; 7. Math类7.1 概述​ java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 7.2 基本运算的方法 public static double abs(double a) ：返回 double 值的绝对值。 12double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.abs(5); //d2的值为5 public static double ceil(double a) ：返回大于等于参数的最小的整数。 12double d1 = Math.ceil(3.3); //d1的值为 4.0double d2 = Math.ceil(‐3.3); //d2的值为 ‐3.0 public static double floor(double a) ：返回小于等于参数最大的整数。 12double d1 = Math.floor(3.3); //d1的值为3.0double d2 = Math.floor(‐3.3); //d2的值为‐4.0 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法) 12long d1 = Math.round(5.5); //d1的值为6.0long d2 = Math.round(5.4); //d2的值为5.0 8. static关键字8.1 概述​ 关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 8.2 定义和使用格式类变量​ 当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 类变量：使用 static关键字修饰的成员变量。 定义格式： 1static 数据类型 变量名； 静态方法​ 当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。 类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。 定义格式： 123修饰符 static 返回值类型 方法名 (参数列表)&#123; // 执行语句&#125; 静态方法调用的注意事项： 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this关键字。 小贴士：静态方法只能访问静态成员。 调用格式​ 被static修饰的成员可以并且建议通过类名直接访问。 ​ 虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。 格式： 1234// 访问类变量类名.类变量名；// 调用静态方法类名.静态方法名(参数)； 8.3 静态原理图解 static 修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。 8.4 静态代码块 静态代码块：定义在成员位置，使用static修饰的代码块{ }。 位置：类中方法外。 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。 格式： 12345public class ClassName&#123; static &#123; // 执行语句 &#125;&#125; 作用：给类变量进行初始化赋值。 static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。","categories":[{"name":"常用API","slug":"常用API","permalink":"https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"}],"tags":[{"name":"Scanner类","slug":"Scanner类","permalink":"https://mrchen229.github.io/tags/Scanner%E7%B1%BB/"},{"name":"Random类","slug":"Random类","permalink":"https://mrchen229.github.io/tags/Random%E7%B1%BB/"},{"name":"ArrayList类","slug":"ArrayList类","permalink":"https://mrchen229.github.io/tags/ArrayList%E7%B1%BB/"},{"name":"String类的常用方法","slug":"String类的常用方法","permalink":"https://mrchen229.github.io/tags/String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"Arrays类的方法","slug":"Arrays类的方法","permalink":"https://mrchen229.github.io/tags/Arrays%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"},{"name":"Math类","slug":"Math类","permalink":"https://mrchen229.github.io/tags/Math%E7%B1%BB/"},{"name":"static变量_static方法_static代码块","slug":"static变量-static方法-static代码块","permalink":"https://mrchen229.github.io/tags/static%E5%8F%98%E9%87%8F-static%E6%96%B9%E6%B3%95-static%E4%BB%A3%E7%A0%81%E5%9D%97/"}]},{"title":"类与对象_对象内存图_封装_this_构造_JavaBean","slug":"02.面向对象和封装/类与对象_对象内存图_封装_this_构造_JavaBean","date":"2020-08-26T07:52:08.000Z","updated":"2020-08-26T07:53:14.470Z","comments":true,"path":"2020/08/26/02.面向对象和封装/类与对象_对象内存图_封装_this_构造_JavaBean/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE_%E5%B0%81%E8%A3%85_this_%E6%9E%84%E9%80%A0_JavaBean/","excerpt":"","text":"知识点 面向对象 类与对象 对象内存图 封装 private、this关键字 构造方法 JavaBean 1. 面向对象1.1 面向对象思想概述​ Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 区别: 面向过程：强调步骤。 面向对象：强调对象。 面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特征，即封装、继承和多态。 1.2 类和对象 1.类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。 现实中，描述一类事物： 属性：就是该事物的状态信息。 行为：就是该事物能够做什么。 举例：小猫。 ​ 属性：名字、体重、年龄、颜色。 行为：走、跑、叫。 2.对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。 举例：一只小猫。 ​ 属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。 3.类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 1.3 类的定义 事物与类的对比 :现实世界的一类事物： 属性：事物的状态信息。 行为：事物能够做什么。 Java中用class描述事物也是如此： 成员变量：对应事物的属性 成员方法：对应事物的行为 类的定义格式1234public class ClassName &#123; //成员变量 //成员方法&#125; 定义类：就是定义类的成员，包括成员变量和成员方法。 成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法：和以前定义方法几乎是一样的。只不过把static去掉，static的作用在面向对象后面课程中再详细讲解。 1.4 对象的使用对象的使用格式创建对象： 1类名 对象名 = new 类名(); 使用对象访问类中的成员: 12对象名.成员变量；对象名.成员方法()； 成员变量的默认值 数据类型 默认值 基本类型 整数（byte，short，int，long） 0 浮点数（float，double） 0.0 字符（char） ‘\\u0000’ 布尔（boolean） false 引用类型 数组，类，接口 null 1.5 对象内存图一个对象，调用一个方法内存图 通过上图，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。 但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。 补充：图中的X是指方法调用完出栈。 两个对象，调用同一方法内存图 对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。 补充：图中的X是指方法调用完出栈。 两个引用指向同一对象的内存图 一个引用，作为参数传递到方法中内存图 引用类型作为参数，传递的是地址值。 使用对象类型作为方法的参数 使用对象类型作为方法的返回值 1.6 成员变量和局部变量区别​ 变量根据定义位置的不同，我们给变量起了不同的名字。如下图所示： 在类中的位置不同 重点 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 重点 成员变量：类中 局部变量：方法中 初始化值的不同 重点 成员变量：有默认值 局部变量：没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 2. 封装2.1 封装概述​ 面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 原则将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 2.2 封装的步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。 2.3 封装的操作——private关键字private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 private的使用格式1private 数据类型 变量名 ； 2.4 封装优化1——this关键字 我们发现 setXxx 方法中的形参名字并不符合见名知意的规定，那么如果修改与成员变量名一致，是否就见名知意了呢？ 12345678910public class Student &#123; private String name; private int age; public void setName(String name) &#123; name = name; &#125; public void setAge(int age) &#123; age = age; &#125;&#125; 经过修改和测试，我们发现新的问题，成员变量赋值失败了。也就是说，在修改了 setXxx() 的形参变量名后，方法并没有给成员变量赋值！这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。所以，我们只能使用this关键字，来解决这个重名问题。 this的含义​ this代表所在类的当前对象的引用（地址值），即对象自己的引用。 记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 this使用格式1this.成员变量名 方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。 2.5 封装优化2——构造方法​ 当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。 小贴士：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。 构造方法的定义格式123修饰符 构造方法名(参数列表)&#123; // 方法体&#125; 构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型。 注意事项 如果你不提供构造方法，系统会给出无参数构造方法。 如果你提供了构造方法，系统将不再提供无参数构造方法。 构造方法是可以重载的，既可以定义参数，也可以不定义参数。 2.6 标准代码——JavaBean​ JavaBean 是 Java语言编写类的一种标准规范。 ​ 符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 123456789public class ClassName&#123; //成员变量 //构造方法 //无参构造方法【必须】 //有参构造方法【建议】 //成员方法 //getXxx() //setXxx()&#125;","categories":[{"name":"面向对象和封装","slug":"面向对象和封装","permalink":"https://mrchen229.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/"}],"tags":[{"name":"类与对象","slug":"类与对象","permalink":"https://mrchen229.github.io/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"name":"对象内存图","slug":"对象内存图","permalink":"https://mrchen229.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"封装private","slug":"封装private","permalink":"https://mrchen229.github.io/tags/%E5%B0%81%E8%A3%85private/"},{"name":"this","slug":"this","permalink":"https://mrchen229.github.io/tags/this/"},{"name":"构造","slug":"构造","permalink":"https://mrchen229.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://mrchen229.github.io/tags/JavaBean/"}]},{"title":"一维数组定义_内存图_作为方法参数与返回值","slug":"01.Java基础语法/一维数组定义_内存图_作为方法参数与返回值","date":"2020-08-26T05:07:08.000Z","updated":"2020-08-26T05:13:02.611Z","comments":true,"path":"2020/08/26/01.Java基础语法/一维数组定义_内存图_作为方法参数与返回值/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89_%E5%86%85%E5%AD%98%E5%9B%BE_%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/","excerpt":"","text":"知识点 一维数组定义与索引 一维数组内存图 一维数组常见操作 数组作为方法参数与返回值 1. 数组定义和访问​ 数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 1.1 数组的定义方式一12数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];eg: int[] arr = new int[3]; 数组定义格式详解： 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [] : 表示数组。 数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 new：关键字，创建数组使用的关键字。 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [长度]：数组的长度，表示数组容器中可以存储多少个元素。 注意：数组有定长特性，长度一旦指定，不可更改。 和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。 方式二12数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;eg: int[] arr = new int[]&#123;1,2,3,4,5&#125;; 方式三12数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;eg: int[] arr = &#123;1,2,3,4,5&#125;; 1.2 数组的访问 索引： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 1数组名[索引] 数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度 语句为： 1数组名.length ，属性length的执行结果是数组的长度，int类型结果。由此可以推断出，数组的最大索引值为 数组名.length-1 。 索引访问数组中的元素： 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，取出数组中的元素 2. 数组原理内存图2.1 内存概述​ 内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。​ Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 2.2 Java虚拟机的内存划分​ 为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 JVM的内存划分： 区域名称 作用 寄存器 给CPU使用，和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组，new来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如main方法运行，进入方法栈中执行 2.3 数组在内存中的存储一个数组内存图1234public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr);//[I@5f150435&#125; ​ 以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。​ 输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素 两个数组内存图123456public static void main(String[] args) &#123; int[] arr = new int[3]; int[] arr2 = new int[2]; System.out.println(arr); System.out.println(arr2);&#125; 两个引用指向一个数组12345678910111213141516public static void main(String[] args) &#123; // 定义数组，存储3个元素 int[] arr = new int[3]; //数组索引进行赋值 arr[0] = 5; arr[1] = 6; arr[2] = 7; //输出3个索引上的元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); //定义数组变量arr2，将arr的地址赋值给arr2 int[] arr2 = arr; arr2[1] = 9; System.out.println(arr[1]);&#125; 3. 数组的常见操作3.1 数组越界异常1234public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arr[3]);&#125; ​ 创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 3.2 数组空指针异常12345public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; arr = null; System.out.println(arr[0]);｝ ​ arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 空指针异常在内存图中的表现 3.3 数组长度运行期间不可改变 3.4 数组遍历数组遍历： 就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。 1234int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 3.5 数组获取最大值元素 最大值获取：从数组的所有元素中找出最大值。 123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++) &#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println(&quot;数组最大值是： &quot; + max);&#125; 3.6 数组反转 数组的反转： 数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 123456789101112131415161718public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 4. 数组作为方法参数和返回值4.1 数组作为方法参数 **数组作为方法参数传递，传递的参数是数组内存的地址。 ** 1234567891011121314public static void main(String[] args) &#123; int[] arr = &#123; 1, 3, 5, 7, 9 &#125;; //调用方法，传递数组 printArray(arr); &#125; /* 创建方法，方法接收数组类型的参数 进行数组的遍历 */ public static void printArray(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 4.2 数组作为方法返回值 数组作为方法的返回值，返回的是数组的内存地址 1234567891011121314151617public static void main(String[] args) &#123; //调用方法，接收数组的返回值 //接收到的是数组的内存地址 int[] arr = getArray(); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; /* 创建方法，返回值是数组类型 return返回数组的地址*/public static int[] getArray() &#123; int[] arr = &#123; 1, 3, 5, 7, 9 &#125;; //返回数组的地址，返回到调用者 return arr;&#125; 补充 方法的参数为基本类型时,传递的是数据值。 方法的参数为引用类型时,传递的是地址值.","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"一维数组定义与索引","slug":"一维数组定义与索引","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%B4%A2%E5%BC%95/"},{"name":"一维数组内存图","slug":"一维数组内存图","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"数组作为方法参数与返回值","slug":"数组作为方法参数与返回值","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/"},{"name":"数组常见操作","slug":"数组常见操作","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"}]},{"title":"IDEA使用_方法重载与执行","slug":"01.Java基础语法/IDEA_方法重载与执行","date":"2020-08-26T02:50:08.000Z","updated":"2020-08-26T02:51:49.755Z","comments":true,"path":"2020/08/26/01.Java基础语法/IDEA_方法重载与执行/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/IDEA_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/","excerpt":"","text":"知识点 IDEA使用 定义方法与方法重载 1. IDEA 回顾一下开发Java程序的步骤： 编写代码 启动cmd 调用javac编译 调用java运行 集成开发环境，是一种专门用来提高Java开发效率的软件。 ​ 免费的IDE当中：Eclipse​ 收费的IDE当中：IntelliJ IDEA免费+收费所有的IDE当中：全世界用得最多的就是IntelliJ IDEA IDEA是一个专门针对Java的集成开发工具(IDE)，由Java语言编写。所以，需要有JRE运行环境并配置好环境变量。它可以极大地提升我们的开发效率。可以自动编译，检查错误。 File-&gt;new-&gt;Project 创建Project选择java，并选择jdk的位置。 首次新建项目时，默认的Project Location路径有问题，如 c:\\\\xxx ，正确写法为 c:\\xxx 。更改后不会再出现此类问题。 1.1 创建包和类展开创建的工程，在源代码目录 src 上，鼠标右键，选择 new-&gt;package ，键入包名。 所谓包，就是文件夹，用来对类文件进行管理。 在创建好的包上，鼠标右键，选择 new-&gt;class 创建类，键入类名。 1.2 字体设置File-&gt;Settings-&gt;Editor-&gt;Font 修改字体 1.3 IDEA的项目目录 我们创建的项目，在project目录的文件夹下 .idea 目录和 demo.iml 和我们开发无关，是IDEA工具自己使用的 out 目录是存储编译后的.class文件 src 目录是存储我们编写的.java源文件 1.4 IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标位置下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+i 自动生成代码，toString，get，set等方法 Alt+Shift+上下箭头 移动当前代码行 1.5 IDEA修改快捷键​ 在IDEA工具中， Ctrl+空格 的快捷键，可以帮助我们补全代码，但是这个快捷键和Windows中的输入法切换快捷键冲突，需要修改IDEA中的快捷键。1.File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic 2.双击 Basic-&gt;选择remove Ctrl+空格 3.再次双击 Basic-&gt;Add Keyboard-&gt;键入 Alt+/-&gt;点击OK 1.6 IDEA导入和关闭项目​ 关闭IDEA中已经存在的项目， File-&gt;Close Project File-&gt;Close Project 这时IDEA回到了刚启动界面，点击项目上的 X ，IDEA中就没有这个项目了 若要打开，在IDEA的启动界面上，点击 OPEN ，选择项目目录即可 2. 方法2.1 定义方法的格式1234修饰符 返回值类型 方法名(参数列表)&#123; //代码省略... return 结果;&#125; 修饰符： public static 固定写法 返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者 参数列表：方法在运算过程中的未知数据，调用者调用方法时传递 return：将方法执行后的结果带给调用者，方法执行到 return ，整体方法运行结束 return 结果; 正确的叫法为方法的返回值 2.2 定义方法的两个明确 需求：定义方法实现两个整数的求和计算。 明确返回值类型：方法计算的是整数的求和，结果也必然是个整数，返回值类型定义为int类型。 明确参数列表：计算哪两个整数的和，并不清楚，但可以确定是整数，参数列表可以定义两个int类型的变量，由调用者调用方法时传递 1234567891011121314151617public class Method_Demo2 &#123; public static void main(String[] args) &#123; // 调用方法getSum，传递两个整数，这里传递的实际数据又称为实际参数 // 并接收方法计算后的结果，返回值 int sum = getSum(5, 6); System.out.println(sum); &#125; /* 定义 计算两个整数和的方法 返回值类型，计算结果是int 参数：不确定数据求和，定义int参数.参数又称为形式参数 */ public static int getSum(int a, int b) &#123; return a + b; &#125;&#125; 程序执行，主方法 main 调用 getSum 方法，传递了实际数据 5和6 ，两个变量 a和b 接收到的就是实际参数，并将计算后的结果返回，主方法 main 中的变量 sum 接收的就是方法的返回值。 2.3 定义方法的注意事项 定义位置，类中方法外面。返回值类型，必须要和 return 语句返回的类型相同，否则编译失败 。 不能在 return 后面写代码， return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。 不能用输出语句调用 void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。 123456// 返回值类型要求是intpublic static int getSum() &#123; return 5;// 正确，int类型 return 1.2;// 错误，类型不匹配 return true;// 错误，类型不匹配&#125; 2.4 方法重载 方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 参数列表：个数不同，数据类型不同，顺序不同。 重载方法调用：JVM通过方法的参数列表，调用不同的方法。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"IDEA使用","slug":"IDEA使用","permalink":"https://mrchen229.github.io/tags/IDEA%E4%BD%BF%E7%94%A8/"},{"name":"方法重载与执行","slug":"方法重载与执行","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"}]},{"title":"判断_选择_循环","slug":"01.Java基础语法/判断_选择_循环","date":"2020-08-26T01:56:08.000Z","updated":"2020-08-26T01:56:54.151Z","comments":true,"path":"2020/08/26/01.Java基础语法/判断_选择_循环/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%88%A4%E6%96%AD_%E9%80%89%E6%8B%A9_%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"知识点 判断语句 选择语句 循环语句 1. 判断语句1.1 if123if(关系表达式)｛ 语句体;｝ 1.2 if…else12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; 1.3 if..else if…else1234567891011if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125; ...&#125;else if (判断条件n) &#123; 执行语句n;&#125; else &#123; 执行语句n+1;&#125; 2. 选择语句2.1 switch123456789101112switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 注意： switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。 2.2 case的穿透性​ 在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会再判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 3. 循环语句3.1 for123for(初始化表达式①; 布尔表达式②; 步进表达式④)&#123; 循环体③&#125; 执行流程 执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。 ①负责完成循环变量初始化 ②负责判断是否满足循环条件，不满足则跳出循环 ③具体执行的语句 ④循环后，循环条件所涉及变量的变化情况 3.2 while12345初始化表达式①while(布尔表达式②)&#123; 循环体③ 步进表达式④&#125; 执行流程 执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。 ①负责完成循环变量初始化。 ②负责判断是否满足循环条件，不满足则跳出循环。 ③具体执行的语句。 ④循环后，循环变量的变化情况。 3.3 do…while12345初始化表达式①do&#123; 循环体③ 步进表达式④&#125;while(布尔表达式②); 执行流程 执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。①负责完成循环变量初始化。②负责判断是否满足循环条件，不满足则跳出循环。③具体执行的语句④循环后，循环变量的变化情况 do…while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。 3.4 for 和 while 的小区别 for所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 3.5 跳出语句break 使用场景：终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景：结束本次循环，继续下一次的循环 4. 扩展知识点死循环​ 死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。例如：while(true){}。 嵌套循环12345for(初始化表达式①; 循环条件②; 步进表达式⑦) &#123; for(初始化表达式③; 循环条件④; 步进表达式⑥) &#123; 执行语句⑤; &#125;&#125; 嵌套循环执行流程： 执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥外循环一次，内循环多次。比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"判断语句","slug":"判断语句","permalink":"https://mrchen229.github.io/tags/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"},{"name":"选择语句","slug":"选择语句","permalink":"https://mrchen229.github.io/tags/%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"},{"name":"循环语句","slug":"循环语句","permalink":"https://mrchen229.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"}]},{"title":"数据类型转换_运算符_方法定义","slug":"01.Java基础语法/数据类型转换_运算符_方法定义","date":"2020-08-26T01:17:08.000Z","updated":"2020-08-26T01:17:27.340Z","comments":true,"path":"2020/08/26/01.Java基础语法/数据类型转换_运算符_方法定义/","link":"","permalink":"https://mrchen229.github.io/2020/08/26/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2_%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/","excerpt":"","text":"知识点 数据类型间的自动转换与强制转换 算数、比较、逻辑、三元运算符( 注意+= ) 方法定义 1.数据类型之间的转换​ Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。 1.1 自动转换一个 int 类型变量和一个 byte 类型变量进行加法运算， 结果是什么数据类型？ 运算结果，变量的类型将是 int 类型，这就是出现了数据类型的自动类型转换现象。 自动转换：将取值范围小的类型自动提升为取值范围大的类型 。 12345int i = 1;byte b = 2; // 一个byte是8位，范围-128-127// byte x = b + i; // 报错// int类型和byte类型运算，结果是int类型int j = b + i; 转换原理图解​ byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。 同样道理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。 12345int i = 1;double d = 2.5;//int类型和double类型运算，结果是double类型//int类型会提升为double类型double e = d+i; 转换规则​ 范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 1.2 强制转换​ 将 1.5 赋值到 int 类型变量会发生什么？产生编译失败，肯定无法赋值。 1int i = 1.5; // 错误 ​ double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。可以理解为 double 是8升的水壶， int 是4升的水壶，不能把大水壶中的水直接放进小水壶去。 ​ 想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。 强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。 比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。 ​ 转换格式： 数据类型 变量名 = （数据类型）被转数据值; ​ 将 1.5 赋值到 int 类型，代码修改为： 12// double类型数据强制转成int类型，直接去掉小数点。int i = (int)1.5; ​ 同样道理，当一个 short 类型与 1 相加，若想将结果赋值给short类型变量，就需要强制转换。 1234567891011//short类型变量，内存中2个字节short s = 1;/* 出现编译失败 s和1做运算的时候，1是int类型，s会被提升为int类型 s+1后的结果是int类型，将结果在赋值会short类型时发生错误 short内存2个字节，int类型4个字节 必须将int强制转成short才能完成赋值*/s = s + 1；//编译失败s = (short)(s+1);//编译成功 转换原理图解 注意点 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失 1234// 定义s为short范围内最大值short s = 32767;// 运算后，强制转换，砍掉2个字节后会出现不确定的结果s = (short)(s + 10); 1.3 ASCII编码表1234567public static void main(String[] args) &#123; //字符类型变量 char c = &#x27;a&#x27;; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98&#125; 在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。 编码表 ：就是将人类的文字和一个十进制数进行对应起来组成一张表格。 见ASCII表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 在char类型和int类型计算的过程中，char类型的字符先查询编码表，得到97，再和1求和，结果为98。char类型提升为int类型。char类型内存2个字节，int类型内存4个字节。 2. 运算符2.1 算数运算符 算数运算符包括： + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++ 、 – 自增自减运算 Java中，整数使用以上运算符，无论怎么计算，也不会得到小数。 12int i = 1234;System.out.println(i/1000*1000);//计算结果是1000 ++ 运算，变量自己增长1。反之， -- 运算，变量自己减少1，用法与 ++ 一致。 独立运算： 变量在独立运算时， 前++ 和 后++ 没有区别 。 混合运算： 和其他变量放在一起， 前++ 和 后++ 就产生了不同。 变量++ ： 即 a=1; b=a++; 得到a为 2，b为1。 ++变量 : 即 a=1; b=++a; 得到a为 2，b为2。 + 符号在字符串中的操作： 123+ 符号在遇到字符串的时候，表示连接、拼接的含义。 &quot;a&quot;+&quot;b&quot;的结果是“ab”，连接含义 System.out.println(&quot;5+5=&quot;+5+5);//输出5+5=55 2.2 赋值运算符 赋值运算符包括： = 等于号 += 加等于 -= 减等于 *= 乘等于 /= 除等于 %= 取模等 12eg : i+=5;//计算方式 i=i+5 变量i先加5，再赋值变量i 2.3 比较运算符 比较运算符包括： == 比较符号两边数据是否相等，相等结果是true。 &lt; 比较符号左边的数据是否小于右边的数据，如果小于结果是true。 &gt; 比较符号左边的数据是否大于右边的数据，如果大于结果是true。 &lt;= 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。 &gt;= 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。 ！= 不等于符号 ，如果符号两边的数据不相等，结果是true。 比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。 2.4 逻辑运算符 逻辑运算符包括： &amp;&amp; 短路与 1. 两边都是true，结果是true2. 一边是false，结果是false 短路特点：符号左边是false，右边不再运算 || 短路或 1. 两边都是false，结果是false 2. 一边是true，结果是true 短路特点： 符号左边是true，右边不再运算 ！ 取反 1. ! true 结果是false 2. ! false结果是true 逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false 2.5 三元运算符 三元运算符格式： 1数据类型 变量名 = 布尔类型表达式？结果1：结果2 三元运算符计算方式：布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 3. 方法入门3.1 概述 方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 3.2 方法的定义定义格式： 1234修饰符 返回值类型 方法名 （参数列表）｛ 代码... return ;｝ 定义格式解释： 修饰符： 目前固定写法 public static 。 返回值类型： 目前固定写法 void ，其他返回值类型在后面的课程讲解。 方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。 参数列表： 目前无参数， 带有参数的方法在后面的课程讲解。 return：方法结束。因为返回值类型是void，方法大括号内的return可以不写。 3.3 注意事项 方法定义注意事项： 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 4. 扩展知识点+=符号 12345public static void main(String[] args)&#123; short s = 1; s+=1; System.out.println(s);&#125; ​ 分析： s += 1 逻辑上看作是 s = s + 1 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， s=s+1进行两次运算 ， += 是一个运算符，只运算一次，并带有强制转换的特点。 ​ 也就是说s += 1 就是 s = (short)(s + 1) ，因此程序没有问题编译通过，运行结果是2 常量和变量的运算12345678public static void main(String[] args)&#123; byte b1=1; byte b2=2; byte b3=1 + 2; byte b4=b1 + b2; System.out.println(b3); System.out.println(b4);&#125; 分析： b3 = 1 + 2 ， 1 和 2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 ，因此b3=1 + 2 是正确的。 ​ 反之， b4 = b2 + b3 ， b2 和 b3 是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b2+b3的结果是什么，因此会将结果以int类型进行处理，所以int类型不能赋值给byte类型，因此编译失败。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据类型转换","slug":"数据类型转换","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"运算符细节","slug":"运算符细节","permalink":"https://mrchen229.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%86%E8%8A%82/"},{"name":"方法定义","slug":"方法定义","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"}]},{"title":"进制_Java执行顺序_常量_数据类型","slug":"01.Java基础语法/进制-Java执行顺序-常量-数据类型","date":"2020-08-25T07:27:08.000Z","updated":"2020-08-26T01:14:41.281Z","comments":true,"path":"2020/08/25/01.Java基础语法/进制-Java执行顺序-常量-数据类型/","link":"","permalink":"https://mrchen229.github.io/2020/08/25/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6-Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%B8%B8%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"知识点 进制转换 JVM JRE JDK关系 Java程序执行过程 标识符的写法 常量 变量的定义 基本数据类型的分类 1. 计算机基础知识二进制​ 计算机中全部采用二进制数表示数据，它只包含0、1，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特）。 十进制数据转成二进制数据 ​ 使用除以2获取余数的方式 二进制数据转成十进制数据 ​ 使用8421编码的方式 二进制数系统中，每个0或1就是一个位，叫做bit（比特）。 字节123456789101112131415 字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性可以查看文件的字节大小。8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。位（bit）：一个数字0或者一个数字1，代表一位。 字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。 1 Byte &#x3D; 8 bit 1 KB &#x3D; 1024 Byte 1 MB &#x3D; 1024 KB 1 GB &#x3D; 1024 MB 1 TB &#x3D; 1024 GB 1 PB &#x3D; 1024 TB 1 EB &#x3D; 1024 PB 1 ZB &#x3D; 1024 EB 常用DOS命令 命令 操作符号 盘符切换命令 盘符名: 查看当前文件夹 dir 进入文件夹命令 cd 文件夹名 or cd 文件夹1\\文件夹2\\文件夹3 返回上一级 cd .. 退出到磁盘根目录 cd \\ 清屏 cls 退出 exit 2. JVM JRE JDK Java虚拟机——JVM​ JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。​ 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 ​ 如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。 JRE 和 JDK​ JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的核心类库 。​ JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 运行一个已有的Java程序，只需安装 JRE 即可。开发一个全新的Java程序，则必须安装 JDK 。 3. Java程序执行过程Java程序开发三步骤：编写、编译、运行 。 编写 新建文件，文件名修改为 xxx.java。 在文件中键入文本并保存： 12345public class xxx &#123; public static void main(String[] args) &#123; System.out.println(&quot;xxx&quot;); &#125;&#125; 文件名必须是 xxx ，保证文件名和类的名字是一致的，注意大小写。 ​ 此时需要将编写好的 Java源文件，编译成JVM可以看懂的字节码文件 。 编译在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。 ​ 命令：javac Java源文件名.java ​ 编译成功后，命令行没有任何提示。打开 Java源文件名对应的目录，发现产生了一个新的文件 xxx.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 Java源文件的编译工具 javac.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。 运行在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。 命令: java 类名字 ​ Java程序 .class文件 的运行工具 java.exe ，在JDK安装目录的bin目录下。由于配置了环境变量，可以再任意目录下使用。 补充编译和运行​ 编译：是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。​ 运行：是指将 class文件交给JVM去运行，此时JVM就会去执行我们编写的程序了。 关于main方法​ main方法：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 注释​ Java中有单行注释和多行注释 12单行注释以 &#x2F;&#x2F;开头 换行结束多行注释以 &#x2F;*开头 以*&#x2F;结束 标识符​ 标识符：是指在程序中自己定义的内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 命名规则： 硬性要求 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 标识符不能以数字开头。 标识符不能是关键字。 命名规范： 软性建议 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 变量名规范：全部小写。 4. 常量​ 常量：是指在Java程序中固定不变的数据。 分类 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’ ， ‘ ‘， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值（流程控制中讲解） true ， false 空常量 只有一个值（引用数据类型中讲解） null 5. 变量和数据类型变量概述​ 变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。 数据类型数据类型分类Java的数据类型分为两大类： 基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。 引用数据类型：包括 类 、 数组 、 接口、字符串、lambda 。 注意事项： 字符串不是基本类型，而是引用类型。 浮点型可能只是一个近似值，并非精确的值。 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。 浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。 基本数据类型​ 四类八种基本数据类型： 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int（默认） 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认） 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false Java中的默认类型：整数类型是 int 、浮点类型是 double 。 变量定义变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值 。 格式: 数据类型 变量名 = 数据值; ​ long类型：建议数据后加L表示。​ float类型：建议数据后加F表示 注意事项​ 变量名称：在同一个大括号范围内，变量的名字不可以相同。​ 变量赋值：定义的变量，不赋值不能使用。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"进制转换","slug":"进制转换","permalink":"https://mrchen229.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"name":"Java开发过程","slug":"Java开发过程","permalink":"https://mrchen229.github.io/tags/Java%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/"},{"name":"常量与数据类型","slug":"常量与数据类型","permalink":"https://mrchen229.github.io/tags/%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"springboot和thymeleaf","slug":"leyou_springboot/springboot和thymeleaf","date":"2020-08-14T08:58:31.000Z","updated":"2020-08-14T09:31:19.362Z","comments":true,"path":"2020/08/14/leyou_springboot/springboot和thymeleaf/","link":"","permalink":"https://mrchen229.github.io/2020/08/14/leyou_springboot/springboot%E5%92%8Cthymeleaf/","excerpt":"","text":"总结 SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 牵涉到这些注解： 12345678910111.@RestController2.@EnableAutoConfiguration3.@ComponentScan4.@SpringBootApplication *5.@propertySource6.@SpringBootConfiguration7.@Configuration *8.@Bean *9.@Value10.ConfigurationProperties * 这个注解在这个笔记的属性注入中有解释11.EnableConfigurationProperties * 这个注解在这个笔记的属性注入中有解释 1. 了解SpringBoot1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 官网参考：https://docs.spring.io/spring-boot/docs/2.3.2.RELEASE/reference/htmlsingle/1 ​ https://spring.io/projects/spring-boot/#learn 官方介绍： Spring Boot helps you to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. 翻译： Spring Boot只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。我们为spring平台和第三方依赖库提供了一种固定化的使用方式，能非常轻松的开发应用程序并且只需要很少的配置。 Spring Boot常称为搭建程序的脚手架。其主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，关注于业务而非配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.2.为什么要学习SpringBoot传统java项目构建的缺点： 复杂的配置 项目各种配置是开发时的损耗， 需要在思考 Spring 特性配置和解决业务问题之间进行思维切换。 混乱的依赖管理 项目的依赖管理需要知道这些库的哪个版本和其他库不会有冲突，也是一种损耗，添加依赖不是写应用程序代码。 而SpringBoot让这一切成为过去！ 1.3.SpringBoot的特点 Provide a radically faster and widely accessible getting-started experience for all Spring development. Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults. Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration). Absolutely no code generation and no requirement for XML configuration. 创建独立的spring应用程序 直接内嵌tomcat、jetty和undertow（不需要打包成war包部署） 提供了固定化的“starter”配置，以简化构建配置 尽可能的自动配置spring和第三方库 提供产品级的功能，如：安全、指标、运行状况监测和外部化配置等 绝对不会生成代码，并且不需要XML配置 总之，Spring Boot为所有 Spring 的开发者提供一个开箱即用的、非常快速的、广泛接受的体验。 2.快速入门环境要求： ​ spring5.x基本要求jdk8，不同版本要求不同，可以查看相应的reference doc. 2.1.创建工程​ 1.new project (Empty project) ​ 2.new module (maven) 填写坐标信息： 目录结构： 创建完成后的目录结构： 2.2.引入依赖​ 现在我们的项目与SpringBoot还没有什么关联。 ​ SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，以这个项目为父工程，可以不用操心依赖的版本问题了，需要什么依赖就直接引入坐标！ module的pom.xml: 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.springboot&lt;/groupId&gt; &lt;artifactId&gt;itcast-springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 所有的springboot的工程都以spring父工程为父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- 启动器：每个启动器背后都是一堆依赖。web启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.编写HelloController 代码： 12345678910111213@RestController@EnableAutoConfiguration //启动自动配置public class HelloController &#123; @GetMapping(&quot;show&quot;) public String test()&#123; return &quot;hello Spring Boot!&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloController.class, args); &#125;&#125; 2.4.启动测试 123456console信息中 Servlet dispatcherServlet mapped to [&#x2F;]，这是springMVC的入口： &#x2F; Tomcat started on port(s): 8080， 这是tomcat监听8080端口通过localhost:8080&#x2F;show 访问 页面打印出 hello Spring Boot! 2.5.涉及知识点1.pom.xml里引入了启动器的概念 2.在启动类使用@EnableAutoConfiguration注解。 3.在启动类使用@RestController注解。 2.5.1.启动器为了让SpringBoot帮助完成各种自动配置，必须引入SpringBoot提供的自动配置依赖，称为启动器。 ​ spring-boot-starter-parent工程将依赖关系声明为一个或者多个启动器，我们可以根据项目需求引入相应的启动器，如web项目需要引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，这里并没有指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 在Project的External Libraries中已经存在了大量依赖。 ​ 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.5.2.@EnableAutoConfiguration官网说明： Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. 简单翻译以下： 开启spring应用程序的自动配置，SpringBoot基于你所添加的依赖和你自己定义的bean，试图去猜测并配置你想要的配置。比如引入spring-boot-starter-web，这个启动器中添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了。 2.5.3@RestController注解一、在Spring中@RestController的作用等同于@Controller + @ResponseBody。 所以想要理解@RestController注解就要先了解@Controller和@ResponseBody注解。 2.5.3.1@Controller注解 在一个类上添加@Controller注解，表明了这个类是一个控制器类。但想要让这个类成为一个处理请求的处理器光有@Controller注解是不够的，他还需要进一步修炼才能成为一个处理器。 1.在spring容器中创建该类的实例。创建实例的方式有两种： 1&lt;bean class=&quot;test.controller.MyController&quot;/&gt; 上述这种方式是在spring容器中注入单个bean，当项目比较大，控制器类比较多时，用这种方式向Spring容器中注入bean非常的让人苦恼，索性有第二种方式。 1&lt;context:component-scan base-scan=&quot;test.controller&quot;/&gt; 这种方式会扫描指定包中的所有类，并生成相应的bean注入到spring容器中。使用这种方式当然能够极大提高我们的开发效率，但是有时候我们不想某一类型的类注入到spring容器中。 这个时候第二种方式也可以解决。 12&lt;context:component-scan base-package=&quot;test&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;&lt;/context:component-scan&gt; 上述代码表示扫描test包中除有@Service注解之外的类。 2.将@Controller注解的类注入Spring容器中，只是该类成为处理器的第一步，想要修炼大成，还需要在该类中添加注解 2.5.3.2@RequestMapping @RequestMapping注解是用来映射请求的，即指明处理器可以处理哪些URL请求，该注解既可以用在类上，也可以用在方法上。 当使用@RequestMapping标记控制器类时，方法的请求地址是相对类的请求地址而言的；当没有使用@RequestMapping标记类时，方法的请求地址是绝对路径。 @RequestMapping的地址可以是uri变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址。具体的使用方法不是本次的重点，有兴趣的可以看 [https://www.cnblogs.com/xiepeixing/p/4243288.html] 123456789 @Controller @RequestMapping(&quot;/user&quot;) public class UserController&#123; @RequestMapping(&quot;/users&quot;) public String users() &#123; return &quot;users&quot;; &#125; &#125; 此时请求users方法的url路径就是：…/user/users。 可以看到上面users方法的返回值是字符串类型的，这个就是处理器在处理完任务后将要跳转的页面。如果想要方法直接返回结果，而不是跳转页面，这就要用到@ResponseBody注解了。 2.5.3.3@ResponseBody注解 @ResponseBody表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。 格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。 如果要求方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。 2.5.4*@GetMapping*与@PostMapping@GetMapping用于处理请求方法的GET类型，*@ PostMapping用于处理请求方法的POST*类型等 如果我们想使用传统的*@RequestMapping*注释实现URL处理程序，那么它应该是这样的： @RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET) 新方法可以简化为： @GetMapping(&quot;/get/&#123;id&#125;&quot; 2.6.多个Controller多个Controller的情形如何处理？ 添加Hello2Controller： 1234567891011@RestController@RequestMapping(&quot;hello&quot;)@EnableAutoConfigurationpublic class Hello2Controller &#123; @GetMapping(&quot;show2&quot;) public String test()&#123; return &quot;hello Spring Boot2!&quot;; &#125;&#125; 重新启动，访问show2测试，失败。 ​ 难道要在每一个Controller中都添加一个main方法和@EnableAutoConfiguration注解，这样启动一个springboot程序也太麻烦了。也无法同时启动多个Controller，因为每个main方法都监听8080端口。所以，一个springboot程序应该只有一个springboot的main方法。 ​ 所以，springboot程序引入了一个全局的引导类。 2.5.1.添加引导类​ 通常情况下，我们在一个springboot工程中都会在基包下创建一个引导类，一些springboot的全局注解（@EnableAutoConfiguration注解）以及springboot程序的入口main方法都放在该类中。 ​ 在springboot的程序的基包下（引导类和Controller包在同级目录下），创建TestApplication.class： 内容如下： 12345678@EnableAutoConfiguration@ComponentScan //类似于&lt;context:component-scan base-package=&quot;&quot;&gt; 扫描该类所在的包以及它的子孙包public class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 并修改HelloController，去掉main方法及@EnableAutoConfiguration： 12345678@RestControllerpublic class HelloController &#123; @GetMapping(&quot;show&quot;) public String test()&#123; return &quot;hello Spring Boot!&quot;; &#125;&#125; 启动引导类，访问show测试仍然失败。 ​ 发现所有的Controller都不能访问，为什么？ 回想以前程序，我们在配置文件中添加了注解扫描，它能扫描指定包下的所有Controller，而现在并没有。怎么解决——**@ComponentScan注解** 2.5.2.@ComponentScanspring框架除了提供配置方式的注解扫描&lt;context:component-scan /&gt;，还提供了注解方式的注解扫描@ComponentScan。 在TestApplication.class中，使用@ComponentScan注解： 123456789@EnableAutoConfiguration@ComponentScan //类似于&lt;context:component-scan base-package=&quot;&quot;&gt; 扫描该类所在的包以及它的子孙包public class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 重新启动，访问show或者show2成功！(localhost:8080/show与localhost:8080/show2) 跟进该注解的源码查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。一般启动类会放在一个比较浅的包目录中。 2.5.3.@SpringBootApplication​ 我们现在的引导类中使用了@EnableAutoConfiguration和@ComponentScan注解，有点麻烦。springboot提供了一种简便的玩法：@SpringBootApplication注解 使用@SpringBootApplication改造TestApplication： 12345678@SpringBootApplication //使用组合注解public class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 点击进入，查看源码： 发现@SpringBootApplication其实是一个组合注解，这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration：开启自动配置 @ComponentScan：开启注解扫描 2.5.4.@SpringBootConfiguration@SpringBootConfiguration注解的源码： 我们继续点击查看源码： ​ 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 3.默认配置原理springboot的默认配置方式和我们之前玩的配置方式不太一样，没有任何的xml。那么如果自己要新增配置该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt; 现在该怎么做呢? 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解来达到和xml配置一样的效果，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @Value：属性注入 @PropertySource：指定外部属性文件。 我们接下来用java配置来尝试实现连接池配置 3.2.1.引入依赖首先在pom.xml中，引入Druid连接池依赖，即Druid启动器： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.drtrang&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot2-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 3.2.2.添加jdbc.properties1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 3.2.3.配置数据源创建JdbcConfiguration类： 1234567891011121314151617181920212223@Configuration // 声明一个类是一个java配置类，相当于一个xml配置文件@PropertySource(&quot;classpath:jdbc.properties&quot;) //读取资源文件public class JdbcConfiguration &#123; @Value(&quot;$&#123;jdbc.url&#125;&quot;) String url; @Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;) String driverClassName; @Value(&quot;$&#123;jdbc.username&#125;&quot;) String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) String password; @Bean //将方法的返回值注入到spring容器 public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明JdbcConfiguration是一个配置类。 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值。 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签 然后就可以在任意位置通过@Autowired注入DataSource了！ 补充@PropertySource作用： ​ 用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。属性：​ value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath: 示例： 1234@Configuration@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JdbcConfig&#123;&#125; 外部化配置springboot官网的解释 ： ​ Spring Boot使您可以外部化配置，以便可以在不同环境中使用相同的application代码。您可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。属性值 可以使用 @Value 注解直接注入beans中，也可以通过Spring的Environment抽象访问，也可以通过@ConfigurationProperties绑定到结构化对象。 ​ Spring Boot使用一个非常特殊的PropertySource顺序，该顺序旨在允许合理地覆盖值。按以下顺序考虑属性： devtools处于活动状态时 $HOME/.config/spring-boot目录中的Devtools全局设置属性。 测试上的@TestPropertySource注解。 测试中的properties属性。在@SpringBootTest和测试注解上可用，用于测试应用的特定部分。 命令行参数。 来自SPRING_APPLICATION_JSON的属性（嵌入在环境变量或系统属性中的嵌入式JSON）。 ServletConfig的初始化参数。 ServletContext的初始化参数。 来自 java:comp/env的JNDI属性。 Java系统属性（System.getProperties()）。 OS系统环境变量。 一个RandomValuePropertySource，仅具有random.*属性。 打包的jar之外的特定于配置文件的应用属性（application-{profile}.properties和YAML变体）。 打包在jar中的特定于配置文件的应用程序属性（application-{profile}.properties和YAML变体）。 打包的jar之外的应用属性（application.properties和YAML变体）。 打包在jar中的应用属性（application.properties和YAML变体）。 @Configuration类上的@PropertySource 注解。请注意，在刷新应用上下文之前，不会将此类属性源添加到环境中。现在配置某些属性（如logging.*和spring.main.*）为时已晚，这些属性在刷新开始之前就已读取。 默认属性（通过设置SpringApplication.setDefaultProperties指定）。 ​ To provide a concrete example, suppose you develop a @Component that uses a name property, as shown in the following example: 123456789@Componentpublic class MyBean &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; // ...&#125; 1虽然在@SpringBootApplication上使用@PropertySource似乎是在Environment中加载自定义资源的便捷方法，但我们不建议这样做。 在刷新应用上下文之前，不会将此类属性sources添加到Environment中。 现在配置某些属性（如logging.*和spring.main.*）为时已晚，这些属性在刷新开始之前就已读取。 3.2.4.测试我们在HelloController中测试： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping(&quot;show&quot;) public String test()&#123; return &quot;hello Spring Boot!&quot;; &#125;&#125; 在test方法中打一个断点，然后Debug运行并查看： 属性注入成功了！ 3.3.更强大的SpringBoot的属性注入四种方式1.@Autowired注入 2.构造方法注入 3.@Bean方法形参注入 4.直接在@Bean方法上使用@ConfigurationProperties(prefix=”jdbc”) ​ 在上面的案例中，我们实验了java配置方式。 不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 ​ 在SpringBoot中，提供了一种新的属性注入方式，支持**各种java基本数据类型及复杂类型的注入**。 1注意这里说的是属性注入，也就是dataSource类中的属性，url... 使用步骤： 1）新建JdbcProperties，用来进行属性注入： 代码： 12345678910@ConfigurationProperties(prefix = &quot;jdbc&quot;)public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 前提(@ConfigurationProperties) 1）在类上通过@ConfigurationProperties注解声明当前类为属性读取类 2）prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 3）在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致，并且必须具有getter和setter方法 4）需要注意的是，这里我们并没有指定属性文件的地址，SpringBoot默认会读取文件名为application.properties的资源文件，所以我们把jdbc.properties名称改为application.properties 2）在JdbcConfiguration中使用这个属性： ​ 1）通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 ​ 2）然后你可以通过以下方式在JdbcConfiguration类中注入JdbcProperties： @Autowired注入123456789101112131415161718@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; @Autowired private JdbcProperties jdbcProperties; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbcProperties.getUrl()); dataSource.setDriverClassName(jdbcProperties.getDriverClassName()); dataSource.setUsername(jdbcProperties.getUsername()); dataSource.setPassword(jdbcProperties.getPassword()); return dataSource; &#125;&#125; 构造函数注入12345678910111213141516@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; private JdbcProperties jdbcProperties; public JdbcConfiguration(JdbcProperties jdbcProperties)&#123; this.jdbcProperties = jdbcProperties; &#125; @Bean public DataSource dataSource() &#123; // 略 &#125;&#125; @Bean方法的参数注入123456789@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; @Bean public DataSource dataSource(JdbcProperties jdbcProperties) &#123; // ... &#125;&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 3.4.注入到方法​ 事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfiguration &#123; @Bean //把方法的返回值注入容器 // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = &quot;jdbc&quot;) public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是： ​ 该类必须有对应属性的set方法！，也就是说这里的返回值dataSource对象的bean对象需要有对应属性的set方法，且必须名称一致 我们将jdbc的url改成：/heima，再次测试： 3.5.SpringBoot中的默认配置@EnableAutoConfiguration会开启SpringBoot的自动配置，并根据引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是怎么配置的，在哪里配置的呢？ 为何依赖引入就会触发配置呢？ 这些默认配置的属性来自哪里呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： 1）@Configuration：声明这个类是一个配置类 2）@ConditionalOnWebApplication(type = Type.SERVLET) ​ ConditionalOn，就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程。 3）@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;) ​ 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只 要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ 4）@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) ​ 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableConfigurationProperties注解引入了两个属性：WebMvcProperties和ResourceProperties。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 3.6.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 下面这些都可以在spring的官方文档中查得到 1）启动器 ​ 之所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 ​ 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591. Spring Boot application startersspring-boot-starter-thymeleaf使用Thymeleaf视图构建MVC Web应用程序spring-boot-starter-ws使用Spring Web服务。1.4不推荐使用，推荐使用spring-boot-starter-web-servicesspring-boot-starter-data-couchbaseStarter for using Couchbase document-oriented database and Spring Data Couchbasespring-boot-starter-artemis使用Apache Artemis启动JMS消息传递spring-boot-starter-web-services使用Spring Web服务spring-boot-starter-mail支持使用Java Mail和Spring Framework发送电子邮件spring-boot-starter-data-redis使用Redis键值数据存储与Spring Data Redis和Jedis客户端spring-boot-starter-web启动器构建web，包括RESTful，使用Spring MVC的应用程序。使用Tomcat作为默认嵌入式容器spring-boot-starter-data-gemfireStarter for using GemFire distributed data store and Spring Data GemFirespring-boot-starter-activemq使用Apache ActiveMQ启动JMS消息传递spring-boot-starter-data-elasticsearch使用Elasticsearch搜索和分析引擎和Spring Data Elasticsearchspring-boot-starter-integrationStarter for using Spring Integrationspring-boot-starter-testSpring Boot应用程序用于测试包括JUnit，Hamcrest和Mockitospring-boot-starter-hornetq使用HornetQ启动JMS消息传递。1.4已弃用，推荐使用spring-boot-starter-artemisspring-boot-starter-jdbc使用HikariCP连接池spring-boot-starter-mobile使用Spring Mobile构建Web应用程序的入门spring-boot-starter-validation使用Java Bean校验与Hibernate校验器spring-boot-starter-hateoas使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序的入门spring-boot-starter-jersey使用JAX-RS和Jersey构建RESTful Web应用程序的入门。 spring-boot-starter-web的替代品spring-boot-starter-data-neo4j使用Neo4j图数据库和Spring Data Neo4jspring-boot-starter-websocket使用Spring Framework的WebSocket支持构建WebSocket应用程序spring-boot-starter-aop使用Spring AOP和AspectJ进行面向方面编程spring-boot-starter-amqp使用Spring AMQP和Rabbit MQ的入门spring-boot-starter-data-cassandra使用Cassandra分布式数据库和Spring Data Cassandraspring-boot-starter-social-facebook使用Spring Social Facebookspring-boot-starter-jta-atomikos使用Atomikos进行JTA事务spring-boot-starter-security使用Spring Securityspring-boot-starter-mustache使用Mustache视图构建MVC Web应用程序spring-boot-starter-data-jpa使用Spring Data JPA与Hibernatespring-boot-starter核心启动器，包括自动配置支持，日志记录和YAMLspring-boot-starter-velocity使用Velocity视图构建MVC Web应用程序。1.4已弃用spring-boot-starter-groovy-templates使用Groovy模板视图构建MVC Web应用程序spring-boot-starter-freemarker使用FreeMarker视图构建MVC Web应用程序spring-boot-starter-batch使用Spring Batchspring-boot-starter-redis使用Redis键值数据存储与Spring Data Redis和Jedis客户端的入门。1.4已弃用，建议使用spring-boot-starter-data-redisspring-boot-starter-social-linkedinStater for using Spring Social LinkedInspring-boot-starter-cache支持使用Spring Framework的缓存spring-boot-starter-data-solr使用带有Spring Data Solr的Apache Solr搜索平台spring-boot-starter-data-mongodb使用MongoDB和Spring Data MongoDBspring-boot-starter-jooq使用jOOQ访问SQL数据库。 spring-boot-starter-data-jpa或spring-boot-starter-jdbc的替代方法spring-boot-starter-jta-narayanaSpring Boot启动Narayana JTAspring-boot-starter-cloud-connectors启动者使用Spring Cloud连接器，简化了连接到云平台中的服务，如Cloud Foundry和Herokuspring-boot-starter-jta-bitronix使用Bitronix进行JTA事务spring-boot-starter-social-twitter使用Spring Social Twitterspring-boot-starter-data-rest使用Spring Data REST通过REST暴露Spring数据存储库2. Spring Boot production startersspring-boot-starter-actuator使用Spring Boot的Actuator，提供生产就绪的功能，以帮助您监视和管理您的应用程序spring-boot-starter-remote-shell使用CRaSH远程shell通过SSH监视和管理您的应用程序3. Spring Boot technical startersspring-boot-starter-undertow使用Undertow作为嵌入式servlet容器。 spring-boot-starter-tomcat的替代方法spring-boot-starter-jetty使用Jetty作为嵌入式servlet容器的。 spring-boot-starter-tomcat的替代方法spring-boot-starter-logging使用Logback进行日志记录。 默认日志启动器spring-boot-starter-tomcat使用Tomcat作为嵌入式servlet容器。 spring-boot-starter-web使用的默认servlet容器spring-boot-starter-log4j2使用Log4j2进行日志记录。 spring-boot-starter-logging的替代方法 2）全局配置 ​ 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 （tips：springboot默认配置文件：application.properties application.yml，都是配置文件但只能存在一个） ​ 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考《资料》提供的：《SpringBoot全局属性.md》 4.SpringBoot实战接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 4.1.创建工程 4.2.编写基本代码1.pom.xml中引入启动器 2.添加覆盖默认配置(application.properties/yml) 3.添加引导类 4.编写controller代码 pom.xml: 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.user&lt;/groupId&gt; &lt;artifactId&gt;itcast-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 以下均为需引入的依赖，可在官方参考文档中查询 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 参照上边的项目，编写引导类： 1234567@SpringBootApplicationpublic class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class,args); &#125;&#125; 编写UserController： 123456789@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @GetMapping(&quot;hello&quot;) public String test()&#123; return &quot;hello ssm&quot;; &#125;&#125; 4.3.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 4.3.1.修改端口添加全局配置文件：application.properties 端口通过以下方式配置 12# 映射端口server.port=80 重启服务后测试： 4.3.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理，且访问时不需要带前缀static，resources等。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 4.3.3.添加拦截器配置拦截器： 1）声明该类是一个java配置类,@Configuration 2）实现WebMvcConfigurer接口 ​ 拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer**，并且添加@Configuration注解，但是千万不要**加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结： ​ 通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 实现如下： 1）首先我们定义一个拦截器implements HandlerInterceptor： 123456789101112131415161718@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle method is running!&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle method is running!&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion method is running!&quot;); &#125;&#125; 2）然后定义配置类，注册拦截器： 12345678910111213141516@Configurationpublic class MvcConfiguration implements WebMvcConfigurer &#123; @Autowired private HandlerInterceptor myInterceptor; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * /**拦截多级，也就是任意级 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;); &#125;&#125; 接下来运行并查看日志： 123preHandle method is running!postHandle method is running!afterCompletion method is running! ​ 你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。 3）SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名（在application.properties中添加即可） 12# 设置org.springframework包的日志级别为debuglogging.level.org.springframework=debug 再次运行查看： 4.4.整合连接池jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 1）在pom.xml中引入jdbc的启动器： 12345678910&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=root# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器，同样也需要指定驱动： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同（也就是不改变四大参数的配置，只改动特有属性）： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 4.5.整合mybatis4.5.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官方自己实现了： http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 1234567891011121314151617&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的（同样也和上节相同需要四大参数）： 1234# mybatis 别名扫描mybatis.type-aliases-package=cn.itcast.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/**/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; user对象参照课前资料，需要通用mapper的注解： 1234567891011121314151617@Table(name = &quot;tb_user&quot;)public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String userName; private String password; private String name; private Integer age; private Integer sex; private Date birthday; private Date created; private Date updated; ...get set方法&#125; 接下来，就去集成通用mapper。 4.5.1.1 @Mapper1234567891011121314151617181920/** * 添加了@Mapper注解之后这个接口在编译时会生成相应的实现类 * * 需要注意的是：这个接口中不可以定义同名的方法，因为会生成相同的id * 也就是说这个接口是不支持重载的 */@Mapperpublic interface UserDAO &#123; @Select(&quot;select * from user where name = #&#123;name&#125;&quot;) public User find(String name); @Select(&quot;select * from user where name = #&#123;name&#125; and pwd = #&#123;pwd&#125;&quot;) /** * 对于多个参数来说，每个参数之前都要加上@Param注解， * 要不然会找不到对应的参数进而报错 */ public User login(@Param(&quot;name&quot;)String name, @Param(&quot;pwd&quot;)String pwd);&#125; 4.5.2.通用mapperAPI：https://apidoc.gitee.com/free/Mapper/ 文档：https://github.com/abel533/Mapper 通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 不需要做任何配置就可以使用了。 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 4.5.3 service部分12345678910@Servicepublic class UserService&#123; @Autowired private UserMapper userMapper; public User queryUserById(long id)&#123; // 根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号 return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 4.6.整合事务其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 12345678910111213141516@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; // 根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号 return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 4.6.1 controller部分123456789101112@Controller@RequestMapping(&quot;user&quot;)public class UserController&#123; @Autowired private UserSerivice userService; @GetMapping(&quot;$&#123;id&#125;&quot;) @ResponseBody public User queryUserById(@PathVariable(&quot;id&quot;) long id)&#123; return this.userService.queryUserById(id); &#125;&#125; 4.7.启动测试在UserController中添加测试方法，内容： 1234567891011121314151617@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;&#123;id&#125;&quot;) public User queryUserById(@PathVariable(&quot;id&quot;)Long id)&#123; return this.userService.queryById(id); &#125; @GetMapping(&quot;hello&quot;) public String test()&#123; return &quot;hello ssm&quot;; &#125;&#125; 我们启动项目，查看： 4.8.完整项目结构 完整的pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.user&lt;/groupId&gt; &lt;artifactId&gt;itcast-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用mapper --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 完整的application.properties： 123456789101112server.port=80logging.level.org.springframework=debugspring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=root# mybatis 别名扫描mybatis.type-aliases-package=cn.itcast.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉# mybatis.mapper-locations=classpath:mappers/*.xml 4.9 小结12345678910111213141516171819整合springMVC 1.修改端口(server.port=8888) 2.访问静态资源(classpath:...) 3.拦截器： 1)自定义拦截器：实现HandlerInterceptor接口 2)配置拦截器：自定义一个java配置类(@Configuration)，实现WebMvcConfigurer接口整合数据源 1.引入jdbc启动器与mysql驱动 2.添加配置：spring.dataSource.url/password/username整合mybatis 1.引入启动器 2.覆盖默认配置：mybatis.type-aliases-package=cn.cxh.pojo.user mybatis.mapper-locations=classpath:mybatis/mappers/**/*.xml 3.代码：定义一个接口，在接口上添加@Mapper注解整合通用mapper 1.引入启动器 2.代码：接口继承Mapper&lt;User&gt;整合事务： 添加@Transactional 5.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 5.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 5.2.提供数据的Controller编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染 123456789@GetMapping(&quot;/all&quot;)public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute(&quot;users&quot;, users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return &quot;users&quot;;&#125; service部分代码： 123public List&lt;User&gt; queryUserAll()&#123; return this.userMapper.selectAll();&#125; 5.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 5.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： ​ 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;text-align: center&quot;&gt; &lt;span style=&quot;color: darkslategray; font-size: 30px&quot;&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class=&quot;list&quot;&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt;·· &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;user : $&#123;users&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;1&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;张三&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.userName&#125;&quot;&gt;zhangsan&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;20&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.sex&#125;&quot;&gt;男&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.birthday&#125;&quot;&gt;1980-02-30&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： $&#123;&#125; ：这个类似el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;$&#123;user.id&#125;&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 5.5.测试接下来，我们打开页面测试一下： 5.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用，在application.properties中修改： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： 在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。 eclipse中没有测试过。 注意引入启动器后，需要import changes，并在右侧的maven处再次import 我们可以修改页面，测试一下。 6.小结123456789101112131415161718192021222324252627282930313233343536373839404142434445461.什么是springboot 搭建spring应用的脚手架，内置tomcat。打包成jar，自动配置（根据引入的依赖） 简化的依赖管理 简化配置 2.java配置 原生的java配置 1.@Configuration`` 2.@Bean:把方法的返回值注入到spring容器中 3.@Value 4.@PropertySource springboot提供的java配置 1.@ConfigurationProperties(prefix=&quot;jdbc&quot;):声明一个类是一个属性读取类，读取application.properties 2.@EnableConfigurationProperties 1 @Autowired注入 2 构造方法注入 3 通过@Bean方法参数注入 4 直接在@Bean方法上使用@ConfigurationProperties(prefix=&quot;jdbc&quot;)3.springboot的基本使用 搭建springboot基本应用 1.引入统一的父工程以及需要的启动器 2.覆盖默认配置 3.添加引导类：@SpringBootApplication(@EnableAutoConfiguration @ComponentScan @SpringBootConfiguration) 整合springMVC 1.修改端口(server.port=8888) 2.访问静态资源(classpath:...) 3.拦截器： 1)自定义拦截器：实现HandlerInterceptor接口 2)配置拦截器：自定义一个java配置类(@Configuration)，实现WebMvcConfigurer接口 整合数据源 1.引入jdbc启动器与mysql驱动,内置hikariCP 2.添加配置：spring.dataSource.url/password/username 整合mybatis 1.引入启动器 2.覆盖默认配置：mybatis.type-aliases-package=cn.cxh.pojo.user mybatis.mapper-locations=classpath:mybatis/mappers/**/*.xml 3.代码：定义一个接口，在接口上添加@Mapper注解 整合通用mapper 1.引入启动器 2.代码：接口机型Mapper&lt;User&gt; 整合事务： 添加@Transactional","categories":[{"name":"乐优商城","slug":"乐优商城","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"},{"name":"springboot与thymeleaf","slug":"乐优商城/springboot与thymeleaf","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/springboot%E4%B8%8Ethymeleaf/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://mrchen229.github.io/tags/springboot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://mrchen229.github.io/tags/thymeleaf/"}]}],"categories":[{"name":"乐优商城","slug":"乐优商城","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"},{"name":"后台前端_Vuetify_nginx反向代理_商品分类(JPA_通用Mapper)_cors跨域_品牌查询(axios_分页和过滤)","slug":"乐优商城/后台前端-Vuetify-nginx反向代理-商品分类-JPA-通用Mapper-cors跨域-品牌查询-axios-分页和过滤","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF-Vuetify-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB-JPA-%E9%80%9A%E7%94%A8Mapper-cors%E8%B7%A8%E5%9F%9F-%E5%93%81%E7%89%8C%E6%9F%A5%E8%AF%A2-axios-%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/"},{"name":"Vue_router_webpack_cli","slug":"乐优商城/Vue-router-webpack-cli","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/Vue-router-webpack-cli/"},{"name":"乐优商城结构_基本框架_ES6","slug":"乐优商城/乐优商城结构-基本框架-ES6","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6-ES6/"},{"name":"SpringCloud","slug":"乐优商城/SpringCloud","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/SpringCloud/"},{"name":"集合","slug":"集合","permalink":"https://mrchen229.github.io/categories/%E9%9B%86%E5%90%88/"},{"name":"常用API","slug":"常用API","permalink":"https://mrchen229.github.io/categories/%E5%B8%B8%E7%94%A8API/"},{"name":"继承与多态","slug":"继承与多态","permalink":"https://mrchen229.github.io/categories/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"},{"name":"面向对象和封装","slug":"面向对象和封装","permalink":"https://mrchen229.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/"},{"name":"Java基础","slug":"Java基础","permalink":"https://mrchen229.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"springboot与thymeleaf","slug":"乐优商城/springboot与thymeleaf","permalink":"https://mrchen229.github.io/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/springboot%E4%B8%8Ethymeleaf/"}],"tags":[{"name":"Vuetify","slug":"Vuetify","permalink":"https://mrchen229.github.io/tags/Vuetify/"},{"name":"nginx反向代理解决端口问题","slug":"nginx反向代理解决端口问题","permalink":"https://mrchen229.github.io/tags/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/"},{"name":"cors解决跨域","slug":"cors解决跨域","permalink":"https://mrchen229.github.io/tags/cors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"},{"name":"异步查询axios","slug":"异步查询axios","permalink":"https://mrchen229.github.io/tags/%E5%BC%82%E6%AD%A5%E6%9F%A5%E8%AF%A2axios/"},{"name":"分页和过滤","slug":"分页和过滤","permalink":"https://mrchen229.github.io/tags/%E5%88%86%E9%A1%B5%E5%92%8C%E8%BF%87%E6%BB%A4/"},{"name":"Vue实例的常见属性","slug":"Vue实例的常见属性","permalink":"https://mrchen229.github.io/tags/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7/"},{"name":"Vue生命周期的钩子函数","slug":"Vue生命周期的钩子函数","permalink":"https://mrchen229.github.io/tags/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"},{"name":"vue常见指令","slug":"vue常见指令","permalink":"https://mrchen229.github.io/tags/vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"},{"name":"Vue全局组件与局部注册","slug":"Vue全局组件与局部注册","permalink":"https://mrchen229.github.io/tags/Vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C/"},{"name":"vue_router使用","slug":"vue-router使用","permalink":"https://mrchen229.github.io/tags/vue-router%E4%BD%BF%E7%94%A8/"},{"name":"webpack使用","slug":"webpack使用","permalink":"https://mrchen229.github.io/tags/webpack%E4%BD%BF%E7%94%A8/"},{"name":"使用vue_cli搭建项目","slug":"使用vue-cli搭建项目","permalink":"https://mrchen229.github.io/tags/%E4%BD%BF%E7%94%A8vue-cli%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"name":"乐优商城结构","slug":"乐优商城结构","permalink":"https://mrchen229.github.io/tags/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E7%BB%93%E6%9E%84/"},{"name":"基本框架搭建(EurekaServer_zuul_item_common)","slug":"基本框架搭建-EurekaServer-zuul-item-common","permalink":"https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA-EurekaServer-zuul-item-common/"},{"name":"ES6语法","slug":"ES6语法","permalink":"https://mrchen229.github.io/tags/ES6%E8%AF%AD%E6%B3%95/"},{"name":"Hystrix(降级_熔断)","slug":"Hystrix-降级-熔断","permalink":"https://mrchen229.github.io/tags/Hystrix-%E9%99%8D%E7%BA%A7-%E7%86%94%E6%96%AD/"},{"name":"Feign","slug":"Feign","permalink":"https://mrchen229.github.io/tags/Feign/"},{"name":"Zuul","slug":"Zuul","permalink":"https://mrchen229.github.io/tags/Zuul/"},{"name":"ZuulFilter","slug":"ZuulFilter","permalink":"https://mrchen229.github.io/tags/ZuulFilter/"},{"name":"系统架构演变","slug":"系统架构演变","permalink":"https://mrchen229.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/"},{"name":"RPC_HTTP_RestTemplate","slug":"RPC-HTTP-RestTemplate","permalink":"https://mrchen229.github.io/tags/RPC-HTTP-RestTemplate/"},{"name":"Springcloud概念","slug":"Springcloud概念","permalink":"https://mrchen229.github.io/tags/Springcloud%E6%A6%82%E5%BF%B5/"},{"name":"搭建Eureka(注册中心_提供_消费)","slug":"搭建Eureka-注册中心-提供-消费","permalink":"https://mrchen229.github.io/tags/%E6%90%AD%E5%BB%BAEureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E6%8F%90%E4%BE%9B-%E6%B6%88%E8%B4%B9/"},{"name":"Eureka配置(心跳_获取服务列表_失效剔除_自我保护)","slug":"Eureka配置-心跳-获取服务列表-失效剔除-自我保护","permalink":"https://mrchen229.github.io/tags/Eureka%E9%85%8D%E7%BD%AE-%E5%BF%83%E8%B7%B3-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8-%E5%A4%B1%E6%95%88%E5%89%94%E9%99%A4-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/"},{"name":"Ribbon配置与负载均衡策略","slug":"Ribbon配置与负载均衡策略","permalink":"https://mrchen229.github.io/tags/Ribbon%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"},{"name":"栈_队列_数组_链表_红黑树","slug":"栈-队列-数组-链表-红黑树","permalink":"https://mrchen229.github.io/tags/%E6%A0%88-%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://mrchen229.github.io/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://mrchen229.github.io/tags/LinkedList/"},{"name":"HashSet","slug":"HashSet","permalink":"https://mrchen229.github.io/tags/HashSet/"},{"name":"可变参数","slug":"可变参数","permalink":"https://mrchen229.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"},{"name":"Collections工具类","slug":"Collections工具类","permalink":"https://mrchen229.github.io/tags/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Comparable与Comparator","slug":"Comparable与Comparator","permalink":"https://mrchen229.github.io/tags/Comparable%E4%B8%8EComparator/"},{"name":"Collection集合","slug":"Collection集合","permalink":"https://mrchen229.github.io/tags/Collection%E9%9B%86%E5%90%88/"},{"name":"Iterator迭代器","slug":"Iterator迭代器","permalink":"https://mrchen229.github.io/tags/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"增强for","slug":"增强for","permalink":"https://mrchen229.github.io/tags/%E5%A2%9E%E5%BC%BAfor/"},{"name":"泛型类_方法_接口","slug":"泛型类-方法-接口","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%96%B9%E6%B3%95-%E6%8E%A5%E5%8F%A3/"},{"name":"泛型通配符","slug":"泛型通配符","permalink":"https://mrchen229.github.io/tags/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"},{"name":"Object类(toString_equals)","slug":"Object类-toString-equals","permalink":"https://mrchen229.github.io/tags/Object%E7%B1%BB-toString-equals/"},{"name":"Objects类","slug":"Objects类","permalink":"https://mrchen229.github.io/tags/Objects%E7%B1%BB/"},{"name":"Date类","slug":"Date类","permalink":"https://mrchen229.github.io/tags/Date%E7%B1%BB/"},{"name":"DateFormat类(Date与String之间的转换)","slug":"DateFormat类-Date与String之间的转换","permalink":"https://mrchen229.github.io/tags/DateFormat%E7%B1%BB-Date%E4%B8%8EString%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"name":"Calendar类(方便获取各个时间属性)","slug":"Calendar类-方便获取各个时间属性","permalink":"https://mrchen229.github.io/tags/Calendar%E7%B1%BB-%E6%96%B9%E4%BE%BF%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"},{"name":"System类","slug":"System类","permalink":"https://mrchen229.github.io/tags/System%E7%B1%BB/"},{"name":"StringBuilder类","slug":"StringBuilder类","permalink":"https://mrchen229.github.io/tags/StringBuilder%E7%B1%BB/"},{"name":"包装类与自动拆装箱","slug":"包装类与自动拆装箱","permalink":"https://mrchen229.github.io/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"},{"name":"基本类型与字符串之间的转换","slug":"基本类型与字符串之间的转换","permalink":"https://mrchen229.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"name":"final关键字","slug":"final关键字","permalink":"https://mrchen229.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"权限修饰符","slug":"权限修饰符","permalink":"https://mrchen229.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"成员内部类","slug":"成员内部类","permalink":"https://mrchen229.github.io/tags/%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"https://mrchen229.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"引用类型用法(class interface)","slug":"引用类型用法-class-interface","permalink":"https://mrchen229.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95-class-interface/"},{"name":"接口成员的定义","slug":"接口成员的定义","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"name":"接口多实现方法细节","slug":"接口多实现方法细节","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82/"},{"name":"接口的限制","slug":"接口的限制","permalink":"https://mrchen229.github.io/tags/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%99%90%E5%88%B6/"},{"name":"多态的前提","slug":"多态的前提","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90/"},{"name":"多态的上下转型","slug":"多态的上下转型","permalink":"https://mrchen229.github.io/tags/%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B/"},{"name":"instanceof","slug":"instanceof","permalink":"https://mrchen229.github.io/tags/instanceof/"},{"name":"三大特性之继承","slug":"三大特性之继承","permalink":"https://mrchen229.github.io/tags/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"},{"name":"super关键字","slug":"super关键字","permalink":"https://mrchen229.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"this关键字","slug":"this关键字","permalink":"https://mrchen229.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"abstract方法与abstract类","slug":"abstract方法与abstract类","permalink":"https://mrchen229.github.io/tags/abstract%E6%96%B9%E6%B3%95%E4%B8%8Eabstract%E7%B1%BB/"},{"name":"Scanner类","slug":"Scanner类","permalink":"https://mrchen229.github.io/tags/Scanner%E7%B1%BB/"},{"name":"Random类","slug":"Random类","permalink":"https://mrchen229.github.io/tags/Random%E7%B1%BB/"},{"name":"ArrayList类","slug":"ArrayList类","permalink":"https://mrchen229.github.io/tags/ArrayList%E7%B1%BB/"},{"name":"String类的常用方法","slug":"String类的常用方法","permalink":"https://mrchen229.github.io/tags/String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"Arrays类的方法","slug":"Arrays类的方法","permalink":"https://mrchen229.github.io/tags/Arrays%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"},{"name":"Math类","slug":"Math类","permalink":"https://mrchen229.github.io/tags/Math%E7%B1%BB/"},{"name":"static变量_static方法_static代码块","slug":"static变量-static方法-static代码块","permalink":"https://mrchen229.github.io/tags/static%E5%8F%98%E9%87%8F-static%E6%96%B9%E6%B3%95-static%E4%BB%A3%E7%A0%81%E5%9D%97/"},{"name":"类与对象","slug":"类与对象","permalink":"https://mrchen229.github.io/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"name":"对象内存图","slug":"对象内存图","permalink":"https://mrchen229.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"封装private","slug":"封装private","permalink":"https://mrchen229.github.io/tags/%E5%B0%81%E8%A3%85private/"},{"name":"this","slug":"this","permalink":"https://mrchen229.github.io/tags/this/"},{"name":"构造","slug":"构造","permalink":"https://mrchen229.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://mrchen229.github.io/tags/JavaBean/"},{"name":"一维数组定义与索引","slug":"一维数组定义与索引","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%B4%A2%E5%BC%95/"},{"name":"一维数组内存图","slug":"一维数组内存图","permalink":"https://mrchen229.github.io/tags/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE/"},{"name":"数组作为方法参数与返回值","slug":"数组作为方法参数与返回值","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/"},{"name":"数组常见操作","slug":"数组常见操作","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"},{"name":"IDEA使用","slug":"IDEA使用","permalink":"https://mrchen229.github.io/tags/IDEA%E4%BD%BF%E7%94%A8/"},{"name":"方法重载与执行","slug":"方法重载与执行","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"},{"name":"判断语句","slug":"判断语句","permalink":"https://mrchen229.github.io/tags/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"},{"name":"选择语句","slug":"选择语句","permalink":"https://mrchen229.github.io/tags/%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"},{"name":"循环语句","slug":"循环语句","permalink":"https://mrchen229.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数据类型转换","slug":"数据类型转换","permalink":"https://mrchen229.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"运算符细节","slug":"运算符细节","permalink":"https://mrchen229.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%86%E8%8A%82/"},{"name":"方法定义","slug":"方法定义","permalink":"https://mrchen229.github.io/tags/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"},{"name":"进制转换","slug":"进制转换","permalink":"https://mrchen229.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"name":"Java开发过程","slug":"Java开发过程","permalink":"https://mrchen229.github.io/tags/Java%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/"},{"name":"常量与数据类型","slug":"常量与数据类型","permalink":"https://mrchen229.github.io/tags/%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"springboot","slug":"springboot","permalink":"https://mrchen229.github.io/tags/springboot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://mrchen229.github.io/tags/thymeleaf/"}]}